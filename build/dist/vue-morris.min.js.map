{"version":3,"sources":["webpack:///vue-morris.min.js","webpack:///webpack/bootstrap a92ee7b6912111d1a0e9","webpack:///./src/components/chart-props.js","webpack:///./src/util/converter.js","webpack:///./~/morris.js/morris.js","webpack:///./~/raphael/raphael.js","webpack:///./~/morris.js/morris.css?ee78","webpack:///(webpack)/buildin/global.js","webpack:///./src/components/area-chart.vue","webpack:///./src/components/bar-chart.vue","webpack:///./src/components/donut-chart.vue","webpack:///./src/components/line-chart.vue","webpack:///area-chart.vue","webpack:///bar-chart.vue","webpack:///donut-chart.vue","webpack:///line-chart.vue","webpack:///./~/morris.js/morris.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./src/components/line-chart.vue?67c5","webpack:///./src/components/donut-chart.vue?fa71","webpack:///./src/components/bar-chart.vue?0cb4","webpack:///./src/components/area-chart.vue?e29f","webpack:///./~/vue-style-loader/addStyles.js","webpack:///./src/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Props","id","type","String","required","data","Array","barColors","xkey","default","ykeys","labels","hoverCallback","Function","axes","Boolean","hideHover","stacked","resize","grid","gridTextColor","gridTextSize","Number","gridTextFamily","gridTextWeight","colors","formatter","lineColors","xLabels","ChartProps","bar","props","donut","line","area","Converter","toObject","JSON","parse","toBoolean","toInt","parseInt","$","Morris","minutesSpecHelper","secondsSpecHelper","__slice","slice","__bind","fn","me","apply","arguments","__hasProp","__extends","child","parent","ctor","this","constructor","key","__super__","__indexOf","indexOf","item","length","window","jQuery","EventEmitter","on","handler","handlers","push","fire","args","_i","_len","_ref","_results","commas","num","absnum","intnum","ret","strabsnum","Math","abs","floor","toFixed","replace","toString","pad2","number","Grid","_super","options","resizeHandler","_this","element","el","document","getElementById","Error","css","extend","gridDefaults","defaults","units","postUnits","raphael","Raphael","elementWidth","elementHeight","dirty","selectFrom","init","setData","bind","evt","left","offset","right","width","x","pageX","hitTest","min","_x","max","selectionRect","attr","pageY","top","hide","touch","originalEvent","touches","changedTouches","rangeSelect","rect","innerHeight","fill","rangeSelectColor","stroke","toBack","startRange","endRange","timeoutId","clearTimeout","setTimeout","postInit","dateFormat","gridLineColor","gridStrokeWidth","yLabelFormat","xLabelAngle","numLines","padding","parseTime","preUnits","ymax","ymin","goals","goalStrokeWidth","goalLineColors","events","eventStrokeWidth","eventLineColors","redraw","e","idx","index","maxGoal","minGoal","row","step","total","y","ykey","yval","clear","hover","cumulative","src","label","parseDate","Date","xLabelFormat","_j","_len1","_results1","parseFloat","sort","a","b","xmin","xmax","yboundary","autoGridLines","_ref1","_ref2","boundaryType","currentValue","boundaryOption","suggestedValue","nlines","gmax","gmin","smag","span","unit","ymag","log","pow","ceil","_calc","bottomOffsets","gridLine","h","w","yLabelWidths","height","bottom","measureText","yAxisFormat","text","dx","dy","calc","transY","transX","drawGrid","drawGoals","drawEvents","draw","angle","tt","rotate","getBBox","remove","lineY","drawYAxisLabel","drawGridLine","color","goal","drawGoal","event","drawEvent","path","xPos","yPos","show","end","start","setSize","date","isecs","msecs","offsetmins","q","r","secs","match","getTime","getDay","setMonth","UTC","round","Hover","append","class","update","html","moveTo","content","hoverHeight","hoverWidth","parentHeight","parentWidth","innerWidth","outerWidth","outerHeight","Line","hilight","onHoverOut","onHoverMove","onGridClick","lineWidth","pointSize","pointStrokeWidths","pointStrokeColors","pointFillColors","smooth","xLabelMargin","calcPoints","generatePaths","_y","_ymax","concat","displayHoverForRow","hoverContentForRow","j","colorFor","coords","paths","createPath","drawXAxis","drawSeries","drawLabel","prevAngleMargin","prevLabelMargin","ypos","labelText","xpos","labelBox","margin","textBox","drawXAxisLabel","transform","cos","PI","sin","labelSeries","reverse","seriesPoints","_drawLineFor","_drawPointFor","circle","drawLinePoint","drawLinePath","coord","g","grads","ix","lg","prevCoord","x1","x2","y1","y2","gradients","grad","nextCoord","prevHilight","animate","pointShrinkSeries","pointGrowSeries","sidx","lineColor","lineIndex","lineWidthForSeries","pointColor","pointSizeForSeries","pointStrokeWidthForSeries","pointStrokeColorForSeries","animation","dmin","dmax","pxwidth","specName","d0","ddensity","spec","t","LABEL_SPECS","AUTO_LABEL_ORDER","fmt","incr","interval","getFullYear","getMonth","getDate","getHours","getMinutes","setUTCMinutes","getUTCMinutes","getSeconds","setUTCSeconds","getUTCSeconds","decade","setFullYear","year","month","week","setDate","day","hour","30min","15min","10min","5min","minute","30sec","15sec","10sec","5sec","second","Area","areaOptions","areaDefaults","behaveLikeLine","fillOpacity","range","_k","_results2","_drawFillFor","drawFilledPath","fillForSeries","rgb2hsl","hsl","Bar","barSizeRatio","barGap","barOpacity","barRadius","calcBars","xAxisLabelTopPadding","barWidth","groupWidth","lastTop","leftPadding","numBars","size","spaceLeft","zeroPos","barSize","bars","verticalGridCondition","drawBar","verticalGridColor","verticalGridOpacity","barColor","opacity","radiusArray","maxRadius","roundedRect","Donut","select","click","backgroundColor","labelColor","C","cx","cy","last","max_value","next","seg","_len2","values","segments","DonutSegment","render","text1","drawEmptyDonutLabel","text2","segment","deselect","setLabels","label1","label2","inner","maxHeightBottom","maxHeightTop","maxWidth","text1bbox","text1scale","text2bbox","text2scale","fontSize","fontWeight","outer","p0","p1","sin_p0","cos_p0","sin_p1","cos_p1","is_long","calcSegment","selectedPath","calcArc","calcArcPoints","r1","r2","ix0","ix1","iy0","iy1","ox0","ox1","oy0","oy1","arc","drawDonutArc","drawDonutSegment","stroke-width","fillColor","strokeColor","hoverFunction","clickFunction","selected","root","factory","loaded","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","R","undefined","eve","first","is","array","_engine","create","splice","nu","add","f","pop","clone","obj","res","has","repush","ii","cacher","scope","postprocessor","newf","arg","join","cache","count","shift","clrToString","hex","catmullRom2bezier","crp","z","iLen","base3","p2","p3","p4","t1","t2","bezlen","x3","y3","x4","y4","z2","Tvalues","Cvalues","sum","ct","xbase","ybase","comb","math","sqrt","getTatLen","ll","intersect","mmax","mmin","nx","ny","denominator","px","py","px2","py2","interHelper","bez1","bez2","justCount","bbox1","bezierBBox","bbox2","isBBoxIntersect","l1","l2","n1","n2","dots1","dots2","xy","findDotsAtSegment","di","di1","dj","dj1","ci","cj","interPathHelper","path1","path2","_path2curve","x1m","y1m","x2m","y2m","pi","jj","pj","intr","k","kk","segment1","segment2","Matrix","x_y_w_h","S","CubicBezierAtTime","p1x","p1y","p2x","p2y","duration","sampleCurveX","ax","bx","solve","epsilon","solveCurveX","ay","by","t0","d2","Animation","anim","ms","percents","newAnim","times","toFloat","sortByNumber","runAnimation","percent","status","totalOrigin","params","isInAnim","isInAnimSet","prev","timestamp","from","to","diff","animationElements","initstatus","availableAnimAttrs","paper","customAttributes","availableAttrs","getRGB","toColour","pathes","path2curve","toPath","_","eq","equaliseTransform","real","matrix","to2","extractTransform","Str","split","separator","from2","easing","easyeasy","easing_formulas","bezierrg","curve","pipe","del","stop","callback","repeat","origin","requestAnimFrame","stopAnimation","version","paperproto","elements","ellipse","image","formatrg","doc","win","oldRaphael","was","Paper","ca","supportsTouch","DocumentTouch","E","touchMap","mousedown","mousemove","mouseup","lowerCase","toLowerCase","string","objectToString","colourRegExp","_ISURL","isnan","NaN","Infinity","-Infinity","upperCase","toUpperCase","_availableAttrs","arrow-end","arrow-start","blur","clip-rect","cursor","fill-opacity","font","font-family","font-size","font-style","font-weight","gradient","href","letter-spacing","rx","ry","stroke-dasharray","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","target","text-anchor","title","_availableAnimAttrs","commaSpaces","hsrg","hs","rg","p2s","pathCommand","tCommand","pathValues","eldata","_radial_gradient","rectPath","_rectPath","ellipsePath","getPath","_getPath","attrs","bbox","_getBBox","set","mapPath","pathi","_g","SVGAngle","implementation","hasFeature","createElement","innerHTML","firstChild","style","behavior","adj","svg","vml","_Paper","_id","isArray","atan2","rad","deg","snapTo","tolerance","rem","createUUID","uuidRegEx","uuidReplacer","random","v","setWindow","newwin","initWin","toHex","bod","trim","docum","ActiveXObject","write","close","body","createPopup","createTextRange","queryCommandValue","display","appendChild","defaultView","getComputedStyle","getPropertyValue","hsbtoString","hsltoString","rgbtoString","prepareRGB","clr","packageRGB","rgb","hsb2rgb","hsl2rgb","rgb2hsb","G","B","X","H","V","L","M","_path2string","_preload","img","cssText","onload","removeChild","onerror","colour","error","substring","charAt","red","green","blue","hsb","getColor","reset","parsePathString","pathString","pth","arr","pathClone","paramCounts","parseTransformString","TString","ps","sleep","c1x","c1y","c2x","c2y","t13","t12","t3","mx","my","alpha","curveDim","isPointInsideBBox","pathIntersection","pathIntersectionNumber","isPointInsidePath","pathBBox","_removedFactory","methodname","pathDimensions","Y","dim","bb","pathArray","pathToRelative","_pathToRelative","rel","pa","len","pathToAbsolute","_pathToAbsolute","crz","dots","l2c","q2c","_13","_23","a2c","large_arc_flag","sweep_flag","recursive","_120","f1","f2","rx2","ry2","asin","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","m1","m2","m3","m4","newres","findDotAtSegment","dot","qx","qy","attrs2","processPath","pcom","tq","T","Q","fixArc","pp","pcoms1","pcoms2","fixM","a1","a2","pfirst","seg2","seglen","seg2len","tear","_parseDots","par","_tear","toMatrix","_tofront","_toback","_insertafter","el2","_insertbefore","transformPath","_extractTransform","tstr","tdata","sx","sy","tlen","command","absolute","inver","invert","translate","scale","dirtyT","getEmpty","_equaliseTransform","tt1","tt2","maxlength","_getContainer","container","tagName","pixelWidth","offsetWidth","pixelHeight","offsetHeight","matrixproto","norm","normalize","mag","out","fromCharCode","toFilter","scalex","shear","scaley","acos","isSimple","isSuperSimple","noRotation","toTransformString","shorter","preventDefault","returnValue","preventTouch","stopPropagation","cancelBubble","stopTouch","getEventPosition","scrollY","documentElement","scrollTop","scrollX","scrollLeft","clientX","clientY","addEvent","addEventListener","pos","_f","olde","targetTouches","removeEventListener","attachEvent","detacher","detachEvent","drag","dragMove","dragi","identifier","_drag","node","nextSibling","parentNode","opera","getElementByPoint","insertBefore","move_scope","dragUp","unmousemove","unmouseup","end_scope","start_scope","elproto","eventName","unbind","shape","removeData","getData","f_in","f_out","scope_in","scope_out","mouseover","mouseout","unhover","unmouseover","unmouseout","draggable","onmove","onstart","onend","onDragOver","undrag","unmousedown","__set__","format","itemsArray","Set","setStart","setFinish","getSize","canvas","setViewBox","fit","getOffset","elem","box","getBoundingClientRect","ownerDocument","docElem","clientTop","clientLeft","pageYOffset","pageXOffset","elementFromPoint","so","sr","createSVGRect","hits","getIntersectionList","getById","raphaelid","getElementsByBBox","forEach","bot","thisArg","getElementsByPoint","isPointInside","rp","realPath","isWithoutTransform","removed","bboxwt","glow","offsetx","offsety","getPointAtSegmentLength","getLengthFactory","istotal","subpath","onlystart","point","sp","subpaths","getTotalLength","getPointAtLength","getSubpathsAtLength","getSubpath","ef","linear","<",">","<>","backIn","backOut","elastic","bounce","easeIn","easeOut","easeInOut","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","Now","paused","now","time","that","upto255","animateWith","onAnimation","delay","json","100","lastKey","setTime","pause","resume","items","setproto","method","insertion","tail","todel","arglen","exclude","collector","insertAfter","glowConfig","shape2","index2","registerFont","face","fonts","fontcopy","glyphs","family","prop","glyph","getFont","weight","stretch","normal","bold","lighter","bolder","RegExp","fontName","test","thefont","print","letter_spacing","line_spacing","letters","notfirst","lineHeight","shifty","descent","curr","token","str","fullfill","tokenRegex","objNotationRegex","replacer","all","quote","quotedName","isFunc","ninja","st","isLoaded","readyState","glob","current_event","comaseparator","wildcard","numsort","firstDefined","lastDefined","objtos","ar","oldstop","listeners","indexed","queue","ce","zIndex","_events","nes","names","es","sep","exist","nt","subname","cur","nts","off","funcs","once","xlink","markers","block","classic","diamond","open","oval","markerCounter","setAttributeNS","setAttribute","createElementNS","webkitTapHighlightColor","addGradientFill","fx","fy","SVG","_fx","_fy","dir","isNaN","vector","defs","gradientTransform","stop-color","stop-opacity","isFinite","fillurl","isIE9or10","mode","documentMode","location","locationString","protocol","host","pathname","search","updatePosition","pattern","patternTransform","addArrow","isEnd","refX","se","arrows","endPath","endMarker","startPath","startMarker","pathId","markerId","use","marker","getElementsByTagName","markerHeight","markerWidth","orient","refY","xlink:href","delta","startdx","enddx","dasharray","-",".","-.","-..",". ","- ","--","- .","--.","--..","addDashes","butt","square","dashes","setFillAndStroke","vis","visibility","att","nodeValue","val","createTextNode","pn","hl","clip","rc","clip-path","getAttribute","startString","endString","isURL","ig","patternUnits","stops","cssrule","tuneText","leading","tspan","texts","tspans","dif","getRealNode","Element","guid","sw","containerStyle","canvasHidden","parentElement","clientWidth","clientHeight","def","subkey","toFront","afterNode","beforeNode","fltr","stdDeviation","_blur","filter","removeAttribute","preserveAspectRatio","_viewBox","con","isFloating","cnvs","xmlns","xmlns:xlink","_left","_top","renderfix","vb","paperSize","aspectRatio","_vbSize","viewBox","getScreenCTM","createSVGMatrix","desc","fillString","map","Z","bites","blurregexp","cssDot","zoom","pathTypes","ovalTypes","path2vml","vals","isMove","compensation","setCoords","fillpos","flip","kx","ky","coordsize","rotation","coordorigin","fillsize","position","newpath","isOval","div","clipRect","dstyle","textpath","textpathStyle","fontFamily","fontStyle","newfill","createNode","newstroke","joinstyle","miterlimit","endcap","dashstyle","brect","W","dirtyattrs","dd","bbx","fxfy","color2","clrs","focus","focussize","focusposition","_oid","oldt","vbs","_viewBoxShift","vbt","skew","isGrad","isPatt","bbt","auxGetBBox","runtimeStyle","Path","textpathok","cs","styleSheets","createStyleSheet","addRule","namespaces","rvml","locals","eval","__vue_exports__","__vue_options__","__vue_template__","staticRenderFns","global","_interopRequireDefault","_raphael","_raphael2","_converter","_converter2","_chartProps","_chartProps2","mixins","chart","watch","$nextTick","mounted","console","list","result","mediaQuery","alreadyImportedModules","_vm","_h","$createElement","_c","_self","addStylesToDom","styles","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","createStyleElement","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","styleSheet","replaceText","cssNode","childNodes","sources","btoa","unescape","encodeURIComponent","stringify","memoize","memo","isOldIE","navigator","userAgent","DEBUG","newList","mayRemove","textStore","replacement","_donutChart","_donutChart2","_barChart","_barChart2","_lineChart","_lineChart2","_areaChart","_areaChart2","VueMorris","DonutChart","BarChart","LineChart","AreaChart"],"mappings":"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","file":"vue-morris.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n\nvar Props = {\n  id: { type: String, required: true },\n  data: { type: [String, Array], required: true },\n  barColors: { type: [String, Array], required: false },\n  xkey: { type: String, required: false, default: 'key' },\n  ykeys: { type: [String, Array], required: false, default: ['value'] },\n  labels: { type: [String, Array], required: false, default: ['Value'] },\n  hoverCallback: { type: Function, required: false },\n  axes: { type: [Boolean, String], required: false, default: true },\n  hideHover: { type: String, required: false },\n  stacked: { type: [Boolean, String], required: false },\n  resize: { type: [Boolean, String], required: false },\n  grid: { type: [Boolean, String], required: false, default: true },\n  gridTextColor: { type: String, required: false, default: '#888' },\n  gridTextSize: { type: [Number, String], required: false, default: 12 },\n  gridTextFamily: { type: String, required: false, default: 'sans-serif' },\n  gridTextWeight: { type: String, required: false, default: 'normal' },\n\n  colors: { type: [String, Array], required: false },\n  formatter: { type: Function, required: false },\n\n  lineColors: { type: [String, Array], required: false },\n  xLabels: { type: String, required: false }\n};\n\nvar ChartProps = {\n\n  bar: {\n    props: {\n      id: Props.id,\n      data: Props.data,\n      barColors: Props.barColors,\n      xkey: Props.xkey,\n      ykeys: Props.ykeys,\n      labels: Props.labels,\n      hoverCallback: Props.hoverCallback,\n      grid: Props.grid,\n      axes: Props.axes,\n      hideHover: Props.hideHover,\n      stacked: Props.stacked,\n      resize: Props.resize,\n      gridTextColor: Props.gridTextColor,\n      gridTextSize: Props.gridTextSize,\n      gridTextFamily: Props.gridTextFamily,\n      gridTextWeight: Props.gridTextWeight\n    }\n  },\n\n  donut: {\n    props: {\n      id: Props.id,\n      data: Props.data,\n      colors: Props.colors,\n      formatter: Props.formatter,\n      resize: Props.resize\n    }\n  },\n\n  line: {\n    props: {\n      id: Props.id,\n      data: Props.data,\n      resize: Props.resize,\n      lineColors: Props.lineColors,\n      xkey: Props.xkey,\n      ykeys: Props.ykeys,\n      labels: Props.labels,\n      xLabels: Props.xLabels,\n      grid: Props.grid,\n      gridTextColor: Props.gridTextColor,\n      gridTextSize: Props.gridTextSize,\n      gridTextFamily: Props.gridTextFamily,\n      gridTextWeight: Props.gridTextWeight\n    }\n  },\n\n  area: {\n    props: {\n      id: Props.id,\n      data: Props.data,\n      resize: Props.resize,\n      lineColors: Props.lineColors,\n      xkey: Props.xkey,\n      ykeys: Props.ykeys,\n      labels: Props.labels,\n      xLabels: Props.xLabels,\n      grid: Props.grid,\n      gridTextColor: Props.gridTextColor,\n      gridTextSize: Props.gridTextSize,\n      gridTextFamily: Props.gridTextFamily,\n      gridTextWeight: Props.gridTextWeight\n    }\n  }\n\n};\n\nexports.default = ChartProps;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nvar Converter = {\n  toObject: function toObject(data) {\n    if (typeof data === 'string') {\n      return JSON.parse(data);\n    }\n    return data;\n  },\n  toBoolean: function toBoolean(data) {\n    if (typeof data === 'string') {\n      return data === 'true';\n    }\n    return data;\n  },\n  toInt: function toInt(data) {\n    if (typeof data === 'string') {\n      return parseInt(data);\n    }\n    return data;\n  }\n};\n\nmodule.exports = Converter;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n/* @license\nmorris.js v0.5.0\nCopyright 2014 Olly Smith All rights reserved.\nLicensed under the BSD-2-Clause License.\n*/\n\n\n(function() {\n  var $, Morris, minutesSpecHelper, secondsSpecHelper,\n    __slice = [].slice,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Morris = window.Morris = {};\n\n  $ = jQuery;\n\n  Morris.EventEmitter = (function() {\n    function EventEmitter() {}\n\n    EventEmitter.prototype.on = function(name, handler) {\n      if (this.handlers == null) {\n        this.handlers = {};\n      }\n      if (this.handlers[name] == null) {\n        this.handlers[name] = [];\n      }\n      this.handlers[name].push(handler);\n      return this;\n    };\n\n    EventEmitter.prototype.fire = function() {\n      var args, handler, name, _i, _len, _ref, _results;\n      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if ((this.handlers != null) && (this.handlers[name] != null)) {\n        _ref = this.handlers[name];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          handler = _ref[_i];\n          _results.push(handler.apply(null, args));\n        }\n        return _results;\n      }\n    };\n\n    return EventEmitter;\n\n  })();\n\n  Morris.commas = function(num) {\n    var absnum, intnum, ret, strabsnum;\n    if (num != null) {\n      ret = num < 0 ? \"-\" : \"\";\n      absnum = Math.abs(num);\n      intnum = Math.floor(absnum).toFixed(0);\n      ret += intnum.replace(/(?=(?:\\d{3})+$)(?!^)/g, ',');\n      strabsnum = absnum.toString();\n      if (strabsnum.length > intnum.length) {\n        ret += strabsnum.slice(intnum.length);\n      }\n      return ret;\n    } else {\n      return '-';\n    }\n  };\n\n  Morris.pad2 = function(number) {\n    return (number < 10 ? '0' : '') + number;\n  };\n\n  Morris.Grid = (function(_super) {\n    __extends(Grid, _super);\n\n    function Grid(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      var _this = this;\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if ((this.el == null) || this.el.length === 0) {\n        throw new Error(\"Graph container element not found\");\n      }\n      if (this.el.css('position') === 'static') {\n        this.el.css('position', 'relative');\n      }\n      this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);\n      if (typeof this.options.units === 'string') {\n        this.options.postUnits = options.units;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      this.elementWidth = null;\n      this.elementHeight = null;\n      this.dirty = false;\n      this.selectFrom = null;\n      if (this.init) {\n        this.init();\n      }\n      this.setData(this.options.data);\n      this.el.bind('mousemove', function(evt) {\n        var left, offset, right, width, x;\n        offset = _this.el.offset();\n        x = evt.pageX - offset.left;\n        if (_this.selectFrom) {\n          left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;\n          right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;\n          width = right - left;\n          return _this.selectionRect.attr({\n            x: left,\n            width: width\n          });\n        } else {\n          return _this.fire('hovermove', x, evt.pageY - offset.top);\n        }\n      });\n      this.el.bind('mouseleave', function(evt) {\n        if (_this.selectFrom) {\n          _this.selectionRect.hide();\n          _this.selectFrom = null;\n        }\n        return _this.fire('hoverout');\n      });\n      this.el.bind('touchstart touchmove touchend', function(evt) {\n        var offset, touch;\n        touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];\n        offset = _this.el.offset();\n        return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);\n      });\n      this.el.bind('click', function(evt) {\n        var offset;\n        offset = _this.el.offset();\n        return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);\n      });\n      if (this.options.rangeSelect) {\n        this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({\n          fill: this.options.rangeSelectColor,\n          stroke: false\n        }).toBack().hide();\n        this.el.bind('mousedown', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          return _this.startRange(evt.pageX - offset.left);\n        });\n        this.el.bind('mouseup', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          _this.endRange(evt.pageX - offset.left);\n          return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);\n        });\n      }\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');\n      if (this.postInit) {\n        this.postInit();\n      }\n    }\n\n    Grid.prototype.gridDefaults = {\n      dateFormat: null,\n      axes: true,\n      grid: true,\n      gridLineColor: '#aaa',\n      gridStrokeWidth: 0.5,\n      gridTextColor: '#888',\n      gridTextSize: 12,\n      gridTextFamily: 'sans-serif',\n      gridTextWeight: 'normal',\n      hideHover: false,\n      yLabelFormat: null,\n      xLabelAngle: 0,\n      numLines: 5,\n      padding: 25,\n      parseTime: true,\n      postUnits: '',\n      preUnits: '',\n      ymax: 'auto',\n      ymin: 'auto 0',\n      goals: [],\n      goalStrokeWidth: 1.0,\n      goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],\n      events: [],\n      eventStrokeWidth: 1.0,\n      eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],\n      rangeSelect: null,\n      rangeSelectColor: '#eef',\n      resize: false\n    };\n\n    Grid.prototype.setData = function(data, redraw) {\n      var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;\n      if (redraw == null) {\n        redraw = true;\n      }\n      this.options.data = data;\n      if ((data == null) || data.length === 0) {\n        this.data = [];\n        this.raphael.clear();\n        if (this.hover != null) {\n          this.hover.hide();\n        }\n        return;\n      }\n      ymax = this.cumulative ? 0 : null;\n      ymin = this.cumulative ? 0 : null;\n      if (this.options.goals.length > 0) {\n        minGoal = Math.min.apply(Math, this.options.goals);\n        maxGoal = Math.max.apply(Math, this.options.goals);\n        ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;\n        ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;\n      }\n      this.data = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {\n          row = data[index];\n          ret = {\n            src: row\n          };\n          ret.label = row[this.options.xkey];\n          if (this.options.parseTime) {\n            ret.x = Morris.parseDate(ret.label);\n            if (this.options.dateFormat) {\n              ret.label = this.options.dateFormat(ret.x);\n            } else if (typeof ret.label === 'number') {\n              ret.label = new Date(ret.label).toString();\n            }\n          } else {\n            ret.x = index;\n            if (this.options.xLabelFormat) {\n              ret.label = this.options.xLabelFormat(ret);\n            }\n          }\n          total = 0;\n          ret.y = (function() {\n            var _j, _len1, _ref, _results1;\n            _ref = this.options.ykeys;\n            _results1 = [];\n            for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {\n              ykey = _ref[idx];\n              yval = row[ykey];\n              if (typeof yval === 'string') {\n                yval = parseFloat(yval);\n              }\n              if ((yval != null) && typeof yval !== 'number') {\n                yval = null;\n              }\n              if (yval != null) {\n                if (this.cumulative) {\n                  total += yval;\n                } else {\n                  if (ymax != null) {\n                    ymax = Math.max(yval, ymax);\n                    ymin = Math.min(yval, ymin);\n                  } else {\n                    ymax = ymin = yval;\n                  }\n                }\n              }\n              if (this.cumulative && (total != null)) {\n                ymax = Math.max(total, ymax);\n                ymin = Math.min(total, ymin);\n              }\n              _results1.push(yval);\n            }\n            return _results1;\n          }).call(this);\n          _results.push(ret);\n        }\n        return _results;\n      }).call(this);\n      if (this.options.parseTime) {\n        this.data = this.data.sort(function(a, b) {\n          return (a.x > b.x) - (b.x > a.x);\n        });\n      }\n      this.xmin = this.data[0].x;\n      this.xmax = this.data[this.data.length - 1].x;\n      this.events = [];\n      if (this.options.events.length > 0) {\n        if (this.options.parseTime) {\n          this.events = (function() {\n            var _i, _len, _ref, _results;\n            _ref = this.options.events;\n            _results = [];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              e = _ref[_i];\n              _results.push(Morris.parseDate(e));\n            }\n            return _results;\n          }).call(this);\n        } else {\n          this.events = this.options.events;\n        }\n        this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));\n        this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));\n      }\n      if (this.xmin === this.xmax) {\n        this.xmin -= 1;\n        this.xmax += 1;\n      }\n      this.ymin = this.yboundary('min', ymin);\n      this.ymax = this.yboundary('max', ymax);\n      if (this.ymin === this.ymax) {\n        if (ymin) {\n          this.ymin -= 1;\n        }\n        this.ymax += 1;\n      }\n      if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {\n        if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {\n          this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);\n          this.ymin = Math.min(this.ymin, this.grid[0]);\n          this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);\n        } else {\n          step = (this.ymax - this.ymin) / (this.options.numLines - 1);\n          this.grid = (function() {\n            var _i, _ref1, _ref2, _results;\n            _results = [];\n            for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {\n              _results.push(y);\n            }\n            return _results;\n          }).call(this);\n        }\n      }\n      this.dirty = true;\n      if (redraw) {\n        return this.redraw();\n      }\n    };\n\n    Grid.prototype.yboundary = function(boundaryType, currentValue) {\n      var boundaryOption, suggestedValue;\n      boundaryOption = this.options[\"y\" + boundaryType];\n      if (typeof boundaryOption === 'string') {\n        if (boundaryOption.slice(0, 4) === 'auto') {\n          if (boundaryOption.length > 5) {\n            suggestedValue = parseInt(boundaryOption.slice(5), 10);\n            if (currentValue == null) {\n              return suggestedValue;\n            }\n            return Math[boundaryType](currentValue, suggestedValue);\n          } else {\n            if (currentValue != null) {\n              return currentValue;\n            } else {\n              return 0;\n            }\n          }\n        } else {\n          return parseInt(boundaryOption, 10);\n        }\n      } else {\n        return boundaryOption;\n      }\n    };\n\n    Grid.prototype.autoGridLines = function(ymin, ymax, nlines) {\n      var gmax, gmin, grid, smag, span, step, unit, y, ymag;\n      span = ymax - ymin;\n      ymag = Math.floor(Math.log(span) / Math.log(10));\n      unit = Math.pow(10, ymag);\n      gmin = Math.floor(ymin / unit) * unit;\n      gmax = Math.ceil(ymax / unit) * unit;\n      step = (gmax - gmin) / (nlines - 1);\n      if (unit === 1 && step > 1 && Math.ceil(step) !== step) {\n        step = Math.ceil(step);\n        gmax = gmin + step * (nlines - 1);\n      }\n      if (gmin < 0 && gmax > 0) {\n        gmin = Math.floor(ymin / step) * step;\n        gmax = Math.ceil(ymax / step) * step;\n      }\n      if (step < 1) {\n        smag = Math.floor(Math.log(step) / Math.log(10));\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(parseFloat(y.toFixed(1 - smag)));\n          }\n          return _results;\n        })();\n      } else {\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(y);\n          }\n          return _results;\n        })();\n      }\n      return grid;\n    };\n\n    Grid.prototype._calc = function() {\n      var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;\n      w = this.el.width();\n      h = this.el.height();\n      if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {\n        this.elementWidth = w;\n        this.elementHeight = h;\n        this.dirty = false;\n        this.left = this.options.padding;\n        this.right = this.elementWidth - this.options.padding;\n        this.top = this.options.padding;\n        this.bottom = this.elementHeight - this.options.padding;\n        if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {\n          yLabelWidths = (function() {\n            var _i, _len, _ref1, _results;\n            _ref1 = this.grid;\n            _results = [];\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n              gridLine = _ref1[_i];\n              _results.push(this.measureText(this.yAxisFormat(gridLine)).width);\n            }\n            return _results;\n          }).call(this);\n          this.left += Math.max.apply(Math, yLabelWidths);\n        }\n        if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {\n          bottomOffsets = (function() {\n            var _i, _ref2, _results;\n            _results = [];\n            for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {\n              _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);\n            }\n            return _results;\n          }).call(this);\n          this.bottom -= Math.max.apply(Math, bottomOffsets);\n        }\n        this.width = Math.max(1, this.right - this.left);\n        this.height = Math.max(1, this.bottom - this.top);\n        this.dx = this.width / (this.xmax - this.xmin);\n        this.dy = this.height / (this.ymax - this.ymin);\n        if (this.calc) {\n          return this.calc();\n        }\n      }\n    };\n\n    Grid.prototype.transY = function(y) {\n      return this.bottom - (y - this.ymin) * this.dy;\n    };\n\n    Grid.prototype.transX = function(x) {\n      if (this.data.length === 1) {\n        return (this.left + this.right) / 2;\n      } else {\n        return this.left + (x - this.xmin) * this.dx;\n      }\n    };\n\n    Grid.prototype.redraw = function() {\n      this.raphael.clear();\n      this._calc();\n      this.drawGrid();\n      this.drawGoals();\n      this.drawEvents();\n      if (this.draw) {\n        return this.draw();\n      }\n    };\n\n    Grid.prototype.measureText = function(text, angle) {\n      var ret, tt;\n      if (angle == null) {\n        angle = 0;\n      }\n      tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);\n      ret = tt.getBBox();\n      tt.remove();\n      return ret;\n    };\n\n    Grid.prototype.yAxisFormat = function(label) {\n      return this.yLabelFormat(label);\n    };\n\n    Grid.prototype.yLabelFormat = function(label) {\n      if (typeof this.options.yLabelFormat === 'function') {\n        return this.options.yLabelFormat(label);\n      } else {\n        return \"\" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;\n      }\n    };\n\n    Grid.prototype.drawGrid = function() {\n      var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;\n      if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {\n        return;\n      }\n      _ref1 = this.grid;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        lineY = _ref1[_i];\n        y = this.transY(lineY);\n        if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {\n          this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));\n        }\n        if (this.options.grid) {\n          _results.push(this.drawGridLine(\"M\" + this.left + \",\" + y + \"H\" + (this.left + this.width)));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoals = function() {\n      var color, goal, i, _i, _len, _ref, _results;\n      _ref = this.options.goals;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        goal = _ref[i];\n        color = this.options.goalLineColors[i % this.options.goalLineColors.length];\n        _results.push(this.drawGoal(goal, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawEvents = function() {\n      var color, event, i, _i, _len, _ref, _results;\n      _ref = this.events;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        event = _ref[i];\n        color = this.options.eventLineColors[i % this.options.eventLineColors.length];\n        _results.push(this.drawEvent(event, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoal = function(goal, color) {\n      return this.raphael.path(\"M\" + this.left + \",\" + (this.transY(goal)) + \"H\" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);\n    };\n\n    Grid.prototype.drawEvent = function(event, color) {\n      return this.raphael.path(\"M\" + (this.transX(event)) + \",\" + this.bottom + \"V\" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);\n    };\n\n    Grid.prototype.drawYAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');\n    };\n\n    Grid.prototype.drawGridLine = function(path) {\n      return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);\n    };\n\n    Grid.prototype.startRange = function(x) {\n      this.hover.hide();\n      this.selectFrom = x;\n      return this.selectionRect.attr({\n        x: x,\n        width: 0\n      }).show();\n    };\n\n    Grid.prototype.endRange = function(x) {\n      var end, start;\n      if (this.selectFrom) {\n        start = Math.min(this.selectFrom, x);\n        end = Math.max(this.selectFrom, x);\n        this.options.rangeSelect.call(this.el, {\n          start: this.data[this.hitTest(start)].x,\n          end: this.data[this.hitTest(end)].x\n        });\n        return this.selectFrom = null;\n      }\n    };\n\n    Grid.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Grid;\n\n  })(Morris.EventEmitter);\n\n  Morris.parseDate = function(date) {\n    var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;\n    if (typeof date === 'number') {\n      return date;\n    }\n    m = date.match(/^(\\d+) Q(\\d)$/);\n    n = date.match(/^(\\d+)-(\\d+)$/);\n    o = date.match(/^(\\d+)-(\\d+)-(\\d+)$/);\n    p = date.match(/^(\\d+) W(\\d+)$/);\n    q = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    r = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+):(\\d+(\\.\\d+)?)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    if (m) {\n      return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();\n    } else if (n) {\n      return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();\n    } else if (o) {\n      return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();\n    } else if (p) {\n      ret = new Date(parseInt(p[1], 10), 0, 1);\n      if (ret.getDay() !== 4) {\n        ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);\n      }\n      return ret.getTime() + parseInt(p[2], 10) * 604800000;\n    } else if (q) {\n      if (!q[6]) {\n        return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();\n      } else {\n        offsetmins = 0;\n        if (q[6] !== 'Z') {\n          offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);\n          if (q[7] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);\n      }\n    } else if (r) {\n      secs = parseFloat(r[6]);\n      isecs = Math.floor(secs);\n      msecs = Math.round((secs - isecs) * 1000);\n      if (!r[8]) {\n        return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();\n      } else {\n        offsetmins = 0;\n        if (r[8] !== 'Z') {\n          offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);\n          if (r[9] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);\n      }\n    } else {\n      return new Date(parseInt(date, 10), 0, 1).getTime();\n    }\n  };\n\n  Morris.Hover = (function() {\n    Hover.defaults = {\n      \"class\": 'morris-hover morris-default-style'\n    };\n\n    function Hover(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.options = $.extend({}, Morris.Hover.defaults, options);\n      this.el = $(\"<div class='\" + this.options[\"class\"] + \"'></div>\");\n      this.el.hide();\n      this.options.parent.append(this.el);\n    }\n\n    Hover.prototype.update = function(html, x, y) {\n      if (!html) {\n        return this.hide();\n      } else {\n        this.html(html);\n        this.show();\n        return this.moveTo(x, y);\n      }\n    };\n\n    Hover.prototype.html = function(content) {\n      return this.el.html(content);\n    };\n\n    Hover.prototype.moveTo = function(x, y) {\n      var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;\n      parentWidth = this.options.parent.innerWidth();\n      parentHeight = this.options.parent.innerHeight();\n      hoverWidth = this.el.outerWidth();\n      hoverHeight = this.el.outerHeight();\n      left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);\n      if (y != null) {\n        top = y - hoverHeight - 10;\n        if (top < 0) {\n          top = y + 10;\n          if (top + hoverHeight > parentHeight) {\n            top = parentHeight / 2 - hoverHeight / 2;\n          }\n        }\n      } else {\n        top = parentHeight / 2 - hoverHeight / 2;\n      }\n      return this.el.css({\n        left: left + \"px\",\n        top: parseInt(top) + \"px\"\n      });\n    };\n\n    Hover.prototype.show = function() {\n      return this.el.show();\n    };\n\n    Hover.prototype.hide = function() {\n      return this.el.hide();\n    };\n\n    return Hover;\n\n  })();\n\n  Morris.Line = (function(_super) {\n    __extends(Line, _super);\n\n    function Line(options) {\n      this.hilight = __bind(this.hilight, this);\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Line)) {\n        return new Morris.Line(options);\n      }\n      Line.__super__.constructor.call(this, options);\n    }\n\n    Line.prototype.init = function() {\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Line.prototype.defaults = {\n      lineWidth: 3,\n      pointSize: 4,\n      lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      pointStrokeWidths: [1],\n      pointStrokeColors: ['#ffffff'],\n      pointFillColors: [],\n      smooth: true,\n      xLabels: 'auto',\n      xLabelFormat: null,\n      xLabelMargin: 24,\n      hideHover: false\n    };\n\n    Line.prototype.calc = function() {\n      this.calcPoints();\n      return this.generatePaths();\n    };\n\n    Line.prototype.calcPoints = function() {\n      var row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row._y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        })())));\n      }\n      return _results;\n    };\n\n    Line.prototype.hitTest = function(x) {\n      var index, r, _i, _len, _ref;\n      if (this.data.length === 0) {\n        return null;\n      }\n      _ref = this.data.slice(1);\n      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n        r = _ref[index];\n        if (x < (r._x + this.data[index]._x) / 2) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    Line.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Line.prototype.onHoverMove = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.displayHoverForRow(index);\n    };\n\n    Line.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.displayHoverForRow(null);\n      }\n    };\n\n    Line.prototype.displayHoverForRow = function(index) {\n      var _ref;\n      if (index != null) {\n        (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n        return this.hilight(index);\n      } else {\n        this.hover.hide();\n        return this.hilight();\n      }\n    };\n\n    Line.prototype.hoverContentForRow = function(index) {\n      var content, j, row, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      return [content, row._x, row._ymax];\n    };\n\n    Line.prototype.generatePaths = function() {\n      var coords, i, r, smooth;\n      return this.paths = (function() {\n        var _i, _ref, _ref1, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          smooth = typeof this.options.smooth === \"boolean\" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);\n          coords = (function() {\n            var _j, _len, _ref2, _results1;\n            _ref2 = this.data;\n            _results1 = [];\n            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n              r = _ref2[_j];\n              if (r._y[i] !== void 0) {\n                _results1.push({\n                  x: r._x,\n                  y: r._y[i]\n                });\n              }\n            }\n            return _results1;\n          }).call(this);\n          if (coords.length > 1) {\n            _results.push(Morris.Line.createPath(coords, smooth, this.bottom));\n          } else {\n            _results.push(null);\n          }\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Line.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      this.drawSeries();\n      if (this.options.hideHover === false) {\n        return this.displayHoverForRow(this.data.length - 1);\n      }\n    };\n\n    Line.prototype.drawXAxis = function() {\n      var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,\n        _this = this;\n      ypos = this.bottom + this.options.padding / 2;\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      drawLabel = function(labelText, xpos) {\n        var label, labelBox, margin, offset, textBox;\n        label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-_this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (_this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        labelBox = label.getBBox();\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {\n          if (_this.options.xLabelAngle !== 0) {\n            margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;\n        } else {\n          return label.remove();\n        }\n      };\n      if (this.options.parseTime) {\n        if (this.data.length === 1 && this.options.xLabels === 'auto') {\n          labels = [[this.data[0].label, this.data[0].x]];\n        } else {\n          labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);\n        }\n      } else {\n        labels = (function() {\n          var _i, _len, _ref, _results;\n          _ref = this.data;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            row = _ref[_i];\n            _results.push([row.label, row.x]);\n          }\n          return _results;\n        }).call(this);\n      }\n      labels.reverse();\n      _results = [];\n      for (_i = 0, _len = labels.length; _i < _len; _i++) {\n        l = labels[_i];\n        _results.push(drawLabel(l[0], l[1]));\n      }\n      return _results;\n    };\n\n    Line.prototype.drawSeries = function() {\n      var i, _i, _j, _ref, _ref1, _results;\n      this.seriesPoints = [];\n      for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {\n        this._drawLineFor(i);\n      }\n      _results = [];\n      for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {\n        _results.push(this._drawPointFor(i));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawPointFor = function(index) {\n      var circle, row, _i, _len, _ref, _results;\n      this.seriesPoints[index] = [];\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        circle = null;\n        if (row._y[index] != null) {\n          circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);\n        }\n        _results.push(this.seriesPoints[index].push(circle));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawLineFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);\n      }\n    };\n\n    Line.createPath = function(coords, smooth, bottom) {\n      var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;\n      path = \"\";\n      if (smooth) {\n        grads = Morris.Line.gradients(coords);\n      }\n      prevCoord = {\n        y: null\n      };\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          if (prevCoord.y != null) {\n            if (smooth) {\n              g = grads[i];\n              lg = grads[i - 1];\n              ix = (coord.x - prevCoord.x) / 4;\n              x1 = prevCoord.x + ix;\n              y1 = Math.min(bottom, prevCoord.y + ix * lg);\n              x2 = coord.x - ix;\n              y2 = Math.min(bottom, coord.y - ix * g);\n              path += \"C\" + x1 + \",\" + y1 + \",\" + x2 + \",\" + y2 + \",\" + coord.x + \",\" + coord.y;\n            } else {\n              path += \"L\" + coord.x + \",\" + coord.y;\n            }\n          } else {\n            if (!smooth || (grads[i] != null)) {\n              path += \"M\" + coord.x + \",\" + coord.y;\n            }\n          }\n        }\n        prevCoord = coord;\n      }\n      return path;\n    };\n\n    Line.gradients = function(coords) {\n      var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;\n      grad = function(a, b) {\n        return (a.y - b.y) / (a.x - b.x);\n      };\n      _results = [];\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          nextCoord = coords[i + 1] || {\n            y: null\n          };\n          prevCoord = coords[i - 1] || {\n            y: null\n          };\n          if ((prevCoord.y != null) && (nextCoord.y != null)) {\n            _results.push(grad(prevCoord, nextCoord));\n          } else if (prevCoord.y != null) {\n            _results.push(grad(prevCoord, coord));\n          } else if (nextCoord.y != null) {\n            _results.push(grad(coord, nextCoord));\n          } else {\n            _results.push(null);\n          }\n        } else {\n          _results.push(null);\n        }\n      }\n      return _results;\n    };\n\n    Line.prototype.hilight = function(index) {\n      var i, _i, _j, _ref, _ref1;\n      if (this.prevHilight !== null && this.prevHilight !== index) {\n        for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n          if (this.seriesPoints[i][this.prevHilight]) {\n            this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));\n          }\n        }\n      }\n      if (index !== null && this.prevHilight !== index) {\n        for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          if (this.seriesPoints[i][index]) {\n            this.seriesPoints[i][index].animate(this.pointGrowSeries(i));\n          }\n        }\n      }\n      return this.prevHilight = index;\n    };\n\n    Line.prototype.colorFor = function(row, sidx, type) {\n      if (typeof this.options.lineColors === 'function') {\n        return this.options.lineColors.call(this, row, sidx, type);\n      } else if (type === 'point') {\n        return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];\n      } else {\n        return this.options.lineColors[sidx % this.options.lineColors.length];\n      }\n    };\n\n    Line.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Line.prototype.drawLinePath = function(path, lineColor, lineIndex) {\n      return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));\n    };\n\n    Line.prototype.drawLinePoint = function(xPos, yPos, pointColor, lineIndex) {\n      return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));\n    };\n\n    Line.prototype.pointStrokeWidthForSeries = function(index) {\n      return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];\n    };\n\n    Line.prototype.pointStrokeColorForSeries = function(index) {\n      return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];\n    };\n\n    Line.prototype.lineWidthForSeries = function(index) {\n      if (this.options.lineWidth instanceof Array) {\n        return this.options.lineWidth[index % this.options.lineWidth.length];\n      } else {\n        return this.options.lineWidth;\n      }\n    };\n\n    Line.prototype.pointSizeForSeries = function(index) {\n      if (this.options.pointSize instanceof Array) {\n        return this.options.pointSize[index % this.options.pointSize.length];\n      } else {\n        return this.options.pointSize;\n      }\n    };\n\n    Line.prototype.pointGrowSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index) + 3\n      }, 25, 'linear');\n    };\n\n    Line.prototype.pointShrinkSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index)\n      }, 25, 'linear');\n    };\n\n    return Line;\n\n  })(Morris.Grid);\n\n  Morris.labelSeries = function(dmin, dmax, pxwidth, specName, xLabelFormat) {\n    var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;\n    ddensity = 200 * (dmax - dmin) / pxwidth;\n    d0 = new Date(dmin);\n    spec = Morris.LABEL_SPECS[specName];\n    if (spec === void 0) {\n      _ref = Morris.AUTO_LABEL_ORDER;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        s = Morris.LABEL_SPECS[name];\n        if (ddensity >= s.span) {\n          spec = s;\n          break;\n        }\n      }\n    }\n    if (spec === void 0) {\n      spec = Morris.LABEL_SPECS[\"second\"];\n    }\n    if (xLabelFormat) {\n      spec = $.extend({}, spec, {\n        fmt: xLabelFormat\n      });\n    }\n    d = spec.start(d0);\n    ret = [];\n    while ((t = d.getTime()) <= dmax) {\n      if (t >= dmin) {\n        ret.push([spec.fmt(d), t]);\n      }\n      spec.incr(d);\n    }\n    return ret;\n  };\n\n  minutesSpecHelper = function(interval) {\n    return {\n      span: interval * 60 * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes()));\n      },\n      incr: function(d) {\n        return d.setUTCMinutes(d.getUTCMinutes() + interval);\n      }\n    };\n  };\n\n  secondsSpecHelper = function(interval) {\n    return {\n      span: interval * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes())) + \":\" + (Morris.pad2(d.getSeconds()));\n      },\n      incr: function(d) {\n        return d.setUTCSeconds(d.getUTCSeconds() + interval);\n      }\n    };\n  };\n\n  Morris.LABEL_SPECS = {\n    \"decade\": {\n      span: 172800000000,\n      start: function(d) {\n        return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 10);\n      }\n    },\n    \"year\": {\n      span: 17280000000,\n      start: function(d) {\n        return new Date(d.getFullYear(), 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 1);\n      }\n    },\n    \"month\": {\n      span: 2419200000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1));\n      },\n      incr: function(d) {\n        return d.setMonth(d.getMonth() + 1);\n      }\n    },\n    \"week\": {\n      span: 604800000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 7);\n      }\n    },\n    \"day\": {\n      span: 86400000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 1);\n      }\n    },\n    \"hour\": minutesSpecHelper(60),\n    \"30min\": minutesSpecHelper(30),\n    \"15min\": minutesSpecHelper(15),\n    \"10min\": minutesSpecHelper(10),\n    \"5min\": minutesSpecHelper(5),\n    \"minute\": minutesSpecHelper(1),\n    \"30sec\": secondsSpecHelper(30),\n    \"15sec\": secondsSpecHelper(15),\n    \"10sec\": secondsSpecHelper(10),\n    \"5sec\": secondsSpecHelper(5),\n    \"second\": secondsSpecHelper(1)\n  };\n\n  Morris.AUTO_LABEL_ORDER = [\"decade\", \"year\", \"month\", \"week\", \"day\", \"hour\", \"30min\", \"15min\", \"10min\", \"5min\", \"minute\", \"30sec\", \"15sec\", \"10sec\", \"5sec\", \"second\"];\n\n  Morris.Area = (function(_super) {\n    var areaDefaults;\n\n    __extends(Area, _super);\n\n    areaDefaults = {\n      fillOpacity: 'auto',\n      behaveLikeLine: false\n    };\n\n    function Area(options) {\n      var areaOptions;\n      if (!(this instanceof Morris.Area)) {\n        return new Morris.Area(options);\n      }\n      areaOptions = $.extend({}, areaDefaults, options);\n      this.cumulative = !areaOptions.behaveLikeLine;\n      if (areaOptions.fillOpacity === 'auto') {\n        areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;\n      }\n      Area.__super__.constructor.call(this, areaOptions);\n    }\n\n    Area.prototype.calcPoints = function() {\n      var row, total, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        total = 0;\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (this.options.behaveLikeLine) {\n              _results1.push(this.transY(y));\n            } else {\n              total += y || 0;\n              _results1.push(this.transY(total));\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.max.apply(Math, row._y));\n      }\n      return _results;\n    };\n\n    Area.prototype.drawSeries = function() {\n      var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;\n      this.seriesPoints = [];\n      if (this.options.behaveLikeLine) {\n        range = (function() {\n          _results = [];\n          for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this);\n      } else {\n        range = (function() {\n          _results1 = [];\n          for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results1.push(_j); }\n          return _results1;\n        }).apply(this);\n      }\n      _results2 = [];\n      for (_k = 0, _len = range.length; _k < _len; _k++) {\n        i = range[_k];\n        this._drawFillFor(i);\n        this._drawLineFor(i);\n        _results2.push(this._drawPointFor(i));\n      }\n      return _results2;\n    };\n\n    Area.prototype._drawFillFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        path = path + (\"L\" + (this.transX(this.xmax)) + \",\" + this.bottom + \"L\" + (this.transX(this.xmin)) + \",\" + this.bottom + \"Z\");\n        return this.drawFilledPath(path, this.fillForSeries(index));\n      }\n    };\n\n    Area.prototype.fillForSeries = function(i) {\n      var color;\n      color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));\n      return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));\n    };\n\n    Area.prototype.drawFilledPath = function(path, fill) {\n      return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');\n    };\n\n    return Area;\n\n  })(Morris.Line);\n\n  Morris.Bar = (function(_super) {\n    __extends(Bar, _super);\n\n    function Bar(options) {\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Bar)) {\n        return new Morris.Bar(options);\n      }\n      Bar.__super__.constructor.call(this, $.extend({}, options, {\n        parseTime: false\n      }));\n    }\n\n    Bar.prototype.init = function() {\n      this.cumulative = this.options.stacked;\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Bar.prototype.defaults = {\n      barSizeRatio: 0.75,\n      barGap: 3,\n      barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      barOpacity: 1.0,\n      barRadius: [0, 0, 0, 0],\n      xLabelMargin: 50\n    };\n\n    Bar.prototype.calc = function() {\n      var _ref;\n      this.calcBars();\n      if (this.options.hideHover === false) {\n        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));\n      }\n    };\n\n    Bar.prototype.calcBars = function() {\n      var idx, row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n        row = _ref[idx];\n        row._x = this.left + this.width * (idx + 0.5) / this.data.length;\n        _results.push(row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(null);\n            }\n          }\n          return _results1;\n        }).call(this));\n      }\n      return _results;\n    };\n\n    Bar.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      return this.drawSeries();\n    };\n\n    Bar.prototype.drawXAxis = function() {\n      var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref, _results;\n      ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      _results = [];\n      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        row = this.data[this.data.length - 1 - i];\n        label = this.drawXAxisLabel(row._x, ypos, row.label);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {\n          if (this.options.xLabelAngle !== 0) {\n            margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);\n        } else {\n          _results.push(label.remove());\n        }\n      }\n      return _results;\n    };\n\n    Bar.prototype.drawSeries = function() {\n      var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos;\n      groupWidth = this.width / this.options.data.length;\n      numBars = this.options.stacked ? 1 : this.options.ykeys.length;\n      barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;\n      if (this.options.barSize) {\n        barWidth = Math.min(barWidth, this.options.barSize);\n      }\n      spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);\n      leftPadding = spaceLeft / 2;\n      zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;\n      return this.bars = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n          row = _ref[idx];\n          lastTop = 0;\n          _results.push((function() {\n            var _j, _len1, _ref1, _results1;\n            _ref1 = row._y;\n            _results1 = [];\n            for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {\n              ypos = _ref1[sidx];\n              if (ypos !== null) {\n                if (zeroPos) {\n                  top = Math.min(ypos, zeroPos);\n                  bottom = Math.max(ypos, zeroPos);\n                } else {\n                  top = ypos;\n                  bottom = this.bottom;\n                }\n                left = this.left + idx * groupWidth + leftPadding;\n                if (!this.options.stacked) {\n                  left += sidx * (barWidth + this.options.barGap);\n                }\n                size = bottom - top;\n                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {\n                  this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);\n                }\n                if (this.options.stacked) {\n                  top -= lastTop;\n                }\n                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);\n                _results1.push(lastTop += size);\n              } else {\n                _results1.push(null);\n              }\n            }\n            return _results1;\n          }).call(this));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Bar.prototype.colorFor = function(row, sidx, type) {\n      var r, s;\n      if (typeof this.options.barColors === 'function') {\n        r = {\n          x: row.x,\n          y: row.y[sidx],\n          label: row.label\n        };\n        s = {\n          index: sidx,\n          key: this.options.ykeys[sidx],\n          label: this.options.labels[sidx]\n        };\n        return this.options.barColors.call(this, r, s, type);\n      } else {\n        return this.options.barColors[sidx % this.options.barColors.length];\n      }\n    };\n\n    Bar.prototype.hitTest = function(x) {\n      if (this.data.length === 0) {\n        return null;\n      }\n      x = Math.max(Math.min(x, this.right), this.left);\n      return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));\n    };\n\n    Bar.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Bar.prototype.onHoverMove = function(x, y) {\n      var index, _ref;\n      index = this.hitTest(x);\n      return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n    };\n\n    Bar.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.hover.hide();\n      }\n    };\n\n    Bar.prototype.hoverContentForRow = function(index) {\n      var content, j, row, x, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      x = this.left + (index + 0.5) * this.width / this.data.length;\n      return [content, x];\n    };\n\n    Bar.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      var label;\n      return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Bar.prototype.drawBar = function(xPos, yPos, width, height, barColor, opacity, radiusArray) {\n      var maxRadius, path;\n      maxRadius = Math.max.apply(Math, radiusArray);\n      if (maxRadius === 0 || maxRadius > height) {\n        path = this.raphael.rect(xPos, yPos, width, height);\n      } else {\n        path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));\n      }\n      return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');\n    };\n\n    Bar.prototype.roundedRect = function(x, y, w, h, r) {\n      if (r == null) {\n        r = [0, 0, 0, 0];\n      }\n      return [\"M\", x, r[0] + y, \"Q\", x, y, x + r[0], y, \"L\", x + w - r[1], y, \"Q\", x + w, y, x + w, y + r[1], \"L\", x + w, y + h - r[2], \"Q\", x + w, y + h, x + w - r[2], y + h, \"L\", x + r[3], y + h, \"Q\", x, y + h, x, y + h - r[3], \"Z\"];\n    };\n\n    return Bar;\n\n  })(Morris.Grid);\n\n  Morris.Donut = (function(_super) {\n    __extends(Donut, _super);\n\n    Donut.prototype.defaults = {\n      colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],\n      backgroundColor: '#FFFFFF',\n      labelColor: '#000000',\n      formatter: Morris.commas,\n      resize: false\n    };\n\n    function Donut(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      this.select = __bind(this.select, this);\n      this.click = __bind(this.click, this);\n      var _this = this;\n      if (!(this instanceof Morris.Donut)) {\n        return new Morris.Donut(options);\n      }\n      this.options = $.extend({}, this.defaults, options);\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if (this.el === null || this.el.length === 0) {\n        throw new Error(\"Graph placeholder not found.\");\n      }\n      if (options.data === void 0 || options.data.length === 0) {\n        return;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.setData(options.data);\n    }\n\n    Donut.prototype.redraw = function() {\n      var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;\n      this.raphael.clear();\n      cx = this.el.width() / 2;\n      cy = this.el.height() / 2;\n      w = (Math.min(cx, cy) - 10) / 3;\n      total = 0;\n      _ref = this.values;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        value = _ref[_i];\n        total += value;\n      }\n      min = 5 / (2 * w);\n      C = 1.9999 * Math.PI - min * this.data.length;\n      last = 0;\n      idx = 0;\n      this.segments = [];\n      _ref1 = this.values;\n      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n        value = _ref1[i];\n        next = last + min + C * (value / total);\n        seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);\n        seg.render();\n        this.segments.push(seg);\n        seg.on('hover', this.select);\n        seg.on('click', this.click);\n        last = next;\n        idx += 1;\n      }\n      this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);\n      this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);\n      max_value = Math.max.apply(Math, this.values);\n      idx = 0;\n      _ref2 = this.values;\n      _results = [];\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        value = _ref2[_k];\n        if (value === max_value) {\n          this.select(idx);\n          break;\n        }\n        _results.push(idx += 1);\n      }\n      return _results;\n    };\n\n    Donut.prototype.setData = function(data) {\n      var row;\n      this.data = data;\n      this.values = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          row = _ref[_i];\n          _results.push(parseFloat(row.value));\n        }\n        return _results;\n      }).call(this);\n      return this.redraw();\n    };\n\n    Donut.prototype.click = function(idx) {\n      return this.fire('click', idx, this.data[idx]);\n    };\n\n    Donut.prototype.select = function(idx) {\n      var row, s, segment, _i, _len, _ref;\n      _ref = this.segments;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        s = _ref[_i];\n        s.deselect();\n      }\n      segment = this.segments[idx];\n      segment.select();\n      row = this.data[idx];\n      return this.setLabels(row.label, this.options.formatter(row.value, row));\n    };\n\n    Donut.prototype.setLabels = function(label1, label2) {\n      var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;\n      inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;\n      maxWidth = 1.8 * inner;\n      maxHeightTop = inner / 2;\n      maxHeightBottom = inner / 3;\n      this.text1.attr({\n        text: label1,\n        transform: ''\n      });\n      text1bbox = this.text1.getBBox();\n      text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);\n      this.text1.attr({\n        transform: \"S\" + text1scale + \",\" + text1scale + \",\" + (text1bbox.x + text1bbox.width / 2) + \",\" + (text1bbox.y + text1bbox.height)\n      });\n      this.text2.attr({\n        text: label2,\n        transform: ''\n      });\n      text2bbox = this.text2.getBBox();\n      text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);\n      return this.text2.attr({\n        transform: \"S\" + text2scale + \",\" + text2scale + \",\" + (text2bbox.x + text2bbox.width / 2) + \",\" + text2bbox.y\n      });\n    };\n\n    Donut.prototype.drawEmptyDonutLabel = function(xPos, yPos, color, fontSize, fontWeight) {\n      var text;\n      text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);\n      if (fontWeight != null) {\n        text.attr('font-weight', fontWeight);\n      }\n      return text;\n    };\n\n    Donut.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Donut;\n\n  })(Morris.EventEmitter);\n\n  Morris.DonutSegment = (function(_super) {\n    __extends(DonutSegment, _super);\n\n    function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {\n      this.cx = cx;\n      this.cy = cy;\n      this.inner = inner;\n      this.outer = outer;\n      this.color = color;\n      this.backgroundColor = backgroundColor;\n      this.index = index;\n      this.raphael = raphael;\n      this.deselect = __bind(this.deselect, this);\n      this.select = __bind(this.select, this);\n      this.sin_p0 = Math.sin(p0);\n      this.cos_p0 = Math.cos(p0);\n      this.sin_p1 = Math.sin(p1);\n      this.cos_p1 = Math.cos(p1);\n      this.is_long = (p1 - p0) > Math.PI ? 1 : 0;\n      this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);\n      this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);\n      this.hilight = this.calcArc(this.inner);\n    }\n\n    DonutSegment.prototype.calcArcPoints = function(r) {\n      return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];\n    };\n\n    DonutSegment.prototype.calcSegment = function(r1, r2) {\n      var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;\n      _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r1 + \",\" + r1 + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1) + (\"L\" + ox1 + \",\" + oy1) + (\"A\" + r2 + \",\" + r2 + \",0,\" + this.is_long + \",1,\" + ox0 + \",\" + oy0) + \"Z\";\n    };\n\n    DonutSegment.prototype.calcArc = function(r) {\n      var ix0, ix1, iy0, iy1, _ref;\n      _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r + \",\" + r + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1);\n    };\n\n    DonutSegment.prototype.render = function() {\n      var _this = this;\n      this.arc = this.drawDonutArc(this.hilight, this.color);\n      return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {\n        return _this.fire('hover', _this.index);\n      }, function() {\n        return _this.fire('click', _this.index);\n      });\n    };\n\n    DonutSegment.prototype.drawDonutArc = function(path, color) {\n      return this.raphael.path(path).attr({\n        stroke: color,\n        'stroke-width': 2,\n        opacity: 0\n      });\n    };\n\n    DonutSegment.prototype.drawDonutSegment = function(path, fillColor, strokeColor, hoverFunction, clickFunction) {\n      return this.raphael.path(path).attr({\n        fill: fillColor,\n        stroke: strokeColor,\n        'stroke-width': 3\n      }).hover(hoverFunction).click(clickFunction);\n    };\n\n    DonutSegment.prototype.select = function() {\n      if (!this.selected) {\n        this.seg.animate({\n          path: this.selectedPath\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 1\n        }, 150, '<>');\n        return this.selected = true;\n      }\n    };\n\n    DonutSegment.prototype.deselect = function() {\n      if (this.selected) {\n        this.seg.animate({\n          path: this.path\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 0\n        }, 150, '<>');\n        return this.selected = false;\n      }\n    };\n\n    return DonutSegment;\n\n  })(Morris.EventEmitter);\n\n}).call(this);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n//  \\\\\n//  Raphal 2.2.0 - JavaScript Vector Library                                                              \\\\\n//  \\\\\n//  Copyright  2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                        \\\\\n//  Copyright  2008-2016 Sencha Labs (http://sencha.com)                                                  \\\\\n//  \\\\\n//  Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license. \\\\\n//  \\\\\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Raphael\"] = factory();\n\telse\n\t\troot[\"Raphael\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\n\t    return R;\n\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(eve) {\n\n\t    /*\\\n\t     * Raphael\n\t     [ method ]\n\t     **\n\t     * Creates a canvas object on which to draw.\n\t     * You must do this first, as all future calls to drawing methods\n\t     * from this instance will be bound to this canvas.\n\t     > Parameters\n\t     **\n\t     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n\t     - width (number)\n\t     - height (number)\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - x (number)\n\t     - y (number)\n\t     - width (number)\n\t     - height (number)\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.\n\t     = (object) @Paper\n\t     > Usage\n\t     | // Each of the following examples create a canvas\n\t     | // that is 320px wide by 200px high.\n\t     | // Canvas is created at the viewports 10,50 coordinate.\n\t     | var paper = Raphael(10, 50, 320, 200);\n\t     | // Canvas is created at the top left corner of the #notepad element\n\t     | // (or its top right corner in dir=\"rtl\" elements)\n\t     | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n\t     | // Same as above\n\t     | var paper = Raphael(\"notepad\", 320, 200);\n\t     | // Image dump\n\t     | var set = Raphael([\"notepad\", 320, 200, {\n\t     |     type: \"rect\",\n\t     |     x: 10,\n\t     |     y: 10,\n\t     |     width: 25,\n\t     |     height: 25,\n\t     |     stroke: \"#f00\"\n\t     | }, {\n\t     |     type: \"text\",\n\t     |     x: 30,\n\t     |     y: 40,\n\t     |     text: \"Dump\"\n\t     | }]);\n\t    \\*/\n\t    function R(first) {\n\t        if (R.is(first, \"function\")) {\n\t            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n\t        } else if (R.is(first, array)) {\n\t            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n\t        } else {\n\t            var args = Array.prototype.slice.call(arguments, 0);\n\t            if (R.is(args[args.length - 1], \"function\")) {\n\t                var f = args.pop();\n\t                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n\t                    f.call(R._engine.create[apply](R, args));\n\t                });\n\t            } else {\n\t                return R._engine.create[apply](R, arguments);\n\t            }\n\t        }\n\t    }\n\t    R.version = \"2.2.0\";\n\t    R.eve = eve;\n\t    var loaded,\n\t        separator = /[, ]+/,\n\t        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},\n\t        formatrg = /\\{(\\d+)\\}/g,\n\t        proto = \"prototype\",\n\t        has = \"hasOwnProperty\",\n\t        g = {\n\t            doc: document,\n\t            win: window\n\t        },\n\t        oldRaphael = {\n\t            was: Object.prototype[has].call(g.win, \"Raphael\"),\n\t            is: g.win.Raphael\n\t        },\n\t        Paper = function () {\n\t            /*\\\n\t             * Paper.ca\n\t             [ property (object) ]\n\t             **\n\t             * Shortcut for @Paper.customAttributes\n\t            \\*/\n\t            /*\\\n\t             * Paper.customAttributes\n\t             [ property (object) ]\n\t             **\n\t             * If you have a set of attributes that you would like to represent\n\t             * as a function of some number you can do it easily with custom attributes:\n\t             > Usage\n\t             | paper.customAttributes.hue = function (num) {\n\t             |     num = num % 1;\n\t             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\n\t             | };\n\t             | // Custom attribute hue will change fill\n\t             | // to be given hue with fixed saturation and brightness.\n\t             | // Now you can use it like this:\n\t             | var c = paper.circle(10, 10, 10).attr({hue: .45});\n\t             | // or even like this:\n\t             | c.animate({hue: 1}, 1e3);\n\t             |\n\t             | // You could also create custom attribute\n\t             | // with multiple parameters:\n\t             | paper.customAttributes.hsb = function (h, s, b) {\n\t             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\n\t             | };\n\t             | c.attr({hsb: \"0.5 .8 1\"});\n\t             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\n\t            \\*/\n\t            this.ca = this.customAttributes = {};\n\t        },\n\t        paperproto,\n\t        appendChild = \"appendChild\",\n\t        apply = \"apply\",\n\t        concat = \"concat\",\n\t        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test\n\t        E = \"\",\n\t        S = \" \",\n\t        Str = String,\n\t        split = \"split\",\n\t        events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\n\t        touchMap = {\n\t            mousedown: \"touchstart\",\n\t            mousemove: \"touchmove\",\n\t            mouseup: \"touchend\"\n\t        },\n\t        lowerCase = Str.prototype.toLowerCase,\n\t        math = Math,\n\t        mmax = math.max,\n\t        mmin = math.min,\n\t        abs = math.abs,\n\t        pow = math.pow,\n\t        PI = math.PI,\n\t        nu = \"number\",\n\t        string = \"string\",\n\t        array = \"array\",\n\t        toString = \"toString\",\n\t        fillString = \"fill\",\n\t        objectToString = Object.prototype.toString,\n\t        paper = {},\n\t        push = \"push\",\n\t        ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\n\t        colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n\t        isnan = {\"NaN\": 1, \"Infinity\": 1, \"-Infinity\": 1},\n\t        bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n\t        round = math.round,\n\t        setAttribute = \"setAttribute\",\n\t        toFloat = parseFloat,\n\t        toInt = parseInt,\n\t        upperCase = Str.prototype.toUpperCase,\n\t        availableAttrs = R._availableAttrs = {\n\t            \"arrow-end\": \"none\",\n\t            \"arrow-start\": \"none\",\n\t            blur: 0,\n\t            \"clip-rect\": \"0 0 1e9 1e9\",\n\t            cursor: \"default\",\n\t            cx: 0,\n\t            cy: 0,\n\t            fill: \"#fff\",\n\t            \"fill-opacity\": 1,\n\t            font: '10px \"Arial\"',\n\t            \"font-family\": '\"Arial\"',\n\t            \"font-size\": \"10\",\n\t            \"font-style\": \"normal\",\n\t            \"font-weight\": 400,\n\t            gradient: 0,\n\t            height: 0,\n\t            href: \"http://raphaeljs.com/\",\n\t            \"letter-spacing\": 0,\n\t            opacity: 1,\n\t            path: \"M0,0\",\n\t            r: 0,\n\t            rx: 0,\n\t            ry: 0,\n\t            src: \"\",\n\t            stroke: \"#000\",\n\t            \"stroke-dasharray\": \"\",\n\t            \"stroke-linecap\": \"butt\",\n\t            \"stroke-linejoin\": \"butt\",\n\t            \"stroke-miterlimit\": 0,\n\t            \"stroke-opacity\": 1,\n\t            \"stroke-width\": 1,\n\t            target: \"_blank\",\n\t            \"text-anchor\": \"middle\",\n\t            title: \"Raphael\",\n\t            transform: \"\",\n\t            width: 0,\n\t            x: 0,\n\t            y: 0,\n\t            \"class\": \"\"\n\t        },\n\t        availableAnimAttrs = R._availableAnimAttrs = {\n\t            blur: nu,\n\t            \"clip-rect\": \"csv\",\n\t            cx: nu,\n\t            cy: nu,\n\t            fill: \"colour\",\n\t            \"fill-opacity\": nu,\n\t            \"font-size\": nu,\n\t            height: nu,\n\t            opacity: nu,\n\t            path: \"path\",\n\t            r: nu,\n\t            rx: nu,\n\t            ry: nu,\n\t            stroke: \"colour\",\n\t            \"stroke-opacity\": nu,\n\t            \"stroke-width\": nu,\n\t            transform: \"transform\",\n\t            width: nu,\n\t            x: nu,\n\t            y: nu\n\t        },\n\t        whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\n\t        commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n\t        hsrg = {hs: 1, rg: 1},\n\t        p2s = /,?([achlmqrstvxz]),?/gi,\n\t        pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n\t        tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n\t        pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n\t        radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\n\t        eldata = {},\n\t        sortByKey = function (a, b) {\n\t            return a.key - b.key;\n\t        },\n\t        sortByNumber = function (a, b) {\n\t            return toFloat(a) - toFloat(b);\n\t        },\n\t        fun = function () {},\n\t        pipe = function (x) {\n\t            return x;\n\t        },\n\t        rectPath = R._rectPath = function (x, y, w, h, r) {\n\t            if (r) {\n\t                return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\n\t            }\n\t            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n\t        },\n\t        ellipsePath = function (x, y, rx, ry) {\n\t            if (ry == null) {\n\t                ry = rx;\n\t            }\n\t            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n\t        },\n\t        getPath = R._getPath = {\n\t            path: function (el) {\n\t                return el.attr(\"path\");\n\t            },\n\t            circle: function (el) {\n\t                var a = el.attrs;\n\t                return ellipsePath(a.cx, a.cy, a.r);\n\t            },\n\t            ellipse: function (el) {\n\t                var a = el.attrs;\n\t                return ellipsePath(a.cx, a.cy, a.rx, a.ry);\n\t            },\n\t            rect: function (el) {\n\t                var a = el.attrs;\n\t                return rectPath(a.x, a.y, a.width, a.height, a.r);\n\t            },\n\t            image: function (el) {\n\t                var a = el.attrs;\n\t                return rectPath(a.x, a.y, a.width, a.height);\n\t            },\n\t            text: function (el) {\n\t                var bbox = el._getBBox();\n\t                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t            },\n\t            set : function(el) {\n\t                var bbox = el._getBBox();\n\t                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t            }\n\t        },\n\t        /*\\\n\t         * Raphael.mapPath\n\t         [ method ]\n\t         **\n\t         * Transform the path string with given matrix.\n\t         > Parameters\n\t         - path (string) path string\n\t         - matrix (object) see @Matrix\n\t         = (string) transformed path string\n\t        \\*/\n\t        mapPath = R.mapPath = function (path, matrix) {\n\t            if (!matrix) {\n\t                return path;\n\t            }\n\t            var x, y, i, j, ii, jj, pathi;\n\t            path = path2curve(path);\n\t            for (i = 0, ii = path.length; i < ii; i++) {\n\t                pathi = path[i];\n\t                for (j = 1, jj = pathi.length; j < jj; j += 2) {\n\t                    x = matrix.x(pathi[j], pathi[j + 1]);\n\t                    y = matrix.y(pathi[j], pathi[j + 1]);\n\t                    pathi[j] = x;\n\t                    pathi[j + 1] = y;\n\t                }\n\t            }\n\t            return path;\n\t        };\n\n\t    R._g = g;\n\t    /*\\\n\t     * Raphael.type\n\t     [ property (string) ]\n\t     **\n\t     * Can be SVG, VML or empty, depending on browser support.\n\t    \\*/\n\t    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\");\n\t    if (R.type == \"VML\") {\n\t        var d = g.doc.createElement(\"div\"),\n\t            b;\n\t        d.innerHTML = '<v:shape adj=\"1\"/>';\n\t        b = d.firstChild;\n\t        b.style.behavior = \"url(#default#VML)\";\n\t        if (!(b && typeof b.adj == \"object\")) {\n\t            return (R.type = E);\n\t        }\n\t        d = null;\n\t    }\n\t    /*\\\n\t     * Raphael.svg\n\t     [ property (boolean) ]\n\t     **\n\t     * `true` if browser supports SVG.\n\t    \\*/\n\t    /*\\\n\t     * Raphael.vml\n\t     [ property (boolean) ]\n\t     **\n\t     * `true` if browser supports VML.\n\t    \\*/\n\t    R.svg = !(R.vml = R.type == \"VML\");\n\t    R._Paper = Paper;\n\t    /*\\\n\t     * Raphael.fn\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to the canvas. For example if you want to draw a pie chart,\n\t     * you can create your own pie chart function and ship it as a Raphal plugin. To do this\n\t     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\n\t     * Raphal instance is created, otherwise it will take no effect. Please note that the\n\t     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\n\t     * ensure any namespacing ensures proper context.\n\t     > Usage\n\t     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\n\t     |     return this.path( ... );\n\t     | };\n\t     | // or create namespace\n\t     | Raphael.fn.mystuff = {\n\t     |     arrow: function () {},\n\t     |     star: function () {},\n\t     |     // etc\n\t     | };\n\t     | var paper = Raphael(10, 10, 630, 480);\n\t     | // then use it\n\t     | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\n\t     | paper.mystuff.arrow();\n\t     | paper.mystuff.star();\n\t    \\*/\n\t    R.fn = paperproto = Paper.prototype = R.prototype;\n\t    R._id = 0;\n\t    /*\\\n\t     * Raphael.is\n\t     [ method ]\n\t     **\n\t     * Handful of replacements for `typeof` operator.\n\t     > Parameters\n\t     - o () any object or primitive\n\t     - type (string) name of the type, i.e. string, function, number, etc.\n\t     = (boolean) is given value is of given type\n\t    \\*/\n\t    R.is = function (o, type) {\n\t        type = lowerCase.call(type);\n\t        if (type == \"finite\") {\n\t            return !isnan[has](+o);\n\t        }\n\t        if (type == \"array\") {\n\t            return o instanceof Array;\n\t        }\n\t        return  (type == \"null\" && o === null) ||\n\t                (type == typeof o && o !== null) ||\n\t                (type == \"object\" && o === Object(o)) ||\n\t                (type == \"array\" && Array.isArray && Array.isArray(o)) ||\n\t                objectToString.call(o).slice(8, -1).toLowerCase() == type;\n\t    };\n\n\t    function clone(obj) {\n\t        if (typeof obj == \"function\" || Object(obj) !== obj) {\n\t            return obj;\n\t        }\n\t        var res = new obj.constructor;\n\t        for (var key in obj) if (obj[has](key)) {\n\t            res[key] = clone(obj[key]);\n\t        }\n\t        return res;\n\t    }\n\n\t    /*\\\n\t     * Raphael.angle\n\t     [ method ]\n\t     **\n\t     * Returns angle between two or three points\n\t     > Parameters\n\t     - x1 (number) x coord of first point\n\t     - y1 (number) y coord of first point\n\t     - x2 (number) x coord of second point\n\t     - y2 (number) y coord of second point\n\t     - x3 (number) #optional x coord of third point\n\t     - y3 (number) #optional y coord of third point\n\t     = (number) angle in degrees.\n\t    \\*/\n\t    R.angle = function (x1, y1, x2, y2, x3, y3) {\n\t        if (x3 == null) {\n\t            var x = x1 - x2,\n\t                y = y1 - y2;\n\t            if (!x && !y) {\n\t                return 0;\n\t            }\n\t            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n\t        } else {\n\t            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\n\t        }\n\t    };\n\t    /*\\\n\t     * Raphael.rad\n\t     [ method ]\n\t     **\n\t     * Transform angle to radians\n\t     > Parameters\n\t     - deg (number) angle in degrees\n\t     = (number) angle in radians.\n\t    \\*/\n\t    R.rad = function (deg) {\n\t        return deg % 360 * PI / 180;\n\t    };\n\t    /*\\\n\t     * Raphael.deg\n\t     [ method ]\n\t     **\n\t     * Transform angle to degrees\n\t     > Parameters\n\t     - rad (number) angle in radians\n\t     = (number) angle in degrees.\n\t    \\*/\n\t    R.deg = function (rad) {\n\t        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;\n\t    };\n\t    /*\\\n\t     * Raphael.snapTo\n\t     [ method ]\n\t     **\n\t     * Snaps given value to given grid.\n\t     > Parameters\n\t     - values (array|number) given array of values or step of the grid\n\t     - value (number) value to adjust\n\t     - tolerance (number) #optional tolerance for snapping. Default is `10`.\n\t     = (number) adjusted value.\n\t    \\*/\n\t    R.snapTo = function (values, value, tolerance) {\n\t        tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\n\t        if (R.is(values, array)) {\n\t            var i = values.length;\n\t            while (i--) if (abs(values[i] - value) <= tolerance) {\n\t                return values[i];\n\t            }\n\t        } else {\n\t            values = +values;\n\t            var rem = value % values;\n\t            if (rem < tolerance) {\n\t                return value - rem;\n\t            }\n\t            if (rem > values - tolerance) {\n\t                return value - rem + values;\n\t            }\n\t        }\n\t        return value;\n\t    };\n\n\t    /*\\\n\t     * Raphael.createUUID\n\t     [ method ]\n\t     **\n\t     * Returns RFC4122, version 4 ID\n\t    \\*/\n\t    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {\n\t        return function () {\n\t            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\n\t        };\n\t    })(/[xy]/g, function (c) {\n\t        var r = math.random() * 16 | 0,\n\t            v = c == \"x\" ? r : (r & 3 | 8);\n\t        return v.toString(16);\n\t    });\n\n\t    /*\\\n\t     * Raphael.setWindow\n\t     [ method ]\n\t     **\n\t     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\n\t     > Parameters\n\t     - newwin (window) new window object\n\t    \\*/\n\t    R.setWindow = function (newwin) {\n\t        eve(\"raphael.setWindow\", R, g.win, newwin);\n\t        g.win = newwin;\n\t        g.doc = g.win.document;\n\t        if (R._engine.initWin) {\n\t            R._engine.initWin(g.win);\n\t        }\n\t    };\n\t    var toHex = function (color) {\n\t        if (R.vml) {\n\t            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\n\t            var trim = /^\\s+|\\s+$/g;\n\t            var bod;\n\t            try {\n\t                var docum = new ActiveXObject(\"htmlfile\");\n\t                docum.write(\"<body>\");\n\t                docum.close();\n\t                bod = docum.body;\n\t            } catch(e) {\n\t                bod = createPopup().document.body;\n\t            }\n\t            var range = bod.createTextRange();\n\t            toHex = cacher(function (color) {\n\t                try {\n\t                    bod.style.color = Str(color).replace(trim, E);\n\t                    var value = range.queryCommandValue(\"ForeColor\");\n\t                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n\t                    return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\n\t                } catch(e) {\n\t                    return \"none\";\n\t                }\n\t            });\n\t        } else {\n\t            var i = g.doc.createElement(\"i\");\n\t            i.title = \"Rapha\\xebl Colour Picker\";\n\t            i.style.display = \"none\";\n\t            g.doc.body.appendChild(i);\n\t            toHex = cacher(function (color) {\n\t                i.style.color = color;\n\t                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n\t            });\n\t        }\n\t        return toHex(color);\n\t    },\n\t    hsbtoString = function () {\n\t        return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n\t    },\n\t    hsltoString = function () {\n\t        return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n\t    },\n\t    rgbtoString = function () {\n\t        return this.hex;\n\t    },\n\t    prepareRGB = function (r, g, b) {\n\t        if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n\t            b = r.b;\n\t            g = r.g;\n\t            r = r.r;\n\t        }\n\t        if (g == null && R.is(r, string)) {\n\t            var clr = R.getRGB(r);\n\t            r = clr.r;\n\t            g = clr.g;\n\t            b = clr.b;\n\t        }\n\t        if (r > 1 || g > 1 || b > 1) {\n\t            r /= 255;\n\t            g /= 255;\n\t            b /= 255;\n\t        }\n\n\t        return [r, g, b];\n\t    },\n\t    packageRGB = function (r, g, b, o) {\n\t        r *= 255;\n\t        g *= 255;\n\t        b *= 255;\n\t        var rgb = {\n\t            r: r,\n\t            g: g,\n\t            b: b,\n\t            hex: R.rgb(r, g, b),\n\t            toString: rgbtoString\n\t        };\n\t        R.is(o, \"finite\") && (rgb.opacity = o);\n\t        return rgb;\n\t    };\n\n\t    /*\\\n\t     * Raphael.color\n\t     [ method ]\n\t     **\n\t     * Parses the color string and returns object with all values for the given color.\n\t     > Parameters\n\t     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\n\t     = (object) Combined RGB & HSB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #,\n\t     o     error (boolean) `true` if string cant be parsed,\n\t     o     h (number) hue,\n\t     o     s (number) saturation,\n\t     o     v (number) value (brightness),\n\t     o     l (number) lightness\n\t     o }\n\t    \\*/\n\t    R.color = function (clr) {\n\t        var rgb;\n\t        if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n\t            rgb = R.hsb2rgb(clr);\n\t            clr.r = rgb.r;\n\t            clr.g = rgb.g;\n\t            clr.b = rgb.b;\n\t            clr.hex = rgb.hex;\n\t        } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n\t            rgb = R.hsl2rgb(clr);\n\t            clr.r = rgb.r;\n\t            clr.g = rgb.g;\n\t            clr.b = rgb.b;\n\t            clr.hex = rgb.hex;\n\t        } else {\n\t            if (R.is(clr, \"string\")) {\n\t                clr = R.getRGB(clr);\n\t            }\n\t            if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\n\t                rgb = R.rgb2hsl(clr);\n\t                clr.h = rgb.h;\n\t                clr.s = rgb.s;\n\t                clr.l = rgb.l;\n\t                rgb = R.rgb2hsb(clr);\n\t                clr.v = rgb.b;\n\t            } else {\n\t                clr = {hex: \"none\"};\n\t                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n\t            }\n\t        }\n\t        clr.toString = rgbtoString;\n\t        return clr;\n\t    };\n\t    /*\\\n\t     * Raphael.hsb2rgb\n\t     [ method ]\n\t     **\n\t     * Converts HSB values to RGB object.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - v (number) value or brightness\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #\n\t     o }\n\t    \\*/\n\t    R.hsb2rgb = function (h, s, v, o) {\n\t        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n\t            v = h.b;\n\t            s = h.s;\n\t            o = h.o;\n\t            h = h.h;\n\t        }\n\t        h *= 360;\n\t        var R, G, B, X, C;\n\t        h = (h % 360) / 60;\n\t        C = v * s;\n\t        X = C * (1 - abs(h % 2 - 1));\n\t        R = G = B = v - C;\n\n\t        h = ~~h;\n\t        R += [C, X, 0, 0, X, C][h];\n\t        G += [X, C, C, X, 0, 0][h];\n\t        B += [0, 0, X, C, C, X][h];\n\t        return packageRGB(R, G, B, o);\n\t    };\n\t    /*\\\n\t     * Raphael.hsl2rgb\n\t     [ method ]\n\t     **\n\t     * Converts HSL values to RGB object.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - l (number) luminosity\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #\n\t     o }\n\t    \\*/\n\t    R.hsl2rgb = function (h, s, l, o) {\n\t        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n\t            l = h.l;\n\t            s = h.s;\n\t            h = h.h;\n\t        }\n\t        if (h > 1 || s > 1 || l > 1) {\n\t            h /= 360;\n\t            s /= 100;\n\t            l /= 100;\n\t        }\n\t        h *= 360;\n\t        var R, G, B, X, C;\n\t        h = (h % 360) / 60;\n\t        C = 2 * s * (l < .5 ? l : 1 - l);\n\t        X = C * (1 - abs(h % 2 - 1));\n\t        R = G = B = l - C / 2;\n\n\t        h = ~~h;\n\t        R += [C, X, 0, 0, X, C][h];\n\t        G += [X, C, C, X, 0, 0][h];\n\t        B += [0, 0, X, C, C, X][h];\n\t        return packageRGB(R, G, B, o);\n\t    };\n\t    /*\\\n\t     * Raphael.rgb2hsb\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to HSB object.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (object) HSB object in format:\n\t     o {\n\t     o     h (number) hue\n\t     o     s (number) saturation\n\t     o     b (number) brightness\n\t     o }\n\t    \\*/\n\t    R.rgb2hsb = function (r, g, b) {\n\t        b = prepareRGB(r, g, b);\n\t        r = b[0];\n\t        g = b[1];\n\t        b = b[2];\n\n\t        var H, S, V, C;\n\t        V = mmax(r, g, b);\n\t        C = V - mmin(r, g, b);\n\t        H = (C == 0 ? null :\n\t             V == r ? (g - b) / C :\n\t             V == g ? (b - r) / C + 2 :\n\t                      (r - g) / C + 4\n\t            );\n\t        H = ((H + 360) % 6) * 60 / 360;\n\t        S = C == 0 ? 0 : C / V;\n\t        return {h: H, s: S, b: V, toString: hsbtoString};\n\t    };\n\t    /*\\\n\t     * Raphael.rgb2hsl\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to HSL object.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (object) HSL object in format:\n\t     o {\n\t     o     h (number) hue\n\t     o     s (number) saturation\n\t     o     l (number) luminosity\n\t     o }\n\t    \\*/\n\t    R.rgb2hsl = function (r, g, b) {\n\t        b = prepareRGB(r, g, b);\n\t        r = b[0];\n\t        g = b[1];\n\t        b = b[2];\n\n\t        var H, S, L, M, m, C;\n\t        M = mmax(r, g, b);\n\t        m = mmin(r, g, b);\n\t        C = M - m;\n\t        H = (C == 0 ? null :\n\t             M == r ? (g - b) / C :\n\t             M == g ? (b - r) / C + 2 :\n\t                      (r - g) / C + 4);\n\t        H = ((H + 360) % 6) * 60 / 360;\n\t        L = (M + m) / 2;\n\t        S = (C == 0 ? 0 :\n\t             L < .5 ? C / (2 * L) :\n\t                      C / (2 - 2 * L));\n\t        return {h: H, s: S, l: L, toString: hsltoString};\n\t    };\n\t    R._path2string = function () {\n\t        return this.join(\",\").replace(p2s, \"$1\");\n\t    };\n\t    function repush(array, item) {\n\t        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n\t            return array.push(array.splice(i, 1)[0]);\n\t        }\n\t    }\n\t    function cacher(f, scope, postprocessor) {\n\t        function newf() {\n\t            var arg = Array.prototype.slice.call(arguments, 0),\n\t                args = arg.join(\"\\u2400\"),\n\t                cache = newf.cache = newf.cache || {},\n\t                count = newf.count = newf.count || [];\n\t            if (cache[has](args)) {\n\t                repush(count, args);\n\t                return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t            }\n\t            count.length >= 1e3 && delete cache[count.shift()];\n\t            count.push(args);\n\t            cache[args] = f[apply](scope, arg);\n\t            return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t        }\n\t        return newf;\n\t    }\n\n\t    var preload = R._preload = function (src, f) {\n\t        var img = g.doc.createElement(\"img\");\n\t        img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\t        img.onload = function () {\n\t            f.call(this);\n\t            this.onload = null;\n\t            g.doc.body.removeChild(this);\n\t        };\n\t        img.onerror = function () {\n\t            g.doc.body.removeChild(this);\n\t        };\n\t        g.doc.body.appendChild(img);\n\t        img.src = src;\n\t    };\n\n\t    function clrToString() {\n\t        return this.hex;\n\t    }\n\n\t    /*\\\n\t     * Raphael.getRGB\n\t     [ method ]\n\t     **\n\t     * Parses colour string as RGB object\n\t     > Parameters\n\t     - colour (string) colour string in one of formats:\n\t     # <ul>\n\t     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n\t     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t     #     <li>hsb(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsl(, , )  same as hsb</li>\n\t     #     <li>hsl(%, %, %)  same as hsb</li>\n\t     # </ul>\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue\n\t     o     hex (string) color in HTML/CSS format: #,\n\t     o     error (boolean) true if string cant be parsed\n\t     o }\n\t    \\*/\n\t    R.getRGB = cacher(function (colour) {\n\t        if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n\t            return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n\t        }\n\t        if (colour == \"none\") {\n\t            return {r: -1, g: -1, b: -1, hex: \"none\", toString: clrToString};\n\t        }\n\t        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n\t        var res,\n\t            red,\n\t            green,\n\t            blue,\n\t            opacity,\n\t            t,\n\t            values,\n\t            rgb = colour.match(colourRegExp);\n\t        if (rgb) {\n\t            if (rgb[2]) {\n\t                blue = toInt(rgb[2].substring(5), 16);\n\t                green = toInt(rgb[2].substring(3, 5), 16);\n\t                red = toInt(rgb[2].substring(1, 3), 16);\n\t            }\n\t            if (rgb[3]) {\n\t                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n\t                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n\t                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n\t            }\n\t            if (rgb[4]) {\n\t                values = rgb[4][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            }\n\t            if (rgb[5]) {\n\t                values = rgb[5][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t                return R.hsb2rgb(red, green, blue, opacity);\n\t            }\n\t            if (rgb[6]) {\n\t                values = rgb[6][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t                return R.hsl2rgb(red, green, blue, opacity);\n\t            }\n\t            rgb = {r: red, g: green, b: blue, toString: clrToString};\n\t            rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n\t            R.is(opacity, \"finite\") && (rgb.opacity = opacity);\n\t            return rgb;\n\t        }\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n\t    }, R);\n\t    /*\\\n\t     * Raphael.hsb\n\t     [ method ]\n\t     **\n\t     * Converts HSB values to hex representation of the colour.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - b (number) value or brightness\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.hsb = cacher(function (h, s, b) {\n\t        return R.hsb2rgb(h, s, b).hex;\n\t    });\n\t    /*\\\n\t     * Raphael.hsl\n\t     [ method ]\n\t     **\n\t     * Converts HSL values to hex representation of the colour.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - l (number) luminosity\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.hsl = cacher(function (h, s, l) {\n\t        return R.hsl2rgb(h, s, l).hex;\n\t    });\n\t    /*\\\n\t     * Raphael.rgb\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to hex representation of the colour.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.rgb = cacher(function (r, g, b) {\n\t        function round(x) { return (x + 0.5) | 0; }\n\t        return \"#\" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);\n\t    });\n\t    /*\\\n\t     * Raphael.getColor\n\t     [ method ]\n\t     **\n\t     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\n\t     > Parameters\n\t     - value (number) #optional brightness, default is `0.75`\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.getColor = function (value) {\n\t        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},\n\t            rgb = this.hsb2rgb(start.h, start.s, start.b);\n\t        start.h += .075;\n\t        if (start.h > 1) {\n\t            start.h = 0;\n\t            start.s -= .2;\n\t            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});\n\t        }\n\t        return rgb.hex;\n\t    };\n\t    /*\\\n\t     * Raphael.getColor.reset\n\t     [ method ]\n\t     **\n\t     * Resets spectrum position for @Raphael.getColor back to red.\n\t    \\*/\n\t    R.getColor.reset = function () {\n\t        delete this.start;\n\t    };\n\n\t    // http://schepers.cc/getting-to-the-point\n\t    function catmullRom2bezier(crp, z) {\n\t        var d = [];\n\t        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n\t            var p = [\n\t                        {x: +crp[i - 2], y: +crp[i - 1]},\n\t                        {x: +crp[i],     y: +crp[i + 1]},\n\t                        {x: +crp[i + 2], y: +crp[i + 3]},\n\t                        {x: +crp[i + 4], y: +crp[i + 5]}\n\t                    ];\n\t            if (z) {\n\t                if (!i) {\n\t                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n\t                } else if (iLen - 4 == i) {\n\t                    p[3] = {x: +crp[0], y: +crp[1]};\n\t                } else if (iLen - 2 == i) {\n\t                    p[2] = {x: +crp[0], y: +crp[1]};\n\t                    p[3] = {x: +crp[2], y: +crp[3]};\n\t                }\n\t            } else {\n\t                if (iLen - 4 == i) {\n\t                    p[3] = p[2];\n\t                } else if (!i) {\n\t                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n\t                }\n\t            }\n\t            d.push([\"C\",\n\t                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n\t                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n\t                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n\t                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n\t                  p[2].x,\n\t                  p[2].y\n\t            ]);\n\t        }\n\n\t        return d;\n\t    }\n\t    /*\\\n\t     * Raphael.parsePathString\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Parses given path string into an array of arrays of path segments.\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.parsePathString = function (pathString) {\n\t        if (!pathString) {\n\t            return null;\n\t        }\n\t        var pth = paths(pathString);\n\t        if (pth.arr) {\n\t            return pathClone(pth.arr);\n\t        }\n\n\t        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},\n\t            data = [];\n\t        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption\n\t            data = pathClone(pathString);\n\t        }\n\t        if (!data.length) {\n\t            Str(pathString).replace(pathCommand, function (a, b, c) {\n\t                var params = [],\n\t                    name = b.toLowerCase();\n\t                c.replace(pathValues, function (a, b) {\n\t                    b && params.push(+b);\n\t                });\n\t                if (name == \"m\" && params.length > 2) {\n\t                    data.push([b][concat](params.splice(0, 2)));\n\t                    name = \"l\";\n\t                    b = b == \"m\" ? \"l\" : \"L\";\n\t                }\n\t                if (name == \"r\") {\n\t                    data.push([b][concat](params));\n\t                } else while (params.length >= paramCounts[name]) {\n\t                    data.push([b][concat](params.splice(0, paramCounts[name])));\n\t                    if (!paramCounts[name]) {\n\t                        break;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        data.toString = R._path2string;\n\t        pth.arr = pathClone(data);\n\t        return data;\n\t    };\n\t    /*\\\n\t     * Raphael.parseTransformString\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Parses given path string into an array of transformations.\n\t     > Parameters\n\t     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\n\t     = (array) array of transformations.\n\t    \\*/\n\t    R.parseTransformString = cacher(function (TString) {\n\t        if (!TString) {\n\t            return null;\n\t        }\n\t        var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n\t            data = [];\n\t        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption\n\t            data = pathClone(TString);\n\t        }\n\t        if (!data.length) {\n\t            Str(TString).replace(tCommand, function (a, b, c) {\n\t                var params = [],\n\t                    name = lowerCase.call(b);\n\t                c.replace(pathValues, function (a, b) {\n\t                    b && params.push(+b);\n\t                });\n\t                data.push([b][concat](params));\n\t            });\n\t        }\n\t        data.toString = R._path2string;\n\t        return data;\n\t    });\n\t    // PATHS\n\t    var paths = function (ps) {\n\t        var p = paths.ps = paths.ps || {};\n\t        if (p[ps]) {\n\t            p[ps].sleep = 100;\n\t        } else {\n\t            p[ps] = {\n\t                sleep: 100\n\t            };\n\t        }\n\t        setTimeout(function () {\n\t            for (var key in p) if (p[has](key) && key != ps) {\n\t                p[key].sleep--;\n\t                !p[key].sleep && delete p[key];\n\t            }\n\t        });\n\t        return p[ps];\n\t    };\n\t    /*\\\n\t     * Raphael.findDotsAtSegment\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Find dot coordinates on the given cubic bezier curve at the given t.\n\t     > Parameters\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     - t (number) position on the curve (0..1)\n\t     = (object) point information in format:\n\t     o {\n\t     o     x: (number) x coordinate of the point\n\t     o     y: (number) y coordinate of the point\n\t     o     m: {\n\t     o         x: (number) x coordinate of the left anchor\n\t     o         y: (number) y coordinate of the left anchor\n\t     o     }\n\t     o     n: {\n\t     o         x: (number) x coordinate of the right anchor\n\t     o         y: (number) y coordinate of the right anchor\n\t     o     }\n\t     o     start: {\n\t     o         x: (number) x coordinate of the start of the curve\n\t     o         y: (number) y coordinate of the start of the curve\n\t     o     }\n\t     o     end: {\n\t     o         x: (number) x coordinate of the end of the curve\n\t     o         y: (number) y coordinate of the end of the curve\n\t     o     }\n\t     o     alpha: (number) angle of the curve derivative at the point\n\t     o }\n\t    \\*/\n\t    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t,\n\t            t13 = pow(t1, 3),\n\t            t12 = pow(t1, 2),\n\t            t2 = t * t,\n\t            t3 = t2 * t,\n\t            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n\t            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n\t            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n\t            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n\t            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n\t            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n\t            ax = t1 * p1x + t * c1x,\n\t            ay = t1 * p1y + t * c1y,\n\t            cx = t1 * c2x + t * p2x,\n\t            cy = t1 * c2y + t * p2y,\n\t            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n\t        (mx > nx || my < ny) && (alpha += 180);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            m: {x: mx, y: my},\n\t            n: {x: nx, y: ny},\n\t            start: {x: ax, y: ay},\n\t            end: {x: cx, y: cy},\n\t            alpha: alpha\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.bezierBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Return bounding box of a given cubic bezier curve\n\t     > Parameters\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     * or\n\t     - bez (array) array of six points for bezier curve\n\t     = (object) point information in format:\n\t     o {\n\t     o     min: {\n\t     o         x: (number) x coordinate of the left point\n\t     o         y: (number) y coordinate of the top point\n\t     o     }\n\t     o     max: {\n\t     o         x: (number) x coordinate of the right point\n\t     o         y: (number) y coordinate of the bottom point\n\t     o     }\n\t     o }\n\t    \\*/\n\t    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t        if (!R.is(p1x, \"array\")) {\n\t            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n\t        }\n\t        var bbox = curveDim.apply(null, p1x);\n\t        return {\n\t            x: bbox.min.x,\n\t            y: bbox.min.y,\n\t            x2: bbox.max.x,\n\t            y2: bbox.max.y,\n\t            width: bbox.max.x - bbox.min.x,\n\t            height: bbox.max.y - bbox.min.y\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.isPointInsideBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside bounding boxes.\n\t     > Parameters\n\t     - bbox (string) bounding box\n\t     - x (string) x coordinate of the point\n\t     - y (string) y coordinate of the point\n\t     = (boolean) `true` if point inside\n\t    \\*/\n\t    R.isPointInsideBBox = function (bbox, x, y) {\n\t        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\n\t    };\n\t    /*\\\n\t     * Raphael.isBBoxIntersect\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if two bounding boxes intersect\n\t     > Parameters\n\t     - bbox1 (string) first bounding box\n\t     - bbox2 (string) second bounding box\n\t     = (boolean) `true` if they intersect\n\t    \\*/\n\t    R.isBBoxIntersect = function (bbox1, bbox2) {\n\t        var i = R.isPointInsideBBox;\n\t        return i(bbox2, bbox1.x, bbox1.y)\n\t            || i(bbox2, bbox1.x2, bbox1.y)\n\t            || i(bbox2, bbox1.x, bbox1.y2)\n\t            || i(bbox2, bbox1.x2, bbox1.y2)\n\t            || i(bbox1, bbox2.x, bbox2.y)\n\t            || i(bbox1, bbox2.x2, bbox2.y)\n\t            || i(bbox1, bbox2.x, bbox2.y2)\n\t            || i(bbox1, bbox2.x2, bbox2.y2)\n\t            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n\t            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n\t    };\n\t    function base3(t, p1, p2, p3, p4) {\n\t        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n\t            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n\t        return t * t2 - 3 * p1 + 3 * p2;\n\t    }\n\t    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n\t        if (z == null) {\n\t            z = 1;\n\t        }\n\t        z = z > 1 ? 1 : z < 0 ? 0 : z;\n\t        var z2 = z / 2,\n\t            n = 12,\n\t            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],\n\t            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n\t            sum = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var ct = z2 * Tvalues[i] + z2,\n\t                xbase = base3(ct, x1, x2, x3, x4),\n\t                ybase = base3(ct, y1, y2, y3, y4),\n\t                comb = xbase * xbase + ybase * ybase;\n\t            sum += Cvalues[i] * math.sqrt(comb);\n\t        }\n\t        return z2 * sum;\n\t    }\n\t    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n\t        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n\t            return;\n\t        }\n\t        var t = 1,\n\t            step = t / 2,\n\t            t2 = t - step,\n\t            l,\n\t            e = .01;\n\t        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        while (abs(l - ll) > e) {\n\t            step /= 2;\n\t            t2 += (l < ll ? 1 : -1) * step;\n\t            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        }\n\t        return t2;\n\t    }\n\t    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\t        if (\n\t            mmax(x1, x2) < mmin(x3, x4) ||\n\t            mmin(x1, x2) > mmax(x3, x4) ||\n\t            mmax(y1, y2) < mmin(y3, y4) ||\n\t            mmin(y1, y2) > mmax(y3, y4)\n\t        ) {\n\t            return;\n\t        }\n\t        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n\t            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n\t            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n\t        if (!denominator) {\n\t            return;\n\t        }\n\t        var px = nx / denominator,\n\t            py = ny / denominator,\n\t            px2 = +px.toFixed(2),\n\t            py2 = +py.toFixed(2);\n\t        if (\n\t            px2 < +mmin(x1, x2).toFixed(2) ||\n\t            px2 > +mmax(x1, x2).toFixed(2) ||\n\t            px2 < +mmin(x3, x4).toFixed(2) ||\n\t            px2 > +mmax(x3, x4).toFixed(2) ||\n\t            py2 < +mmin(y1, y2).toFixed(2) ||\n\t            py2 > +mmax(y1, y2).toFixed(2) ||\n\t            py2 < +mmin(y3, y4).toFixed(2) ||\n\t            py2 > +mmax(y3, y4).toFixed(2)\n\t        ) {\n\t            return;\n\t        }\n\t        return {x: px, y: py};\n\t    }\n\t    function inter(bez1, bez2) {\n\t        return interHelper(bez1, bez2);\n\t    }\n\t    function interCount(bez1, bez2) {\n\t        return interHelper(bez1, bez2, 1);\n\t    }\n\t    function interHelper(bez1, bez2, justCount) {\n\t        var bbox1 = R.bezierBBox(bez1),\n\t            bbox2 = R.bezierBBox(bez2);\n\t        if (!R.isBBoxIntersect(bbox1, bbox2)) {\n\t            return justCount ? 0 : [];\n\t        }\n\t        var l1 = bezlen.apply(0, bez1),\n\t            l2 = bezlen.apply(0, bez2),\n\t            n1 = mmax(~~(l1 / 5), 1),\n\t            n2 = mmax(~~(l2 / 5), 1),\n\t            dots1 = [],\n\t            dots2 = [],\n\t            xy = {},\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0; i < n1 + 1; i++) {\n\t            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\n\t            dots1.push({x: p.x, y: p.y, t: i / n1});\n\t        }\n\t        for (i = 0; i < n2 + 1; i++) {\n\t            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\n\t            dots2.push({x: p.x, y: p.y, t: i / n2});\n\t        }\n\t        for (i = 0; i < n1; i++) {\n\t            for (var j = 0; j < n2; j++) {\n\t                var di = dots1[i],\n\t                    di1 = dots1[i + 1],\n\t                    dj = dots2[j],\n\t                    dj1 = dots2[j + 1],\n\t                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n\t                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n\t                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\t                if (is) {\n\t                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n\t                        continue;\n\t                    }\n\t                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n\t                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n\t                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\t                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\n\t                        if (justCount) {\n\t                            res++;\n\t                        } else {\n\t                            res.push({\n\t                                x: is.x,\n\t                                y: is.y,\n\t                                t1: mmin(t1, 1),\n\t                                t2: mmin(t2, 1)\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    /*\\\n\t     * Raphael.pathIntersection\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds intersections of two paths\n\t     > Parameters\n\t     - path1 (string) path string\n\t     - path2 (string) path string\n\t     = (array) dots of intersection\n\t     o [\n\t     o     {\n\t     o         x: (number) x coordinate of the point\n\t     o         y: (number) y coordinate of the point\n\t     o         t1: (number) t value for segment of path1\n\t     o         t2: (number) t value for segment of path2\n\t     o         segment1: (number) order number for segment of path1\n\t     o         segment2: (number) order number for segment of path2\n\t     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1\n\t     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n\t     o     }\n\t     o ]\n\t    \\*/\n\t    R.pathIntersection = function (path1, path2) {\n\t        return interPathHelper(path1, path2);\n\t    };\n\t    R.pathIntersectionNumber = function (path1, path2) {\n\t        return interPathHelper(path1, path2, 1);\n\t    };\n\t    function interPathHelper(path1, path2, justCount) {\n\t        path1 = R._path2curve(path1);\n\t        path2 = R._path2curve(path2);\n\t        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0, ii = path1.length; i < ii; i++) {\n\t            var pi = path1[i];\n\t            if (pi[0] == \"M\") {\n\t                x1 = x1m = pi[1];\n\t                y1 = y1m = pi[2];\n\t            } else {\n\t                if (pi[0] == \"C\") {\n\t                    bez1 = [x1, y1].concat(pi.slice(1));\n\t                    x1 = bez1[6];\n\t                    y1 = bez1[7];\n\t                } else {\n\t                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n\t                    x1 = x1m;\n\t                    y1 = y1m;\n\t                }\n\t                for (var j = 0, jj = path2.length; j < jj; j++) {\n\t                    var pj = path2[j];\n\t                    if (pj[0] == \"M\") {\n\t                        x2 = x2m = pj[1];\n\t                        y2 = y2m = pj[2];\n\t                    } else {\n\t                        if (pj[0] == \"C\") {\n\t                            bez2 = [x2, y2].concat(pj.slice(1));\n\t                            x2 = bez2[6];\n\t                            y2 = bez2[7];\n\t                        } else {\n\t                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n\t                            x2 = x2m;\n\t                            y2 = y2m;\n\t                        }\n\t                        var intr = interHelper(bez1, bez2, justCount);\n\t                        if (justCount) {\n\t                            res += intr;\n\t                        } else {\n\t                            for (var k = 0, kk = intr.length; k < kk; k++) {\n\t                                intr[k].segment1 = i;\n\t                                intr[k].segment2 = j;\n\t                                intr[k].bez1 = bez1;\n\t                                intr[k].bez2 = bez2;\n\t                            }\n\t                            res = res.concat(intr);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    /*\\\n\t     * Raphael.isPointInsidePath\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside a given closed path.\n\t     > Parameters\n\t     - path (string) path string\n\t     - x (number) x of the point\n\t     - y (number) y of the point\n\t     = (boolean) true, if point is inside the path\n\t    \\*/\n\t    R.isPointInsidePath = function (path, x, y) {\n\t        var bbox = R.pathBBox(path);\n\t        return R.isPointInsideBBox(bbox, x, y) &&\n\t               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n\t    };\n\t    R._removedFactory = function (methodname) {\n\t        return function () {\n\t            eve(\"raphael.log\", null, \"Rapha\\xebl: you are calling to method \\u201c\" + methodname + \"\\u201d of removed object\", methodname);\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.pathBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Return bounding box of a given path\n\t     > Parameters\n\t     - path (string) path string\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box\n\t     o     y: (number) y coordinate of the left top point of the box\n\t     o     x2: (number) x coordinate of the right bottom point of the box\n\t     o     y2: (number) y coordinate of the right bottom point of the box\n\t     o     width: (number) width of the box\n\t     o     height: (number) height of the box\n\t     o     cx: (number) x coordinate of the center of the box\n\t     o     cy: (number) y coordinate of the center of the box\n\t     o }\n\t    \\*/\n\t    var pathDimensions = R.pathBBox = function (path) {\n\t        var pth = paths(path);\n\t        if (pth.bbox) {\n\t            return clone(pth.bbox);\n\t        }\n\t        if (!path) {\n\t            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};\n\t        }\n\t        path = path2curve(path);\n\t        var x = 0,\n\t            y = 0,\n\t            X = [],\n\t            Y = [],\n\t            p;\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            p = path[i];\n\t            if (p[0] == \"M\") {\n\t                x = p[1];\n\t                y = p[2];\n\t                X.push(x);\n\t                Y.push(y);\n\t            } else {\n\t                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                X = X[concat](dim.min.x, dim.max.x);\n\t                Y = Y[concat](dim.min.y, dim.max.y);\n\t                x = p[5];\n\t                y = p[6];\n\t            }\n\t        }\n\t        var xmin = mmin[apply](0, X),\n\t            ymin = mmin[apply](0, Y),\n\t            xmax = mmax[apply](0, X),\n\t            ymax = mmax[apply](0, Y),\n\t            width = xmax - xmin,\n\t            height = ymax - ymin,\n\t                bb = {\n\t                x: xmin,\n\t                y: ymin,\n\t                x2: xmax,\n\t                y2: ymax,\n\t                width: width,\n\t                height: height,\n\t                cx: xmin + width / 2,\n\t                cy: ymin + height / 2\n\t            };\n\t        pth.bbox = clone(bb);\n\t        return bb;\n\t    },\n\t        pathClone = function (pathArray) {\n\t            var res = clone(pathArray);\n\t            res.toString = R._path2string;\n\t            return res;\n\t        },\n\t        pathToRelative = R._pathToRelative = function (pathArray) {\n\t            var pth = paths(pathArray);\n\t            if (pth.rel) {\n\t                return pathClone(pth.rel);\n\t            }\n\t            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n\t                pathArray = R.parsePathString(pathArray);\n\t            }\n\t            var res = [],\n\t                x = 0,\n\t                y = 0,\n\t                mx = 0,\n\t                my = 0,\n\t                start = 0;\n\t            if (pathArray[0][0] == \"M\") {\n\t                x = pathArray[0][1];\n\t                y = pathArray[0][2];\n\t                mx = x;\n\t                my = y;\n\t                start++;\n\t                res.push([\"M\", x, y]);\n\t            }\n\t            for (var i = start, ii = pathArray.length; i < ii; i++) {\n\t                var r = res[i] = [],\n\t                    pa = pathArray[i];\n\t                if (pa[0] != lowerCase.call(pa[0])) {\n\t                    r[0] = lowerCase.call(pa[0]);\n\t                    switch (r[0]) {\n\t                        case \"a\":\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +(pa[6] - x).toFixed(3);\n\t                            r[7] = +(pa[7] - y).toFixed(3);\n\t                            break;\n\t                        case \"v\":\n\t                            r[1] = +(pa[1] - y).toFixed(3);\n\t                            break;\n\t                        case \"m\":\n\t                            mx = pa[1];\n\t                            my = pa[2];\n\t                        default:\n\t                            for (var j = 1, jj = pa.length; j < jj; j++) {\n\t                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n\t                            }\n\t                    }\n\t                } else {\n\t                    r = res[i] = [];\n\t                    if (pa[0] == \"m\") {\n\t                        mx = pa[1] + x;\n\t                        my = pa[2] + y;\n\t                    }\n\t                    for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                        res[i][k] = pa[k];\n\t                    }\n\t                }\n\t                var len = res[i].length;\n\t                switch (res[i][0]) {\n\t                    case \"z\":\n\t                        x = mx;\n\t                        y = my;\n\t                        break;\n\t                    case \"h\":\n\t                        x += +res[i][len - 1];\n\t                        break;\n\t                    case \"v\":\n\t                        y += +res[i][len - 1];\n\t                        break;\n\t                    default:\n\t                        x += +res[i][len - 2];\n\t                        y += +res[i][len - 1];\n\t                }\n\t            }\n\t            res.toString = R._path2string;\n\t            pth.rel = pathClone(res);\n\t            return res;\n\t        },\n\t        pathToAbsolute = R._pathToAbsolute = function (pathArray) {\n\t            var pth = paths(pathArray);\n\t            if (pth.abs) {\n\t                return pathClone(pth.abs);\n\t            }\n\t            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n\t                pathArray = R.parsePathString(pathArray);\n\t            }\n\t            if (!pathArray || !pathArray.length) {\n\t                return [[\"M\", 0, 0]];\n\t            }\n\t            var res = [],\n\t                x = 0,\n\t                y = 0,\n\t                mx = 0,\n\t                my = 0,\n\t                start = 0;\n\t            if (pathArray[0][0] == \"M\") {\n\t                x = +pathArray[0][1];\n\t                y = +pathArray[0][2];\n\t                mx = x;\n\t                my = y;\n\t                start++;\n\t                res[0] = [\"M\", x, y];\n\t            }\n\t            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n\t            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n\t                res.push(r = []);\n\t                pa = pathArray[i];\n\t                if (pa[0] != upperCase.call(pa[0])) {\n\t                    r[0] = upperCase.call(pa[0]);\n\t                    switch (r[0]) {\n\t                        case \"A\":\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +(pa[6] + x);\n\t                            r[7] = +(pa[7] + y);\n\t                            break;\n\t                        case \"V\":\n\t                            r[1] = +pa[1] + y;\n\t                            break;\n\t                        case \"H\":\n\t                            r[1] = +pa[1] + x;\n\t                            break;\n\t                        case \"R\":\n\t                            var dots = [x, y][concat](pa.slice(1));\n\t                            for (var j = 2, jj = dots.length; j < jj; j++) {\n\t                                dots[j] = +dots[j] + x;\n\t                                dots[++j] = +dots[j] + y;\n\t                            }\n\t                            res.pop();\n\t                            res = res[concat](catmullRom2bezier(dots, crz));\n\t                            break;\n\t                        case \"M\":\n\t                            mx = +pa[1] + x;\n\t                            my = +pa[2] + y;\n\t                        default:\n\t                            for (j = 1, jj = pa.length; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                    }\n\t                } else if (pa[0] == \"R\") {\n\t                    dots = [x, y][concat](pa.slice(1));\n\t                    res.pop();\n\t                    res = res[concat](catmullRom2bezier(dots, crz));\n\t                    r = [\"R\"][concat](pa.slice(-2));\n\t                } else {\n\t                    for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                        r[k] = pa[k];\n\t                    }\n\t                }\n\t                switch (r[0]) {\n\t                    case \"Z\":\n\t                        x = mx;\n\t                        y = my;\n\t                        break;\n\t                    case \"H\":\n\t                        x = r[1];\n\t                        break;\n\t                    case \"V\":\n\t                        y = r[1];\n\t                        break;\n\t                    case \"M\":\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                }\n\t            }\n\t            res.toString = R._path2string;\n\t            pth.abs = pathClone(res);\n\t            return res;\n\t        },\n\t        l2c = function (x1, y1, x2, y2) {\n\t            return [x1, y1, x2, y2, x2, y2];\n\t        },\n\t        q2c = function (x1, y1, ax, ay, x2, y2) {\n\t            var _13 = 1 / 3,\n\t                _23 = 2 / 3;\n\t            return [\n\t                    _13 * x1 + _23 * ax,\n\t                    _13 * y1 + _23 * ay,\n\t                    _13 * x2 + _23 * ax,\n\t                    _13 * y2 + _23 * ay,\n\t                    x2,\n\t                    y2\n\t                ];\n\t        },\n\t        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t            // for more information of where this math came from visit:\n\t            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t            var _120 = PI * 120 / 180,\n\t                rad = PI / 180 * (+angle || 0),\n\t                res = [],\n\t                xy,\n\t                rotate = cacher(function (x, y, rad) {\n\t                    var X = x * math.cos(rad) - y * math.sin(rad),\n\t                        Y = x * math.sin(rad) + y * math.cos(rad);\n\t                    return {x: X, y: Y};\n\t                });\n\t            if (!recursive) {\n\t                xy = rotate(x1, y1, -rad);\n\t                x1 = xy.x;\n\t                y1 = xy.y;\n\t                xy = rotate(x2, y2, -rad);\n\t                x2 = xy.x;\n\t                y2 = xy.y;\n\t                var cos = math.cos(PI / 180 * angle),\n\t                    sin = math.sin(PI / 180 * angle),\n\t                    x = (x1 - x2) / 2,\n\t                    y = (y1 - y2) / 2;\n\t                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n\t                if (h > 1) {\n\t                    h = math.sqrt(h);\n\t                    rx = h * rx;\n\t                    ry = h * ry;\n\t                }\n\t                var rx2 = rx * rx,\n\t                    ry2 = ry * ry,\n\t                    k = (large_arc_flag == sweep_flag ? -1 : 1) *\n\t                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n\t                    cx = k * rx * y / ry + (x1 + x2) / 2,\n\t                    cy = k * -ry * x / rx + (y1 + y2) / 2,\n\t                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n\t                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n\t                f1 = x1 < cx ? PI - f1 : f1;\n\t                f2 = x2 < cx ? PI - f2 : f2;\n\t                f1 < 0 && (f1 = PI * 2 + f1);\n\t                f2 < 0 && (f2 = PI * 2 + f2);\n\t                if (sweep_flag && f1 > f2) {\n\t                    f1 = f1 - PI * 2;\n\t                }\n\t                if (!sweep_flag && f2 > f1) {\n\t                    f2 = f2 - PI * 2;\n\t                }\n\t            } else {\n\t                f1 = recursive[0];\n\t                f2 = recursive[1];\n\t                cx = recursive[2];\n\t                cy = recursive[3];\n\t            }\n\t            var df = f2 - f1;\n\t            if (abs(df) > _120) {\n\t                var f2old = f2,\n\t                    x2old = x2,\n\t                    y2old = y2;\n\t                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t                x2 = cx + rx * math.cos(f2);\n\t                y2 = cy + ry * math.sin(f2);\n\t                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t            }\n\t            df = f2 - f1;\n\t            var c1 = math.cos(f1),\n\t                s1 = math.sin(f1),\n\t                c2 = math.cos(f2),\n\t                s2 = math.sin(f2),\n\t                t = math.tan(df / 4),\n\t                hx = 4 / 3 * rx * t,\n\t                hy = 4 / 3 * ry * t,\n\t                m1 = [x1, y1],\n\t                m2 = [x1 + hx * s1, y1 - hy * c1],\n\t                m3 = [x2 + hx * s2, y2 - hy * c2],\n\t                m4 = [x2, y2];\n\t            m2[0] = 2 * m1[0] - m2[0];\n\t            m2[1] = 2 * m1[1] - m2[1];\n\t            if (recursive) {\n\t                return [m2, m3, m4][concat](res);\n\t            } else {\n\t                res = [m2, m3, m4][concat](res).join()[split](\",\");\n\t                var newres = [];\n\t                for (var i = 0, ii = res.length; i < ii; i++) {\n\t                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t                }\n\t                return newres;\n\t            }\n\t        },\n\t        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t            var t1 = 1 - t;\n\t            return {\n\t                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n\t                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n\t            };\n\t        },\n\t        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),\n\t                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\n\t                c = p1x - c1x,\n\t                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\n\t                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\n\t                y = [p1y, p2y],\n\t                x = [p1x, p2x],\n\t                dot;\n\t            abs(t1) > \"1e12\" && (t1 = .5);\n\t            abs(t2) > \"1e12\" && (t2 = .5);\n\t            if (t1 > 0 && t1 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            if (t2 > 0 && t2 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);\n\t            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\n\t            c = p1y - c1y;\n\t            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\n\t            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\n\t            abs(t1) > \"1e12\" && (t1 = .5);\n\t            abs(t2) > \"1e12\" && (t2 = .5);\n\t            if (t1 > 0 && t1 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            if (t2 > 0 && t2 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            return {\n\t                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},\n\t                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}\n\t            };\n\t        }),\n\t        path2curve = R._path2curve = cacher(function (path, path2) {\n\t            var pth = !path2 && paths(path);\n\t            if (!path2 && pth.curve) {\n\t                return pathClone(pth.curve);\n\t            }\n\t            var p = pathToAbsolute(path),\n\t                p2 = path2 && pathToAbsolute(path2),\n\t                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t                processPath = function (path, d, pcom) {\n\t                    var nx, ny, tq = {T:1, Q:1};\n\t                    if (!path) {\n\t                        return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n\t                    }\n\t                    !(path[0] in tq) && (d.qx = d.qy = null);\n\t                    switch (path[0]) {\n\t                        case \"M\":\n\t                            d.X = path[1];\n\t                            d.Y = path[2];\n\t                            break;\n\t                        case \"A\":\n\t                            path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\n\t                            break;\n\t                        case \"S\":\n\t                            if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n\t                                nx = d.x * 2 - d.bx;          // And reflect the previous\n\t                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n\t                            }\n\t                            else {                            // or some else or nothing\n\t                                nx = d.x;\n\t                                ny = d.y;\n\t                            }\n\t                            path = [\"C\", nx, ny][concat](path.slice(1));\n\t                            break;\n\t                        case \"T\":\n\t                            if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n\t                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n\t                                d.qy = d.y * 2 - d.qy;        // to case \"S\".\n\t                            }\n\t                            else {                            // or something else or nothing\n\t                                d.qx = d.x;\n\t                                d.qy = d.y;\n\t                            }\n\t                            path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                            break;\n\t                        case \"Q\":\n\t                            d.qx = path[1];\n\t                            d.qy = path[2];\n\t                            path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                            break;\n\t                        case \"L\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\n\t                            break;\n\t                        case \"H\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\n\t                            break;\n\t                        case \"V\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\n\t                            break;\n\t                        case \"Z\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\n\t                            break;\n\t                    }\n\t                    return path;\n\t                },\n\t                fixArc = function (pp, i) {\n\t                    if (pp[i].length > 7) {\n\t                        pp[i].shift();\n\t                        var pi = pp[i];\n\t                        while (pi.length) {\n\t                            pcoms1[i]=\"A\"; // if created multiple C:s, their original seg is saved\n\t                            p2 && (pcoms2[i]=\"A\"); // the same as above\n\t                            pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\n\t                        }\n\t                        pp.splice(i, 1);\n\t                        ii = mmax(p.length, p2 && p2.length || 0);\n\t                    }\n\t                },\n\t                fixM = function (path1, path2, a1, a2, i) {\n\t                    if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n\t                        path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n\t                        a1.bx = 0;\n\t                        a1.by = 0;\n\t                        a1.x = path1[i][1];\n\t                        a1.y = path1[i][2];\n\t                        ii = mmax(p.length, p2 && p2.length || 0);\n\t                    }\n\t                },\n\t                pcoms1 = [], // path commands of original path p\n\t                pcoms2 = [], // path commands of original path p2\n\t                pfirst = \"\", // temporary holder for original path command\n\t                pcom = \"\"; // holder for previous path command of original path\n\t            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n\t                p[i] && (pfirst = p[i][0]); // save current path command\n\n\t                if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n\t                {\n\t                    pcoms1[i] = pfirst; // Save current path command\n\t                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom\n\t                }\n\t                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t                if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n\t                // which may produce multiple C:s\n\t                // so we have to make sure that C is also C in original path\n\n\t                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n\t                if (p2) { // the same procedures is done to p2\n\t                    p2[i] && (pfirst = p2[i][0]);\n\t                    if (pfirst != \"C\")\n\t                    {\n\t                        pcoms2[i] = pfirst;\n\t                        i && (pcom = pcoms2[i-1]);\n\t                    }\n\t                    p2[i] = processPath(p2[i], attrs2, pcom);\n\n\t                    if (pcoms2[i]!=\"A\" && pfirst==\"C\") pcoms2[i]=\"C\";\n\n\t                    fixArc(p2, i);\n\t                }\n\t                fixM(p, p2, attrs, attrs2, i);\n\t                fixM(p2, p, attrs2, attrs, i);\n\t                var seg = p[i],\n\t                    seg2 = p2 && p2[i],\n\t                    seglen = seg.length,\n\t                    seg2len = p2 && seg2.length;\n\t                attrs.x = seg[seglen - 2];\n\t                attrs.y = seg[seglen - 1];\n\t                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n\t                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n\t                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n\t                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n\t                attrs2.x = p2 && seg2[seg2len - 2];\n\t                attrs2.y = p2 && seg2[seg2len - 1];\n\t            }\n\t            if (!p2) {\n\t                pth.curve = pathClone(p);\n\t            }\n\t            return p2 ? [p, p2] : p;\n\t        }, null, pathClone),\n\t        parseDots = R._parseDots = cacher(function (gradient) {\n\t            var dots = [];\n\t            for (var i = 0, ii = gradient.length; i < ii; i++) {\n\t                var dot = {},\n\t                    par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\n\t                dot.color = R.getRGB(par[1]);\n\t                if (dot.color.error) {\n\t                    return null;\n\t                }\n\t                dot.opacity = dot.color.opacity;\n\t                dot.color = dot.color.hex;\n\t                par[2] && (dot.offset = par[2] + \"%\");\n\t                dots.push(dot);\n\t            }\n\t            for (i = 1, ii = dots.length - 1; i < ii; i++) {\n\t                if (!dots[i].offset) {\n\t                    var start = toFloat(dots[i - 1].offset || 0),\n\t                        end = 0;\n\t                    for (var j = i + 1; j < ii; j++) {\n\t                        if (dots[j].offset) {\n\t                            end = dots[j].offset;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!end) {\n\t                        end = 100;\n\t                        j = ii;\n\t                    }\n\t                    end = toFloat(end);\n\t                    var d = (end - start) / (j - i + 1);\n\t                    for (; i < j; i++) {\n\t                        start += d;\n\t                        dots[i].offset = start + \"%\";\n\t                    }\n\t                }\n\t            }\n\t            return dots;\n\t        }),\n\t        tear = R._tear = function (el, paper) {\n\t            el == paper.top && (paper.top = el.prev);\n\t            el == paper.bottom && (paper.bottom = el.next);\n\t            el.next && (el.next.prev = el.prev);\n\t            el.prev && (el.prev.next = el.next);\n\t        },\n\t        tofront = R._tofront = function (el, paper) {\n\t            if (paper.top === el) {\n\t                return;\n\t            }\n\t            tear(el, paper);\n\t            el.next = null;\n\t            el.prev = paper.top;\n\t            paper.top.next = el;\n\t            paper.top = el;\n\t        },\n\t        toback = R._toback = function (el, paper) {\n\t            if (paper.bottom === el) {\n\t                return;\n\t            }\n\t            tear(el, paper);\n\t            el.next = paper.bottom;\n\t            el.prev = null;\n\t            paper.bottom.prev = el;\n\t            paper.bottom = el;\n\t        },\n\t        insertafter = R._insertafter = function (el, el2, paper) {\n\t            tear(el, paper);\n\t            el2 == paper.top && (paper.top = el);\n\t            el2.next && (el2.next.prev = el);\n\t            el.next = el2.next;\n\t            el.prev = el2;\n\t            el2.next = el;\n\t        },\n\t        insertbefore = R._insertbefore = function (el, el2, paper) {\n\t            tear(el, paper);\n\t            el2 == paper.bottom && (paper.bottom = el);\n\t            el2.prev && (el2.prev.next = el);\n\t            el.prev = el2.prev;\n\t            el2.prev = el;\n\t            el.next = el2;\n\t        },\n\t        /*\\\n\t         * Raphael.toMatrix\n\t         [ method ]\n\t         **\n\t         * Utility method\n\t         **\n\t         * Returns matrix of transformations applied to a given path\n\t         > Parameters\n\t         - path (string) path string\n\t         - transform (string|array) transformation string\n\t         = (object) @Matrix\n\t        \\*/\n\t        toMatrix = R.toMatrix = function (path, transform) {\n\t            var bb = pathDimensions(path),\n\t                el = {\n\t                    _: {\n\t                        transform: E\n\t                    },\n\t                    getBBox: function () {\n\t                        return bb;\n\t                    }\n\t                };\n\t            extractTransform(el, transform);\n\t            return el.matrix;\n\t        },\n\t        /*\\\n\t         * Raphael.transformPath\n\t         [ method ]\n\t         **\n\t         * Utility method\n\t         **\n\t         * Returns path transformed by a given transformation\n\t         > Parameters\n\t         - path (string) path string\n\t         - transform (string|array) transformation string\n\t         = (string) path\n\t        \\*/\n\t        transformPath = R.transformPath = function (path, transform) {\n\t            return mapPath(path, toMatrix(path, transform));\n\t        },\n\t        extractTransform = R._extractTransform = function (el, tstr) {\n\t            if (tstr == null) {\n\t                return el._.transform;\n\t            }\n\t            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n\t            var tdata = R.parseTransformString(tstr),\n\t                deg = 0,\n\t                dx = 0,\n\t                dy = 0,\n\t                sx = 1,\n\t                sy = 1,\n\t                _ = el._,\n\t                m = new Matrix;\n\t            _.transform = tdata || [];\n\t            if (tdata) {\n\t                for (var i = 0, ii = tdata.length; i < ii; i++) {\n\t                    var t = tdata[i],\n\t                        tlen = t.length,\n\t                        command = Str(t[0]).toLowerCase(),\n\t                        absolute = t[0] != command,\n\t                        inver = absolute ? m.invert() : 0,\n\t                        x1,\n\t                        y1,\n\t                        x2,\n\t                        y2,\n\t                        bb;\n\t                    if (command == \"t\" && tlen == 3) {\n\t                        if (absolute) {\n\t                            x1 = inver.x(0, 0);\n\t                            y1 = inver.y(0, 0);\n\t                            x2 = inver.x(t[1], t[2]);\n\t                            y2 = inver.y(t[1], t[2]);\n\t                            m.translate(x2 - x1, y2 - y1);\n\t                        } else {\n\t                            m.translate(t[1], t[2]);\n\t                        }\n\t                    } else if (command == \"r\") {\n\t                        if (tlen == 2) {\n\t                            bb = bb || el.getBBox(1);\n\t                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                            deg += t[1];\n\t                        } else if (tlen == 4) {\n\t                            if (absolute) {\n\t                                x2 = inver.x(t[2], t[3]);\n\t                                y2 = inver.y(t[2], t[3]);\n\t                                m.rotate(t[1], x2, y2);\n\t                            } else {\n\t                                m.rotate(t[1], t[2], t[3]);\n\t                            }\n\t                            deg += t[1];\n\t                        }\n\t                    } else if (command == \"s\") {\n\t                        if (tlen == 2 || tlen == 3) {\n\t                            bb = bb || el.getBBox(1);\n\t                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                            sx *= t[1];\n\t                            sy *= t[tlen - 1];\n\t                        } else if (tlen == 5) {\n\t                            if (absolute) {\n\t                                x2 = inver.x(t[3], t[4]);\n\t                                y2 = inver.y(t[3], t[4]);\n\t                                m.scale(t[1], t[2], x2, y2);\n\t                            } else {\n\t                                m.scale(t[1], t[2], t[3], t[4]);\n\t                            }\n\t                            sx *= t[1];\n\t                            sy *= t[2];\n\t                        }\n\t                    } else if (command == \"m\" && tlen == 7) {\n\t                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n\t                    }\n\t                    _.dirtyT = 1;\n\t                    el.matrix = m;\n\t                }\n\t            }\n\n\t            /*\\\n\t             * Element.matrix\n\t             [ property (object) ]\n\t             **\n\t             * Keeps @Matrix object, which represents element transformation\n\t            \\*/\n\t            el.matrix = m;\n\n\t            _.sx = sx;\n\t            _.sy = sy;\n\t            _.deg = deg;\n\t            _.dx = dx = m.e;\n\t            _.dy = dy = m.f;\n\n\t            if (sx == 1 && sy == 1 && !deg && _.bbox) {\n\t                _.bbox.x += +dx;\n\t                _.bbox.y += +dy;\n\t            } else {\n\t                _.dirtyT = 1;\n\t            }\n\t        },\n\t        getEmpty = function (item) {\n\t            var l = item[0];\n\t            switch (l.toLowerCase()) {\n\t                case \"t\": return [l, 0, 0];\n\t                case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n\t                case \"r\": if (item.length == 4) {\n\t                    return [l, 0, item[2], item[3]];\n\t                } else {\n\t                    return [l, 0];\n\t                }\n\t                case \"s\": if (item.length == 5) {\n\t                    return [l, 1, 1, item[3], item[4]];\n\t                } else if (item.length == 3) {\n\t                    return [l, 1, 1];\n\t                } else {\n\t                    return [l, 1];\n\t                }\n\t            }\n\t        },\n\t        equaliseTransform = R._equaliseTransform = function (t1, t2) {\n\t            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n\t            t1 = R.parseTransformString(t1) || [];\n\t            t2 = R.parseTransformString(t2) || [];\n\t            var maxlength = mmax(t1.length, t2.length),\n\t                from = [],\n\t                to = [],\n\t                i = 0, j, jj,\n\t                tt1, tt2;\n\t            for (; i < maxlength; i++) {\n\t                tt1 = t1[i] || getEmpty(t2[i]);\n\t                tt2 = t2[i] || getEmpty(tt1);\n\t                if ((tt1[0] != tt2[0]) ||\n\t                    (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n\t                    (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n\t                    ) {\n\t                    return;\n\t                }\n\t                from[i] = [];\n\t                to[i] = [];\n\t                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\n\t                    j in tt1 && (from[i][j] = tt1[j]);\n\t                    j in tt2 && (to[i][j] = tt2[j]);\n\t                }\n\t            }\n\t            return {\n\t                from: from,\n\t                to: to\n\t            };\n\t        };\n\t    R._getContainer = function (x, y, w, h) {\n\t        var container;\n\t        container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\n\t        if (container == null) {\n\t            return;\n\t        }\n\t        if (container.tagName) {\n\t            if (y == null) {\n\t                return {\n\t                    container: container,\n\t                    width: container.style.pixelWidth || container.offsetWidth,\n\t                    height: container.style.pixelHeight || container.offsetHeight\n\t                };\n\t            } else {\n\t                return {\n\t                    container: container,\n\t                    width: y,\n\t                    height: w\n\t                };\n\t            }\n\t        }\n\t        return {\n\t            container: 1,\n\t            x: x,\n\t            y: y,\n\t            width: w,\n\t            height: h\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.pathToRelative\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to relative form\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.pathToRelative = pathToRelative;\n\t    R._engine = {};\n\t    /*\\\n\t     * Raphael.path2curve\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to a new path where all segments are cubic bezier curves.\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.path2curve = path2curve;\n\t    /*\\\n\t     * Raphael.matrix\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns matrix based on given parameters.\n\t     > Parameters\n\t     - a (number)\n\t     - b (number)\n\t     - c (number)\n\t     - d (number)\n\t     - e (number)\n\t     - f (number)\n\t     = (object) @Matrix\n\t    \\*/\n\t    R.matrix = function (a, b, c, d, e, f) {\n\t        return new Matrix(a, b, c, d, e, f);\n\t    };\n\t    function Matrix(a, b, c, d, e, f) {\n\t        if (a != null) {\n\t            this.a = +a;\n\t            this.b = +b;\n\t            this.c = +c;\n\t            this.d = +d;\n\t            this.e = +e;\n\t            this.f = +f;\n\t        } else {\n\t            this.a = 1;\n\t            this.b = 0;\n\t            this.c = 0;\n\t            this.d = 1;\n\t            this.e = 0;\n\t            this.f = 0;\n\t        }\n\t    }\n\t    (function (matrixproto) {\n\t        /*\\\n\t         * Matrix.add\n\t         [ method ]\n\t         **\n\t         * Adds given matrix to existing one.\n\t         > Parameters\n\t         - a (number)\n\t         - b (number)\n\t         - c (number)\n\t         - d (number)\n\t         - e (number)\n\t         - f (number)\n\t         or\n\t         - matrix (object) @Matrix\n\t        \\*/\n\t        matrixproto.add = function (a, b, c, d, e, f) {\n\t            var out = [[], [], []],\n\t                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n\t                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n\t                x, y, z, res;\n\n\t            if (a && a instanceof Matrix) {\n\t                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n\t            }\n\n\t            for (x = 0; x < 3; x++) {\n\t                for (y = 0; y < 3; y++) {\n\t                    res = 0;\n\t                    for (z = 0; z < 3; z++) {\n\t                        res += m[x][z] * matrix[z][y];\n\t                    }\n\t                    out[x][y] = res;\n\t                }\n\t            }\n\t            this.a = out[0][0];\n\t            this.b = out[1][0];\n\t            this.c = out[0][1];\n\t            this.d = out[1][1];\n\t            this.e = out[0][2];\n\t            this.f = out[1][2];\n\t        };\n\t        /*\\\n\t         * Matrix.invert\n\t         [ method ]\n\t         **\n\t         * Returns inverted version of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.invert = function () {\n\t            var me = this,\n\t                x = me.a * me.d - me.b * me.c;\n\t            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n\t        };\n\t        /*\\\n\t         * Matrix.clone\n\t         [ method ]\n\t         **\n\t         * Returns copy of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.clone = function () {\n\t            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t        };\n\t        /*\\\n\t         * Matrix.translate\n\t         [ method ]\n\t         **\n\t         * Translate the matrix\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t        \\*/\n\t        matrixproto.translate = function (x, y) {\n\t            this.add(1, 0, 0, 1, x, y);\n\t        };\n\t        /*\\\n\t         * Matrix.scale\n\t         [ method ]\n\t         **\n\t         * Scales the matrix\n\t         > Parameters\n\t         - x (number)\n\t         - y (number) #optional\n\t         - cx (number) #optional\n\t         - cy (number) #optional\n\t        \\*/\n\t        matrixproto.scale = function (x, y, cx, cy) {\n\t            y == null && (y = x);\n\t            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n\t            this.add(x, 0, 0, y, 0, 0);\n\t            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n\t        };\n\t        /*\\\n\t         * Matrix.rotate\n\t         [ method ]\n\t         **\n\t         * Rotates the matrix\n\t         > Parameters\n\t         - a (number)\n\t         - x (number)\n\t         - y (number)\n\t        \\*/\n\t        matrixproto.rotate = function (a, x, y) {\n\t            a = R.rad(a);\n\t            x = x || 0;\n\t            y = y || 0;\n\t            var cos = +math.cos(a).toFixed(9),\n\t                sin = +math.sin(a).toFixed(9);\n\t            this.add(cos, sin, -sin, cos, x, y);\n\t            this.add(1, 0, 0, 1, -x, -y);\n\t        };\n\t        /*\\\n\t         * Matrix.x\n\t         [ method ]\n\t         **\n\t         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t         = (number) x\n\t        \\*/\n\t        matrixproto.x = function (x, y) {\n\t            return x * this.a + y * this.c + this.e;\n\t        };\n\t        /*\\\n\t         * Matrix.y\n\t         [ method ]\n\t         **\n\t         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t         = (number) y\n\t        \\*/\n\t        matrixproto.y = function (x, y) {\n\t            return x * this.b + y * this.d + this.f;\n\t        };\n\t        matrixproto.get = function (i) {\n\t            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n\t        };\n\t        matrixproto.toString = function () {\n\t            return R.svg ?\n\t                \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" :\n\t                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n\t        };\n\t        matrixproto.toFilter = function () {\n\t            return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) +\n\t                \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) +\n\t                \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\n\t        };\n\t        matrixproto.offset = function () {\n\t            return [this.e.toFixed(4), this.f.toFixed(4)];\n\t        };\n\t        function norm(a) {\n\t            return a[0] * a[0] + a[1] * a[1];\n\t        }\n\t        function normalize(a) {\n\t            var mag = math.sqrt(norm(a));\n\t            a[0] && (a[0] /= mag);\n\t            a[1] && (a[1] /= mag);\n\t        }\n\t        /*\\\n\t         * Matrix.split\n\t         [ method ]\n\t         **\n\t         * Splits matrix into primitive transformations\n\t         = (object) in format:\n\t         o dx (number) translation by x\n\t         o dy (number) translation by y\n\t         o scalex (number) scale by x\n\t         o scaley (number) scale by y\n\t         o shear (number) shear\n\t         o rotate (number) rotation in deg\n\t         o isSimple (boolean) could it be represented via simple transformations\n\t        \\*/\n\t        matrixproto.split = function () {\n\t            var out = {};\n\t            // translation\n\t            out.dx = this.e;\n\t            out.dy = this.f;\n\n\t            // scale and shear\n\t            var row = [[this.a, this.c], [this.b, this.d]];\n\t            out.scalex = math.sqrt(norm(row[0]));\n\t            normalize(row[0]);\n\n\t            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n\t            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n\t            out.scaley = math.sqrt(norm(row[1]));\n\t            normalize(row[1]);\n\t            out.shear /= out.scaley;\n\n\t            // rotation\n\t            var sin = -row[0][1],\n\t                cos = row[1][1];\n\t            if (cos < 0) {\n\t                out.rotate = R.deg(math.acos(cos));\n\t                if (sin < 0) {\n\t                    out.rotate = 360 - out.rotate;\n\t                }\n\t            } else {\n\t                out.rotate = R.deg(math.asin(sin));\n\t            }\n\n\t            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n\t            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n\t            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n\t            return out;\n\t        };\n\t        /*\\\n\t         * Matrix.toTransformString\n\t         [ method ]\n\t         **\n\t         * Return transform string that represents given matrix\n\t         = (string) transform string\n\t        \\*/\n\t        matrixproto.toTransformString = function (shorter) {\n\t            var s = shorter || this[split]();\n\t            if (s.isSimple) {\n\t                s.scalex = +s.scalex.toFixed(4);\n\t                s.scaley = +s.scaley.toFixed(4);\n\t                s.rotate = +s.rotate.toFixed(4);\n\t                return  (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) +\n\t                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n\t                        (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\n\t            } else {\n\t                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n\t            }\n\t        };\n\t    })(Matrix.prototype);\n\n\t    var preventDefault = function () {\n\t        this.returnValue = false;\n\t    },\n\t    preventTouch = function () {\n\t        return this.originalEvent.preventDefault();\n\t    },\n\t    stopPropagation = function () {\n\t        this.cancelBubble = true;\n\t    },\n\t    stopTouch = function () {\n\t        return this.originalEvent.stopPropagation();\n\t    },\n\t    getEventPosition = function (e) {\n\t        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n\n\t        return {\n\t            x: e.clientX + scrollX,\n\t            y: e.clientY + scrollY\n\t        };\n\t    },\n\t    addEvent = (function () {\n\t        if (g.doc.addEventListener) {\n\t            return function (obj, type, fn, element) {\n\t                var f = function (e) {\n\t                    var pos = getEventPosition(e);\n\t                    return fn.call(element, e, pos.x, pos.y);\n\t                };\n\t                obj.addEventListener(type, f, false);\n\n\t                if (supportsTouch && touchMap[type]) {\n\t                    var _f = function (e) {\n\t                        var pos = getEventPosition(e),\n\t                            olde = e;\n\n\t                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n\t                            if (e.targetTouches[i].target == obj) {\n\t                                e = e.targetTouches[i];\n\t                                e.originalEvent = olde;\n\t                                e.preventDefault = preventTouch;\n\t                                e.stopPropagation = stopTouch;\n\t                                break;\n\t                            }\n\t                        }\n\n\t                        return fn.call(element, e, pos.x, pos.y);\n\t                    };\n\t                    obj.addEventListener(touchMap[type], _f, false);\n\t                }\n\n\t                return function () {\n\t                    obj.removeEventListener(type, f, false);\n\n\t                    if (supportsTouch && touchMap[type])\n\t                        obj.removeEventListener(touchMap[type], _f, false);\n\n\t                    return true;\n\t                };\n\t            };\n\t        } else if (g.doc.attachEvent) {\n\t            return function (obj, type, fn, element) {\n\t                var f = function (e) {\n\t                    e = e || g.win.event;\n\t                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n\t                        x = e.clientX + scrollX,\n\t                        y = e.clientY + scrollY;\n\t                    e.preventDefault = e.preventDefault || preventDefault;\n\t                    e.stopPropagation = e.stopPropagation || stopPropagation;\n\t                    return fn.call(element, e, x, y);\n\t                };\n\t                obj.attachEvent(\"on\" + type, f);\n\t                var detacher = function () {\n\t                    obj.detachEvent(\"on\" + type, f);\n\t                    return true;\n\t                };\n\t                return detacher;\n\t            };\n\t        }\n\t    })(),\n\t    drag = [],\n\t    dragMove = function (e) {\n\t        var x = e.clientX,\n\t            y = e.clientY,\n\t            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n\t            dragi,\n\t            j = drag.length;\n\t        while (j--) {\n\t            dragi = drag[j];\n\t            if (supportsTouch && e.touches) {\n\t                var i = e.touches.length,\n\t                    touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    if (touch.identifier == dragi.el._drag.id) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                e.preventDefault();\n\t            }\n\t            var node = dragi.el.node,\n\t                o,\n\t                next = node.nextSibling,\n\t                parent = node.parentNode,\n\t                display = node.style.display;\n\t            g.win.opera && parent.removeChild(node);\n\t            node.style.display = \"none\";\n\t            o = dragi.el.paper.getElementByPoint(x, y);\n\t            node.style.display = display;\n\t            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n\t            o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\n\t            x += scrollX;\n\t            y += scrollY;\n\t            eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n\t        }\n\t    },\n\t    dragUp = function (e) {\n\t        R.unmousemove(dragMove).unmouseup(dragUp);\n\t        var i = drag.length,\n\t            dragi;\n\t        while (i--) {\n\t            dragi = drag[i];\n\t            dragi.el._drag = {};\n\t            eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n\t        }\n\t        drag = [];\n\t    },\n\t    /*\\\n\t     * Raphael.el\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to elements. This is useful when you want to hack default functionality or\n\t     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\n\t     * you can redefine element method at any time. Expending element methods wouldnt affect set.\n\t     > Usage\n\t     | Raphael.el.red = function () {\n\t     |     this.attr({fill: \"#f00\"});\n\t     | };\n\t     | // then use it\n\t     | paper.circle(100, 100, 20).red();\n\t    \\*/\n\t    elproto = R.el = {};\n\t    /*\\\n\t     * Element.click\n\t     [ method ]\n\t     **\n\t     * Adds event handler for click for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unclick\n\t     [ method ]\n\t     **\n\t     * Removes event handler for click for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.dblclick\n\t     [ method ]\n\t     **\n\t     * Adds event handler for double click for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.undblclick\n\t     [ method ]\n\t     **\n\t     * Removes event handler for double click for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mousedown\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mousedown for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousedown\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mousedown for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mousemove\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mousemove for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousemove\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mousemove for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseout\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseout for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseout\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseout for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseover\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseover for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseover\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseover for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseup\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseup for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseup\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseup for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchstart\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchstart for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchstart\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchstart for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchmove\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchmove for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchmove\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchmove for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchend\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchend for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchend\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchend for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchcancel\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchcancel for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchcancel\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchcancel for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    for (var i = events.length; i--;) {\n\t        (function (eventName) {\n\t            R[eventName] = elproto[eventName] = function (fn, scope) {\n\t                if (R.is(fn, \"function\")) {\n\t                    this.events = this.events || [];\n\t                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});\n\t                }\n\t                return this;\n\t            };\n\t            R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\n\t                var events = this.events || [],\n\t                    l = events.length;\n\t                while (l--){\n\t                    if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\n\t                        events[l].unbind();\n\t                        events.splice(l, 1);\n\t                        !events.length && delete this.events;\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\t        })(events[i]);\n\t    }\n\n\t    /*\\\n\t     * Element.data\n\t     [ method ]\n\t     **\n\t     * Adds or retrieves given value associated with given key.\n\t     **\n\t     * See also @Element.removeData\n\t     > Parameters\n\t     - key (string) key to store data\n\t     - value (any) #optional value to store\n\t     = (object) @Element\n\t     * or, if value is not specified:\n\t     = (any) value\n\t     * or, if key and value are not specified:\n\t     = (object) Key/value pairs for all the data associated with the element.\n\t     > Usage\n\t     | for (var i = 0, i < 5, i++) {\n\t     |     paper.circle(10 + 15 * i, 10, 10)\n\t     |          .attr({fill: \"#000\"})\n\t     |          .data(\"i\", i)\n\t     |          .click(function () {\n\t     |             alert(this.data(\"i\"));\n\t     |          });\n\t     | }\n\t    \\*/\n\t    elproto.data = function (key, value) {\n\t        var data = eldata[this.id] = eldata[this.id] || {};\n\t        if (arguments.length == 0) {\n\t            return data;\n\t        }\n\t        if (arguments.length == 1) {\n\t            if (R.is(key, \"object\")) {\n\t                for (var i in key) if (key[has](i)) {\n\t                    this.data(i, key[i]);\n\t                }\n\t                return this;\n\t            }\n\t            eve(\"raphael.data.get.\" + this.id, this, data[key], key);\n\t            return data[key];\n\t        }\n\t        data[key] = value;\n\t        eve(\"raphael.data.set.\" + this.id, this, value, key);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeData\n\t     [ method ]\n\t     **\n\t     * Removes value associated with an element by given key.\n\t     * If key is not provided, removes all the data of the element.\n\t     > Parameters\n\t     - key (string) #optional key\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.removeData = function (key) {\n\t        if (key == null) {\n\t            eldata[this.id] = {};\n\t        } else {\n\t            eldata[this.id] && delete eldata[this.id][key];\n\t        }\n\t        return this;\n\t    };\n\t     /*\\\n\t     * Element.getData\n\t     [ method ]\n\t     **\n\t     * Retrieves the element data\n\t     = (object) data\n\t    \\*/\n\t    elproto.getData = function () {\n\t        return clone(eldata[this.id] || {});\n\t    };\n\t    /*\\\n\t     * Element.hover\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for hover for the element.\n\t     > Parameters\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     - icontext (object) #optional context for hover in handler\n\t     - ocontext (object) #optional context for hover out handler\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n\t        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n\t    };\n\t    /*\\\n\t     * Element.unhover\n\t     [ method ]\n\t     **\n\t     * Removes event handlers for hover for the element.\n\t     > Parameters\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.unhover = function (f_in, f_out) {\n\t        return this.unmouseover(f_in).unmouseout(f_out);\n\t    };\n\t    var draggable = [];\n\t    /*\\\n\t     * Element.drag\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for drag of the element.\n\t     > Parameters\n\t     - onmove (function) handler for moving\n\t     - onstart (function) handler for drag start\n\t     - onend (function) handler for drag end\n\t     - mcontext (object) #optional context for moving handler\n\t     - scontext (object) #optional context for drag start handler\n\t     - econtext (object) #optional context for drag end handler\n\t     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,\n\t     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\n\t     * `drag.over.<id>` will be fired as well.\n\t     *\n\t     * Start event and start handler will be called in specified context or in context of the element with following parameters:\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * Move event and move handler will be called in specified context or in context of the element with following parameters:\n\t     o dx (number) shift by x from the start point\n\t     o dy (number) shift by y from the start point\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * End event and end handler will be called in specified context or in context of the element with following parameters:\n\t     o event (object) DOM event object\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n\t        function start(e) {\n\t            (e.originalEvent || e).preventDefault();\n\t            var x = e.clientX,\n\t                y = e.clientY,\n\t                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n\t            this._drag.id = e.identifier;\n\t            if (supportsTouch && e.touches) {\n\t                var i = e.touches.length, touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    this._drag.id = touch.identifier;\n\t                    if (touch.identifier == this._drag.id) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            this._drag.x = x + scrollX;\n\t            this._drag.y = y + scrollY;\n\t            !drag.length && R.mousemove(dragMove).mouseup(dragUp);\n\t            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n\t            onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\n\t            onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\n\t            onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\n\t            eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);\n\t        }\n\t        this._drag = {};\n\t        draggable.push({el: this, start: start});\n\t        this.mousedown(start);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.onDragOver\n\t     [ method ]\n\t     **\n\t     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\n\t     > Parameters\n\t     - f (function) handler for event, first argument would be the element you are dragging over\n\t    \\*/\n\t    elproto.onDragOver = function (f) {\n\t        f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\n\t    };\n\t    /*\\\n\t     * Element.undrag\n\t     [ method ]\n\t     **\n\t     * Removes all drag event handlers from given element.\n\t    \\*/\n\t    elproto.undrag = function () {\n\t        var i = draggable.length;\n\t        while (i--) if (draggable[i].el == this) {\n\t            this.unmousedown(draggable[i].start);\n\t            draggable.splice(i, 1);\n\t            eve.unbind(\"raphael.drag.*.\" + this.id);\n\t        }\n\t        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\n\t        drag = [];\n\t    };\n\t    /*\\\n\t     * Paper.circle\n\t     [ method ]\n\t     **\n\t     * Draws a circle.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - r (number) radius\n\t     = (object) Raphal element object with type circle\n\t     **\n\t     > Usage\n\t     | var c = paper.circle(50, 50, 40);\n\t    \\*/\n\t    paperproto.circle = function (x, y, r) {\n\t        var out = R._engine.circle(this, x || 0, y || 0, r || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.rect\n\t     [ method ]\n\t     *\n\t     * Draws a rectangle.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the top left corner\n\t     - y (number) y coordinate of the top left corner\n\t     - width (number) width\n\t     - height (number) height\n\t     - r (number) #optional radius for rounded corners, default is 0\n\t     = (object) Raphal element object with type rect\n\t     **\n\t     > Usage\n\t     | // regular rectangle\n\t     | var c = paper.rect(10, 10, 50, 50);\n\t     | // rectangle with rounded corners\n\t     | var c = paper.rect(40, 40, 50, 50, 10);\n\t    \\*/\n\t    paperproto.rect = function (x, y, w, h, r) {\n\t        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.ellipse\n\t     [ method ]\n\t     **\n\t     * Draws an ellipse.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - rx (number) horizontal radius\n\t     - ry (number) vertical radius\n\t     = (object) Raphal element object with type ellipse\n\t     **\n\t     > Usage\n\t     | var c = paper.ellipse(50, 50, 40, 20);\n\t    \\*/\n\t    paperproto.ellipse = function (x, y, rx, ry) {\n\t        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.path\n\t     [ method ]\n\t     **\n\t     * Creates a path element by given path data string.\n\t     > Parameters\n\t     - pathString (string) #optional path string in SVG format.\n\t     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\n\t     | \"M10,20L30,40\"\n\t     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.\n\t     *\n\t     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\n\t     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n\t     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n\t     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n\t     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n\t     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n\t     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n\t     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n\t     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n\t     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n\t     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n\t     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.\n\t     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.\n\t     > Usage\n\t     | var c = paper.path(\"M10 10L90 90\");\n\t     | // draw a diagonal line:\n\t     | // move to 10,10, line to 90,90\n\t     * For example of path strings, check out these icons: http://raphaeljs.com/icons/\n\t    \\*/\n\t    paperproto.path = function (pathString) {\n\t        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\n\t        var out = R._engine.path(R.format[apply](R, arguments), this);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.image\n\t     [ method ]\n\t     **\n\t     * Embeds an image into the surface.\n\t     **\n\t     > Parameters\n\t     **\n\t     - src (string) URI of the source image\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - width (number) width of the image\n\t     - height (number) height of the image\n\t     = (object) Raphal element object with type image\n\t     **\n\t     > Usage\n\t     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n\t    \\*/\n\t    paperproto.image = function (src, x, y, w, h) {\n\t        var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.text\n\t     [ method ]\n\t     **\n\t     * Draws a text string. If you need line breaks, put \\n in the string.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - text (string) The text string to draw\n\t     = (object) Raphal element object with type text\n\t     **\n\t     > Usage\n\t     | var t = paper.text(50, 50, \"Raphal\\nkicks\\nbutt!\");\n\t    \\*/\n\t    paperproto.text = function (x, y, text) {\n\t        var out = R._engine.text(this, x || 0, y || 0, Str(text));\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.set\n\t     [ method ]\n\t     **\n\t     * Creates array-like object to keep and operate several elements at once.\n\t     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.\n\t     * Sets act as pseudo elements  all methods available to an element can be used on a set.\n\t     = (object) array-like object that represents set of elements\n\t     **\n\t     > Usage\n\t     | var st = paper.set();\n\t     | st.push(\n\t     |     paper.circle(10, 10, 5),\n\t     |     paper.circle(30, 10, 5)\n\t     | );\n\t     | st.attr({fill: \"red\"}); // changes the fill of both circles\n\t    \\*/\n\t    paperproto.set = function (itemsArray) {\n\t        !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\n\t        var out = new Set(itemsArray);\n\t        this.__set__ && this.__set__.push(out);\n\t        out[\"paper\"] = this;\n\t        out[\"type\"] = \"set\";\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.setStart\n\t     [ method ]\n\t     **\n\t     * Creates @Paper.set. All elements that will be created after calling this method and before calling\n\t     * @Paper.setFinish will be added to the set.\n\t     **\n\t     > Usage\n\t     | paper.setStart();\n\t     | paper.circle(10, 10, 5),\n\t     | paper.circle(30, 10, 5)\n\t     | var st = paper.setFinish();\n\t     | st.attr({fill: \"red\"}); // changes the fill of both circles\n\t    \\*/\n\t    paperproto.setStart = function (set) {\n\t        this.__set__ = set || this.set();\n\t    };\n\t    /*\\\n\t     * Paper.setFinish\n\t     [ method ]\n\t     **\n\t     * See @Paper.setStart. This method finishes catching and returns resulting set.\n\t     **\n\t     = (object) set\n\t    \\*/\n\t    paperproto.setFinish = function (set) {\n\t        var out = this.__set__;\n\t        delete this.__set__;\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.getSize\n\t     [ method ]\n\t     **\n\t     * Obtains current paper actual size.\n\t     **\n\t     = (object)\n\t     \\*/\n\t    paperproto.getSize = function () {\n\t        var container = this.canvas.parentNode;\n\t        return {\n\t            width: container.offsetWidth,\n\t            height: container.offsetHeight\n\t                };\n\t        };\n\t    /*\\\n\t     * Paper.setSize\n\t     [ method ]\n\t     **\n\t     * If you need to change dimensions of the canvas call this method\n\t     **\n\t     > Parameters\n\t     **\n\t     - width (number) new width of the canvas\n\t     - height (number) new height of the canvas\n\t    \\*/\n\t    paperproto.setSize = function (width, height) {\n\t        return R._engine.setSize.call(this, width, height);\n\t    };\n\t    /*\\\n\t     * Paper.setViewBox\n\t     [ method ]\n\t     **\n\t     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\n\t     * specifying new boundaries.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) new x position, default is `0`\n\t     - y (number) new y position, default is `0`\n\t     - w (number) new width of the canvas\n\t     - h (number) new height of the canvas\n\t     - fit (boolean) `true` if you want graphics to fit into new boundary box\n\t    \\*/\n\t    paperproto.setViewBox = function (x, y, w, h, fit) {\n\t        return R._engine.setViewBox.call(this, x, y, w, h, fit);\n\t    };\n\t    /*\\\n\t     * Paper.top\n\t     [ property ]\n\t     **\n\t     * Points to the topmost element on the paper\n\t    \\*/\n\t    /*\\\n\t     * Paper.bottom\n\t     [ property ]\n\t     **\n\t     * Points to the bottom element on the paper\n\t    \\*/\n\t    paperproto.top = paperproto.bottom = null;\n\t    /*\\\n\t     * Paper.raphael\n\t     [ property ]\n\t     **\n\t     * Points to the @Raphael object/function\n\t    \\*/\n\t    paperproto.raphael = R;\n\t    var getOffset = function (elem) {\n\t        var box = elem.getBoundingClientRect(),\n\t            doc = elem.ownerDocument,\n\t            body = doc.body,\n\t            docElem = doc.documentElement,\n\t            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n\t            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t        return {\n\t            y: top,\n\t            x: left\n\t        };\n\t    };\n\t    /*\\\n\t     * Paper.getElementByPoint\n\t     [ method ]\n\t     **\n\t     * Returns you topmost element under given point.\n\t     **\n\t     = (object) Raphal element object\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate from the top left corner of the window\n\t     - y (number) y coordinate from the top left corner of the window\n\t     > Usage\n\t     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\t    \\*/\n\t    paperproto.getElementByPoint = function (x, y) {\n\t        var paper = this,\n\t            svg = paper.canvas,\n\t            target = g.doc.elementFromPoint(x, y);\n\t        if (g.win.opera && target.tagName == \"svg\") {\n\t            var so = getOffset(svg),\n\t                sr = svg.createSVGRect();\n\t            sr.x = x - so.x;\n\t            sr.y = y - so.y;\n\t            sr.width = sr.height = 1;\n\t            var hits = svg.getIntersectionList(sr, null);\n\t            if (hits.length) {\n\t                target = hits[hits.length - 1];\n\t            }\n\t        }\n\t        if (!target) {\n\t            return null;\n\t        }\n\t        while (target.parentNode && target != svg.parentNode && !target.raphael) {\n\t            target = target.parentNode;\n\t        }\n\t        target == paper.canvas.parentNode && (target = svg);\n\t        target = target && target.raphael ? paper.getById(target.raphaelid) : null;\n\t        return target;\n\t    };\n\n\t    /*\\\n\t     * Paper.getElementsByBBox\n\t     [ method ]\n\t     **\n\t     * Returns set of elements that have an intersecting bounding box\n\t     **\n\t     > Parameters\n\t     **\n\t     - bbox (object) bbox to check with\n\t     = (object) @Set\n\t     \\*/\n\t    paperproto.getElementsByBBox = function (bbox) {\n\t        var set = this.set();\n\t        this.forEach(function (el) {\n\t            if (R.isBBoxIntersect(el.getBBox(), bbox)) {\n\t                set.push(el);\n\t            }\n\t        });\n\t        return set;\n\t    };\n\n\t    /*\\\n\t     * Paper.getById\n\t     [ method ]\n\t     **\n\t     * Returns you element by its internal ID.\n\t     **\n\t     > Parameters\n\t     **\n\t     - id (number) id\n\t     = (object) Raphal element object\n\t    \\*/\n\t    paperproto.getById = function (id) {\n\t        var bot = this.bottom;\n\t        while (bot) {\n\t            if (bot.id == id) {\n\t                return bot;\n\t            }\n\t            bot = bot.next;\n\t        }\n\t        return null;\n\t    };\n\t    /*\\\n\t     * Paper.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element on the paper\n\t     *\n\t     * If callback function returns `false` it will stop loop running.\n\t     **\n\t     > Parameters\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Paper object\n\t     > Usage\n\t     | paper.forEach(function (el) {\n\t     |     el.attr({ stroke: \"blue\" });\n\t     | });\n\t    \\*/\n\t    paperproto.forEach = function (callback, thisArg) {\n\t        var bot = this.bottom;\n\t        while (bot) {\n\t            if (callback.call(thisArg, bot) === false) {\n\t                return this;\n\t            }\n\t            bot = bot.next;\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Paper.getElementsByPoint\n\t     [ method ]\n\t     **\n\t     * Returns set of elements that have common point inside\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (object) @Set\n\t    \\*/\n\t    paperproto.getElementsByPoint = function (x, y) {\n\t        var set = this.set();\n\t        this.forEach(function (el) {\n\t            if (el.isPointInside(x, y)) {\n\t                set.push(el);\n\t            }\n\t        });\n\t        return set;\n\t    };\n\t    function x_y() {\n\t        return this.x + S + this.y;\n\t    }\n\t    function x_y_w_h() {\n\t        return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n\t    }\n\t    /*\\\n\t     * Element.isPointInside\n\t     [ method ]\n\t     **\n\t     * Determine if given point is inside this elements shape\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (boolean) `true` if point inside the shape\n\t    \\*/\n\t    elproto.isPointInside = function (x, y) {\n\t        var rp = this.realPath = getPath[this.type](this);\n\t        if (this.attr('transform') && this.attr('transform').length) {\n\t            rp = R.transformPath(rp, this.attr('transform'));\n\t        }\n\t        return R.isPointInsidePath(rp, x, y);\n\t    };\n\t    /*\\\n\t     * Element.getBBox\n\t     [ method ]\n\t     **\n\t     * Return bounding box for a given element\n\t     **\n\t     > Parameters\n\t     **\n\t     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\n\t     = (object) Bounding box object:\n\t     o {\n\t     o     x: (number) top left corner x\n\t     o     y: (number) top left corner y\n\t     o     x2: (number) bottom right corner x\n\t     o     y2: (number) bottom right corner y\n\t     o     width: (number) width\n\t     o     height: (number) height\n\t     o }\n\t    \\*/\n\t    elproto.getBBox = function (isWithoutTransform) {\n\t        if (this.removed) {\n\t            return {};\n\t        }\n\t        var _ = this._;\n\t        if (isWithoutTransform) {\n\t            if (_.dirty || !_.bboxwt) {\n\t                this.realPath = getPath[this.type](this);\n\t                _.bboxwt = pathDimensions(this.realPath);\n\t                _.bboxwt.toString = x_y_w_h;\n\t                _.dirty = 0;\n\t            }\n\t            return _.bboxwt;\n\t        }\n\t        if (_.dirty || _.dirtyT || !_.bbox) {\n\t            if (_.dirty || !this.realPath) {\n\t                _.bboxwt = 0;\n\t                this.realPath = getPath[this.type](this);\n\t            }\n\t            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\n\t            _.bbox.toString = x_y_w_h;\n\t            _.dirty = _.dirtyT = 0;\n\t        }\n\t        return _.bbox;\n\t    };\n\t    /*\\\n\t     * Element.clone\n\t     [ method ]\n\t     **\n\t     = (object) clone of a given element\n\t     **\n\t    \\*/\n\t    elproto.clone = function () {\n\t        if (this.removed) {\n\t            return null;\n\t        }\n\t        var out = this.paper[this.type]().attr(this.attr());\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Element.glow\n\t     [ method ]\n\t     **\n\t     * Return set of elements that create glow-like effect around given element. See @Paper.set.\n\t     *\n\t     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.\n\t     **\n\t     > Parameters\n\t     **\n\t     - glow (object) #optional parameters object with all properties optional:\n\t     o {\n\t     o     width (number) size of the glow, default is `10`\n\t     o     fill (boolean) will it be filled, default is `false`\n\t     o     opacity (number) opacity, default is `0.5`\n\t     o     offsetx (number) horizontal offset, default is `0`\n\t     o     offsety (number) vertical offset, default is `0`\n\t     o     color (string) glow colour, default is `black`\n\t     o }\n\t     = (object) @Paper.set of elements that represents glow\n\t    \\*/\n\t    elproto.glow = function (glow) {\n\t        if (this.type == \"text\") {\n\t            return null;\n\t        }\n\t        glow = glow || {};\n\t        var s = {\n\t            width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\n\t            fill: glow.fill || false,\n\t            opacity: glow.opacity == null ? .5 : glow.opacity,\n\t            offsetx: glow.offsetx || 0,\n\t            offsety: glow.offsety || 0,\n\t            color: glow.color || \"#000\"\n\t        },\n\t            c = s.width / 2,\n\t            r = this.paper,\n\t            out = r.set(),\n\t            path = this.realPath || getPath[this.type](this);\n\t        path = this.matrix ? mapPath(path, this.matrix) : path;\n\t        for (var i = 1; i < c + 1; i++) {\n\t            out.push(r.path(path).attr({\n\t                stroke: s.color,\n\t                fill: s.fill ? s.color : \"none\",\n\t                \"stroke-linejoin\": \"round\",\n\t                \"stroke-linecap\": \"round\",\n\t                \"stroke-width\": +(s.width / c * i).toFixed(3),\n\t                opacity: +(s.opacity / c).toFixed(3)\n\t            }));\n\t        }\n\t        return out.insertBefore(this).translate(s.offsetx, s.offsety);\n\t    };\n\t    var curveslengths = {},\n\t    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n\t        if (length == null) {\n\t            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\t        } else {\n\t            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n\t        }\n\t    },\n\t    getLengthFactory = function (istotal, subpath) {\n\t        return function (path, length, onlystart) {\n\t            path = path2curve(path);\n\t            var x, y, p, l, sp = \"\", subpaths = {}, point,\n\t                len = 0;\n\t            for (var i = 0, ii = path.length; i < ii; i++) {\n\t                p = path[i];\n\t                if (p[0] == \"M\") {\n\t                    x = +p[1];\n\t                    y = +p[2];\n\t                } else {\n\t                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                    if (len + l > length) {\n\t                        if (subpath && !subpaths.start) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\n\t                            if (onlystart) {return sp;}\n\t                            subpaths.start = sp;\n\t                            sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\n\t                            len += l;\n\t                            x = +p[5];\n\t                            y = +p[6];\n\t                            continue;\n\t                        }\n\t                        if (!istotal && !subpath) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            return {x: point.x, y: point.y, alpha: point.alpha};\n\t                        }\n\t                    }\n\t                    len += l;\n\t                    x = +p[5];\n\t                    y = +p[6];\n\t                }\n\t                sp += p.shift() + p;\n\t            }\n\t            subpaths.end = sp;\n\t            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n\t            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});\n\t            return point;\n\t        };\n\t    };\n\t    var getTotalLength = getLengthFactory(1),\n\t        getPointAtLength = getLengthFactory(),\n\t        getSubpathsAtLength = getLengthFactory(0, 1);\n\t    /*\\\n\t     * Raphael.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns length of the given path in pixels.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string.\n\t     **\n\t     = (number) length.\n\t    \\*/\n\t    R.getTotalLength = getTotalLength;\n\t    /*\\\n\t     * Raphael.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Return coordinates of the point located at the given length on the given path.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string\n\t     - length (number)\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate\n\t     o     y: (number) y coordinate\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    R.getPointAtLength = getPointAtLength;\n\t    /*\\\n\t     * Raphael.getSubpath\n\t     [ method ]\n\t     **\n\t     * Return subpath of a given path from given length to given length.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string\n\t     - from (number) position of the start of the segment\n\t     - to (number) position of the end of the segment\n\t     **\n\t     = (string) pathstring for the segment\n\t    \\*/\n\t    R.getSubpath = function (path, from, to) {\n\t        if (this.getTotalLength(path) - to < 1e-6) {\n\t            return getSubpathsAtLength(path, from).end;\n\t        }\n\t        var a = getSubpathsAtLength(path, to, 1);\n\t        return from ? getSubpathsAtLength(a, from).end : a;\n\t    };\n\t    /*\\\n\t     * Element.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns length of the path in pixels. Only works for element of path type.\n\t     = (number) length.\n\t    \\*/\n\t    elproto.getTotalLength = function () {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        if (this.node.getTotalLength) {\n\t            return this.node.getTotalLength();\n\t        }\n\n\t        return getTotalLength(path);\n\t    };\n\t    /*\\\n\t     * Element.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.\n\t     **\n\t     > Parameters\n\t     **\n\t     - length (number)\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate\n\t     o     y: (number) y coordinate\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    elproto.getPointAtLength = function (length) {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        return getPointAtLength(path, length);\n\t    };\n\t    /*\\\n\t     * Element.getPath\n\t     [ method ]\n\t     **\n\t     * Returns path of the element. Only works for elements of path type and simple elements like circle.\n\t     = (object) path\n\t     **\n\t    \\*/\n\t    elproto.getPath = function () {\n\t        var path,\n\t            getPath = R._getPath[this.type];\n\n\t        if (this.type == \"text\" || this.type == \"set\") {\n\t            return;\n\t        }\n\n\t        if (getPath) {\n\t            path = getPath(this);\n\t        }\n\n\t        return path;\n\t    };\n\t    /*\\\n\t     * Element.getSubpath\n\t     [ method ]\n\t     **\n\t     * Return subpath of a given element from given length to given length. Only works for element of path type.\n\t     **\n\t     > Parameters\n\t     **\n\t     - from (number) position of the start of the segment\n\t     - to (number) position of the end of the segment\n\t     **\n\t     = (string) pathstring for the segment\n\t    \\*/\n\t    elproto.getSubpath = function (from, to) {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        return R.getSubpath(path, from, to);\n\t    };\n\t    /*\\\n\t     * Raphael.easing_formulas\n\t     [ property ]\n\t     **\n\t     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\n\t     # <ul>\n\t     #     <li>linear</li>\n\t     #     <li>&lt; or easeIn or ease-in</li>\n\t     #     <li>> or easeOut or ease-out</li>\n\t     #     <li>&lt;> or easeInOut or ease-in-out</li>\n\t     #     <li>backIn or back-in</li>\n\t     #     <li>backOut or back-out</li>\n\t     #     <li>elastic</li>\n\t     #     <li>bounce</li>\n\t     # </ul>\n\t     # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\n\t    \\*/\n\t    var ef = R.easing_formulas = {\n\t        linear: function (n) {\n\t            return n;\n\t        },\n\t        \"<\": function (n) {\n\t            return pow(n, 1.7);\n\t        },\n\t        \">\": function (n) {\n\t            return pow(n, .48);\n\t        },\n\t        \"<>\": function (n) {\n\t            var q = .48 - n / 1.04,\n\t                Q = math.sqrt(.1734 + q * q),\n\t                x = Q - q,\n\t                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n\t                y = -Q - q,\n\t                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n\t                t = X + Y + .5;\n\t            return (1 - t) * 3 * t * t + t * t * t;\n\t        },\n\t        backIn: function (n) {\n\t            var s = 1.70158;\n\t            return n * n * ((s + 1) * n - s);\n\t        },\n\t        backOut: function (n) {\n\t            n = n - 1;\n\t            var s = 1.70158;\n\t            return n * n * ((s + 1) * n + s) + 1;\n\t        },\n\t        elastic: function (n) {\n\t            if (n == !!n) {\n\t                return n;\n\t            }\n\t            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\n\t        },\n\t        bounce: function (n) {\n\t            var s = 7.5625,\n\t                p = 2.75,\n\t                l;\n\t            if (n < (1 / p)) {\n\t                l = s * n * n;\n\t            } else {\n\t                if (n < (2 / p)) {\n\t                    n -= (1.5 / p);\n\t                    l = s * n * n + .75;\n\t                } else {\n\t                    if (n < (2.5 / p)) {\n\t                        n -= (2.25 / p);\n\t                        l = s * n * n + .9375;\n\t                    } else {\n\t                        n -= (2.625 / p);\n\t                        l = s * n * n + .984375;\n\t                    }\n\t                }\n\t            }\n\t            return l;\n\t        }\n\t    };\n\t    ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\n\t    ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\n\t    ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\n\t    ef[\"back-in\"] = ef.backIn;\n\t    ef[\"back-out\"] = ef.backOut;\n\n\t    var animationElements = [],\n\t        requestAnimFrame = window.requestAnimationFrame       ||\n\t                           window.webkitRequestAnimationFrame ||\n\t                           window.mozRequestAnimationFrame    ||\n\t                           window.oRequestAnimationFrame      ||\n\t                           window.msRequestAnimationFrame     ||\n\t                           function (callback) {\n\t                               setTimeout(callback, 16);\n\t                           },\n\t        animation = function () {\n\t            var Now = +new Date,\n\t                l = 0;\n\t            for (; l < animationElements.length; l++) {\n\t                var e = animationElements[l];\n\t                if (e.el.removed || e.paused) {\n\t                    continue;\n\t                }\n\t                var time = Now - e.start,\n\t                    ms = e.ms,\n\t                    easing = e.easing,\n\t                    from = e.from,\n\t                    diff = e.diff,\n\t                    to = e.to,\n\t                    t = e.t,\n\t                    that = e.el,\n\t                    set = {},\n\t                    now,\n\t                    init = {},\n\t                    key;\n\t                if (e.initstatus) {\n\t                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\n\t                    e.status = e.initstatus;\n\t                    delete e.initstatus;\n\t                    e.stop && animationElements.splice(l--, 1);\n\t                } else {\n\t                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\n\t                }\n\t                if (time < 0) {\n\t                    continue;\n\t                }\n\t                if (time < ms) {\n\t                    var pos = easing(time / ms);\n\t                    for (var attr in from) if (from[has](attr)) {\n\t                        switch (availableAnimAttrs[attr]) {\n\t                            case nu:\n\t                                now = +from[attr] + pos * ms * diff[attr];\n\t                                break;\n\t                            case \"colour\":\n\t                                now = \"rgb(\" + [\n\t                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),\n\t                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),\n\t                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))\n\t                                ].join(\",\") + \")\";\n\t                                break;\n\t                            case \"path\":\n\t                                now = [];\n\t                                for (var i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                    now[i] = [from[attr][i][0]];\n\t                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\n\t                                    }\n\t                                    now[i] = now[i].join(S);\n\t                                }\n\t                                now = now.join(S);\n\t                                break;\n\t                            case \"transform\":\n\t                                if (diff[attr].real) {\n\t                                    now = [];\n\t                                    for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                        now[i] = [from[attr][i][0]];\n\t                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    var get = function (i) {\n\t                                        return +from[attr][i] + pos * ms * diff[attr][i];\n\t                                    };\n\t                                    // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\n\t                                    now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\n\t                                }\n\t                                break;\n\t                            case \"csv\":\n\t                                if (attr == \"clip-rect\") {\n\t                                    now = [];\n\t                                    i = 4;\n\t                                    while (i--) {\n\t                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];\n\t                                    }\n\t                                }\n\t                                break;\n\t                            default:\n\t                                var from2 = [][concat](from[attr]);\n\t                                now = [];\n\t                                i = that.paper.customAttributes[attr].length;\n\t                                while (i--) {\n\t                                    now[i] = +from2[i] + pos * ms * diff[attr][i];\n\t                                }\n\t                                break;\n\t                        }\n\t                        set[attr] = now;\n\t                    }\n\t                    that.attr(set);\n\t                    (function (id, that, anim) {\n\t                        setTimeout(function () {\n\t                            eve(\"raphael.anim.frame.\" + id, that, anim);\n\t                        });\n\t                    })(that.id, that, e.anim);\n\t                } else {\n\t                    (function(f, el, a) {\n\t                        setTimeout(function() {\n\t                            eve(\"raphael.anim.frame.\" + el.id, el, a);\n\t                            eve(\"raphael.anim.finish.\" + el.id, el, a);\n\t                            R.is(f, \"function\") && f.call(el);\n\t                        });\n\t                    })(e.callback, that, e.anim);\n\t                    that.attr(to);\n\t                    animationElements.splice(l--, 1);\n\t                    if (e.repeat > 1 && !e.next) {\n\t                        for (key in to) if (to[has](key)) {\n\t                            init[key] = e.totalOrigin[key];\n\t                        }\n\t                        e.el.attr(init);\n\t                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\n\t                    }\n\t                    if (e.next && !e.stop) {\n\t                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\n\t                    }\n\t                }\n\t            }\n\t            animationElements.length && requestAnimFrame(animation);\n\t        },\n\t        upto255 = function (color) {\n\t            return color > 255 ? 255 : color < 0 ? 0 : color;\n\t        };\n\t    /*\\\n\t     * Element.animateWith\n\t     [ method ]\n\t     **\n\t     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - el (object) element to sync with\n\t     - anim (object) animation to sync with\n\t     - params (object) #optional final attributes for the element, see also @Element.attr\n\t     - ms (number) #optional number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     * or\n\t     - element (object) element to sync with\n\t     - anim (object) animation to sync with\n\t     - animation (object) #optional animation object, see @Raphael.animation\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.animateWith = function (el, anim, params, ms, easing, callback) {\n\t        var element = this;\n\t        if (element.removed) {\n\t            callback && callback.call(element);\n\t            return element;\n\t        }\n\t        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\n\t            x, y;\n\t        runAnimation(a, element, a.percents[0], null, element.attr());\n\t        for (var i = 0, ii = animationElements.length; i < ii; i++) {\n\t            if (animationElements[i].anim == anim && animationElements[i].el == el) {\n\t                animationElements[ii - 1].start = animationElements[i].start;\n\t                break;\n\t            }\n\t        }\n\t        return element;\n\t        //\n\t        //\n\t        // var a = params ? R.animation(params, ms, easing, callback) : anim,\n\t        //     status = element.status(anim);\n\t        // return this.animate(a).status(a, status * anim.ms / a.ms);\n\t    };\n\t    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\n\t        var cx = 3 * p1x,\n\t            bx = 3 * (p2x - p1x) - cx,\n\t            ax = 1 - cx - bx,\n\t            cy = 3 * p1y,\n\t            by = 3 * (p2y - p1y) - cy,\n\t            ay = 1 - cy - by;\n\t        function sampleCurveX(t) {\n\t            return ((ax * t + bx) * t + cx) * t;\n\t        }\n\t        function solve(x, epsilon) {\n\t            var t = solveCurveX(x, epsilon);\n\t            return ((ay * t + by) * t + cy) * t;\n\t        }\n\t        function solveCurveX(x, epsilon) {\n\t            var t0, t1, t2, x2, d2, i;\n\t            for(t2 = x, i = 0; i < 8; i++) {\n\t                x2 = sampleCurveX(t2) - x;\n\t                if (abs(x2) < epsilon) {\n\t                    return t2;\n\t                }\n\t                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\n\t                if (abs(d2) < 1e-6) {\n\t                    break;\n\t                }\n\t                t2 = t2 - x2 / d2;\n\t            }\n\t            t0 = 0;\n\t            t1 = 1;\n\t            t2 = x;\n\t            if (t2 < t0) {\n\t                return t0;\n\t            }\n\t            if (t2 > t1) {\n\t                return t1;\n\t            }\n\t            while (t0 < t1) {\n\t                x2 = sampleCurveX(t2);\n\t                if (abs(x2 - x) < epsilon) {\n\t                    return t2;\n\t                }\n\t                if (x > x2) {\n\t                    t0 = t2;\n\t                } else {\n\t                    t1 = t2;\n\t                }\n\t                t2 = (t1 - t0) / 2 + t0;\n\t            }\n\t            return t2;\n\t        }\n\t        return solve(t, 1 / (200 * duration));\n\t    }\n\t    elproto.onAnimation = function (f) {\n\t        f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\n\t        return this;\n\t    };\n\t    function Animation(anim, ms) {\n\t        var percents = [],\n\t            newAnim = {};\n\t        this.ms = ms;\n\t        this.times = 1;\n\t        if (anim) {\n\t            for (var attr in anim) if (anim[has](attr)) {\n\t                newAnim[toFloat(attr)] = anim[attr];\n\t                percents.push(toFloat(attr));\n\t            }\n\t            percents.sort(sortByNumber);\n\t        }\n\t        this.anim = newAnim;\n\t        this.top = percents[percents.length - 1];\n\t        this.percents = percents;\n\t    }\n\t    /*\\\n\t     * Animation.delay\n\t     [ method ]\n\t     **\n\t     * Creates a copy of existing animation object with given delay.\n\t     **\n\t     > Parameters\n\t     **\n\t     - delay (number) number of ms to pass between animation start and actual animation\n\t     **\n\t     = (object) new altered Animation object\n\t     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\n\t     | circle1.animate(anim); // run the given animation immediately\n\t     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\n\t    \\*/\n\t    Animation.prototype.delay = function (delay) {\n\t        var a = new Animation(this.anim, this.ms);\n\t        a.times = this.times;\n\t        a.del = +delay || 0;\n\t        return a;\n\t    };\n\t    /*\\\n\t     * Animation.repeat\n\t     [ method ]\n\t     **\n\t     * Creates a copy of existing animation object with given repetition.\n\t     **\n\t     > Parameters\n\t     **\n\t     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\n\t     **\n\t     = (object) new altered Animation object\n\t    \\*/\n\t    Animation.prototype.repeat = function (times) {\n\t        var a = new Animation(this.anim, this.ms);\n\t        a.del = this.del;\n\t        a.times = math.floor(mmax(times, 0)) || 1;\n\t        return a;\n\t    };\n\t    function runAnimation(anim, element, percent, status, totalOrigin, times) {\n\t        percent = toFloat(percent);\n\t        var params,\n\t            isInAnim,\n\t            isInAnimSet,\n\t            percents = [],\n\t            next,\n\t            prev,\n\t            timestamp,\n\t            ms = anim.ms,\n\t            from = {},\n\t            to = {},\n\t            diff = {};\n\t        if (status) {\n\t            for (i = 0, ii = animationElements.length; i < ii; i++) {\n\t                var e = animationElements[i];\n\t                if (e.el.id == element.id && e.anim == anim) {\n\t                    if (e.percent != percent) {\n\t                        animationElements.splice(i, 1);\n\t                        isInAnimSet = 1;\n\t                    } else {\n\t                        isInAnim = e;\n\t                    }\n\t                    element.attr(e.totalOrigin);\n\t                    break;\n\t                }\n\t            }\n\t        } else {\n\t            status = +to; // NaN\n\t        }\n\t        for (var i = 0, ii = anim.percents.length; i < ii; i++) {\n\t            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\n\t                percent = anim.percents[i];\n\t                prev = anim.percents[i - 1] || 0;\n\t                ms = ms / anim.top * (percent - prev);\n\t                next = anim.percents[i + 1];\n\t                params = anim.anim[percent];\n\t                break;\n\t            } else if (status) {\n\t                element.attr(anim.anim[anim.percents[i]]);\n\t            }\n\t        }\n\t        if (!params) {\n\t            return;\n\t        }\n\t        if (!isInAnim) {\n\t            for (var attr in params) if (params[has](attr)) {\n\t                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\n\t                    from[attr] = element.attr(attr);\n\t                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);\n\t                    to[attr] = params[attr];\n\t                    switch (availableAnimAttrs[attr]) {\n\t                        case nu:\n\t                            diff[attr] = (to[attr] - from[attr]) / ms;\n\t                            break;\n\t                        case \"colour\":\n\t                            from[attr] = R.getRGB(from[attr]);\n\t                            var toColour = R.getRGB(to[attr]);\n\t                            diff[attr] = {\n\t                                r: (toColour.r - from[attr].r) / ms,\n\t                                g: (toColour.g - from[attr].g) / ms,\n\t                                b: (toColour.b - from[attr].b) / ms\n\t                            };\n\t                            break;\n\t                        case \"path\":\n\t                            var pathes = path2curve(from[attr], to[attr]),\n\t                                toPath = pathes[1];\n\t                            from[attr] = pathes[0];\n\t                            diff[attr] = [];\n\t                            for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                diff[attr][i] = [0];\n\t                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\n\t                                }\n\t                            }\n\t                            break;\n\t                        case \"transform\":\n\t                            var _ = element._,\n\t                                eq = equaliseTransform(_[attr], to[attr]);\n\t                            if (eq) {\n\t                                from[attr] = eq.from;\n\t                                to[attr] = eq.to;\n\t                                diff[attr] = [];\n\t                                diff[attr].real = true;\n\t                                for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                    diff[attr][i] = [from[attr][i][0]];\n\t                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\n\t                                    }\n\t                                }\n\t                            } else {\n\t                                var m = (element.matrix || new Matrix),\n\t                                    to2 = {\n\t                                        _: {transform: _.transform},\n\t                                        getBBox: function () {\n\t                                            return element.getBBox(1);\n\t                                        }\n\t                                    };\n\t                                from[attr] = [\n\t                                    m.a,\n\t                                    m.b,\n\t                                    m.c,\n\t                                    m.d,\n\t                                    m.e,\n\t                                    m.f\n\t                                ];\n\t                                extractTransform(to2, to[attr]);\n\t                                to[attr] = to2._.transform;\n\t                                diff[attr] = [\n\t                                    (to2.matrix.a - m.a) / ms,\n\t                                    (to2.matrix.b - m.b) / ms,\n\t                                    (to2.matrix.c - m.c) / ms,\n\t                                    (to2.matrix.d - m.d) / ms,\n\t                                    (to2.matrix.e - m.e) / ms,\n\t                                    (to2.matrix.f - m.f) / ms\n\t                                ];\n\t                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\n\t                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\n\t                                // extractTransform(to2, to[attr]);\n\t                                // diff[attr] = [\n\t                                //     (to2._.sx - _.sx) / ms,\n\t                                //     (to2._.sy - _.sy) / ms,\n\t                                //     (to2._.deg - _.deg) / ms,\n\t                                //     (to2._.dx - _.dx) / ms,\n\t                                //     (to2._.dy - _.dy) / ms\n\t                                // ];\n\t                            }\n\t                            break;\n\t                        case \"csv\":\n\t                            var values = Str(params[attr])[split](separator),\n\t                                from2 = Str(from[attr])[split](separator);\n\t                            if (attr == \"clip-rect\") {\n\t                                from[attr] = from2;\n\t                                diff[attr] = [];\n\t                                i = from2.length;\n\t                                while (i--) {\n\t                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;\n\t                                }\n\t                            }\n\t                            to[attr] = values;\n\t                            break;\n\t                        default:\n\t                            values = [][concat](params[attr]);\n\t                            from2 = [][concat](from[attr]);\n\t                            diff[attr] = [];\n\t                            i = element.paper.customAttributes[attr].length;\n\t                            while (i--) {\n\t                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\n\t                            }\n\t                            break;\n\t                    }\n\t                }\n\t            }\n\t            var easing = params.easing,\n\t                easyeasy = R.easing_formulas[easing];\n\t            if (!easyeasy) {\n\t                easyeasy = Str(easing).match(bezierrg);\n\t                if (easyeasy && easyeasy.length == 5) {\n\t                    var curve = easyeasy;\n\t                    easyeasy = function (t) {\n\t                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\n\t                    };\n\t                } else {\n\t                    easyeasy = pipe;\n\t                }\n\t            }\n\t            timestamp = params.start || anim.start || +new Date;\n\t            e = {\n\t                anim: anim,\n\t                percent: percent,\n\t                timestamp: timestamp,\n\t                start: timestamp + (anim.del || 0),\n\t                status: 0,\n\t                initstatus: status || 0,\n\t                stop: false,\n\t                ms: ms,\n\t                easing: easyeasy,\n\t                from: from,\n\t                diff: diff,\n\t                to: to,\n\t                el: element,\n\t                callback: params.callback,\n\t                prev: prev,\n\t                next: next,\n\t                repeat: times || anim.times,\n\t                origin: element.attr(),\n\t                totalOrigin: totalOrigin\n\t            };\n\t            animationElements.push(e);\n\t            if (status && !isInAnim && !isInAnimSet) {\n\t                e.stop = true;\n\t                e.start = new Date - ms * status;\n\t                if (animationElements.length == 1) {\n\t                    return animation();\n\t                }\n\t            }\n\t            if (isInAnimSet) {\n\t                e.start = new Date - e.ms * status;\n\t            }\n\t            animationElements.length == 1 && requestAnimFrame(animation);\n\t        } else {\n\t            isInAnim.initstatus = status;\n\t            isInAnim.start = new Date - isInAnim.ms * status;\n\t        }\n\t        eve(\"raphael.anim.start.\" + element.id, element, anim);\n\t    }\n\t    /*\\\n\t     * Raphael.animation\n\t     [ method ]\n\t     **\n\t     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\n\t     * See also @Animation.delay and @Animation.repeat methods.\n\t     **\n\t     > Parameters\n\t     **\n\t     - params (object) final attributes for the element, see also @Element.attr\n\t     - ms (number) number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     **\n\t     = (object) @Animation\n\t    \\*/\n\t    R.animation = function (params, ms, easing, callback) {\n\t        if (params instanceof Animation) {\n\t            return params;\n\t        }\n\t        if (R.is(easing, \"function\") || !easing) {\n\t            callback = callback || easing || null;\n\t            easing = null;\n\t        }\n\t        params = Object(params);\n\t        ms = +ms || 0;\n\t        var p = {},\n\t            json,\n\t            attr;\n\t        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\n\t            json = true;\n\t            p[attr] = params[attr];\n\t        }\n\t        if (!json) {\n\t            // if percent-like syntax is used and end-of-all animation callback used\n\t            if(callback){\n\t                // find the last one\n\t                var lastKey = 0;\n\t                for(var i in params){\n\t                    var percent = toInt(i);\n\t                    if(params[has](i) && percent > lastKey){\n\t                        lastKey = percent;\n\t                    }\n\t                }\n\t                lastKey += '%';\n\t                // if already defined callback in the last keyframe, skip\n\t                !params[lastKey].callback && (params[lastKey].callback = callback);\n\t            }\n\t          return new Animation(params, ms);\n\t        } else {\n\t            easing && (p.easing = easing);\n\t            callback && (p.callback = callback);\n\t            return new Animation({100: p}, ms);\n\t        }\n\t    };\n\t    /*\\\n\t     * Element.animate\n\t     [ method ]\n\t     **\n\t     * Creates and starts animation for given element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - params (object) final attributes for the element, see also @Element.attr\n\t     - ms (number) number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     * or\n\t     - animation (object) animation object, see @Raphael.animation\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.animate = function (params, ms, easing, callback) {\n\t        var element = this;\n\t        if (element.removed) {\n\t            callback && callback.call(element);\n\t            return element;\n\t        }\n\t        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\n\t        runAnimation(anim, element, anim.percents[0], null, element.attr());\n\t        return element;\n\t    };\n\t    /*\\\n\t     * Element.setTime\n\t     [ method ]\n\t     **\n\t     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) animation object\n\t     - value (number) number of milliseconds from the beginning of the animation\n\t     **\n\t     = (object) original element if `value` is specified\n\t     * Note, that during animation following events are triggered:\n\t     *\n\t     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\n\t    \\*/\n\t    elproto.setTime = function (anim, value) {\n\t        if (anim && value != null) {\n\t            this.status(anim, mmin(value, anim.ms) / anim.ms);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.status\n\t     [ method ]\n\t     **\n\t     * Gets or sets the status of animation of the element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\n\t     **\n\t     = (number) status\n\t     * or\n\t     = (array) status if `anim` is not specified. Array of objects in format:\n\t     o {\n\t     o     anim: (object) animation object\n\t     o     status: (number) status\n\t     o }\n\t     * or\n\t     = (object) original element if `value` is specified\n\t    \\*/\n\t    elproto.status = function (anim, value) {\n\t        var out = [],\n\t            i = 0,\n\t            len,\n\t            e;\n\t        if (value != null) {\n\t            runAnimation(anim, this, -1, mmin(value, 1));\n\t            return this;\n\t        } else {\n\t            len = animationElements.length;\n\t            for (; i < len; i++) {\n\t                e = animationElements[i];\n\t                if (e.el.id == this.id && (!anim || e.anim == anim)) {\n\t                    if (anim) {\n\t                        return e.status;\n\t                    }\n\t                    out.push({\n\t                        anim: e.anim,\n\t                        status: e.status\n\t                    });\n\t                }\n\t            }\n\t            if (anim) {\n\t                return 0;\n\t            }\n\t            return out;\n\t        }\n\t    };\n\t    /*\\\n\t     * Element.pause\n\t     [ method ]\n\t     **\n\t     * Stops animation of the element with ability to resume it later on.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.pause = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\n\t                animationElements[i].paused = true;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.resume\n\t     [ method ]\n\t     **\n\t     * Resumes animation if it was paused with @Element.pause method.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.resume = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            var e = animationElements[i];\n\t            if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\n\t                delete e.paused;\n\t                this.status(e.anim, e.status);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.stop\n\t     [ method ]\n\t     **\n\t     * Stops animation of the element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.stop = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\n\t                animationElements.splice(i--, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    function stopAnimation(paper) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {\n\t            animationElements.splice(i--, 1);\n\t        }\n\t    }\n\t    eve.on(\"raphael.remove\", stopAnimation);\n\t    eve.on(\"raphael.clear\", stopAnimation);\n\t    elproto.toString = function () {\n\t        return \"Rapha\\xebl\\u2019s object\";\n\t    };\n\n\t    // Set\n\t    var Set = function (items) {\n\t        this.items = [];\n\t        this.length = 0;\n\t        this.type = \"set\";\n\t        if (items) {\n\t            for (var i = 0, ii = items.length; i < ii; i++) {\n\t                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\n\t                    this[this.items.length] = this.items[this.items.length] = items[i];\n\t                    this.length++;\n\t                }\n\t            }\n\t        }\n\t    },\n\t    setproto = Set.prototype;\n\t    /*\\\n\t     * Set.push\n\t     [ method ]\n\t     **\n\t     * Adds each argument to the current set.\n\t     = (object) original element\n\t    \\*/\n\t    setproto.push = function () {\n\t        var item,\n\t            len;\n\t        for (var i = 0, ii = arguments.length; i < ii; i++) {\n\t            item = arguments[i];\n\t            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\n\t                len = this.items.length;\n\t                this[len] = this.items[len] = item;\n\t                this.length++;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.pop\n\t     [ method ]\n\t     **\n\t     * Removes last element and returns it.\n\t     = (object) element\n\t    \\*/\n\t    setproto.pop = function () {\n\t        this.length && delete this[this.length--];\n\t        return this.items.pop();\n\t    };\n\t    /*\\\n\t     * Set.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element in the set.\n\t     *\n\t     * If function returns `false` it will stop loop running.\n\t     **\n\t     > Parameters\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.forEach = function (callback, thisArg) {\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            if (callback.call(thisArg, this.items[i], i) === false) {\n\t                return this;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    for (var method in elproto) if (elproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname][apply](el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t    setproto.attr = function (name, value) {\n\t        if (name && R.is(name, array) && R.is(name[0], \"object\")) {\n\t            for (var j = 0, jj = name.length; j < jj; j++) {\n\t                this.items[j].attr(name[j]);\n\t            }\n\t        } else {\n\t            for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t                this.items[i].attr(name, value);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.clear\n\t     [ method ]\n\t     **\n\t     * Removes all elements from the set\n\t    \\*/\n\t    setproto.clear = function () {\n\t        while (this.length) {\n\t            this.pop();\n\t        }\n\t    };\n\t    /*\\\n\t     * Set.splice\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     > Parameters\n\t     **\n\t     - index (number) position of the deletion\n\t     - count (number) number of element to remove\n\t     - insertion (object) #optional elements to insert\n\t     = (object) set elements that were deleted\n\t    \\*/\n\t    setproto.splice = function (index, count, insertion) {\n\t        index = index < 0 ? mmax(this.length + index, 0) : index;\n\t        count = mmax(0, mmin(this.length - index, count));\n\t        var tail = [],\n\t            todel = [],\n\t            args = [],\n\t            i;\n\t        for (i = 2; i < arguments.length; i++) {\n\t            args.push(arguments[i]);\n\t        }\n\t        for (i = 0; i < count; i++) {\n\t            todel.push(this[index + i]);\n\t        }\n\t        for (; i < this.length - index; i++) {\n\t            tail.push(this[index + i]);\n\t        }\n\t        var arglen = args.length;\n\t        for (i = 0; i < arglen + tail.length; i++) {\n\t            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n\t        }\n\t        i = this.items.length = this.length -= count - arglen;\n\t        while (this[i]) {\n\t            delete this[i++];\n\t        }\n\t        return new Set(todel);\n\t    };\n\t    /*\\\n\t     * Set.exclude\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     > Parameters\n\t     **\n\t     - element (object) element to remove\n\t     = (boolean) `true` if object was found & removed from the set\n\t    \\*/\n\t    setproto.exclude = function (el) {\n\t        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n\t            this.splice(i, 1);\n\t            return true;\n\t        }\n\t    };\n\t    setproto.animate = function (params, ms, easing, callback) {\n\t        (R.is(easing, \"function\") || !easing) && (callback = easing || null);\n\t        var len = this.items.length,\n\t            i = len,\n\t            item,\n\t            set = this,\n\t            collector;\n\t        if (!len) {\n\t            return this;\n\t        }\n\t        callback && (collector = function () {\n\t            !--len && callback.call(set);\n\t        });\n\t        easing = R.is(easing, string) ? easing : collector;\n\t        var anim = R.animation(params, ms, easing, collector);\n\t        item = this.items[--i].animate(anim);\n\t        while (i--) {\n\t            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\n\t            (this.items[i] && !this.items[i].removed) || len--;\n\t        }\n\t        return this;\n\t    };\n\t    setproto.insertAfter = function (el) {\n\t        var i = this.items.length;\n\t        while (i--) {\n\t            this.items[i].insertAfter(el);\n\t        }\n\t        return this;\n\t    };\n\t    setproto.getBBox = function () {\n\t        var x = [],\n\t            y = [],\n\t            x2 = [],\n\t            y2 = [];\n\t        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n\t            var box = this.items[i].getBBox();\n\t            x.push(box.x);\n\t            y.push(box.y);\n\t            x2.push(box.x + box.width);\n\t            y2.push(box.y + box.height);\n\t        }\n\t        x = mmin[apply](0, x);\n\t        y = mmin[apply](0, y);\n\t        x2 = mmax[apply](0, x2);\n\t        y2 = mmax[apply](0, y2);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            x2: x2,\n\t            y2: y2,\n\t            width: x2 - x,\n\t            height: y2 - y\n\t        };\n\t    };\n\t    setproto.clone = function (s) {\n\t        s = this.paper.set();\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            s.push(this.items[i].clone());\n\t        }\n\t        return s;\n\t    };\n\t    setproto.toString = function () {\n\t        return \"Rapha\\xebl\\u2018s set\";\n\t    };\n\n\t    setproto.glow = function(glowConfig) {\n\t        var ret = this.paper.set();\n\t        this.forEach(function(shape, index){\n\t            var g = shape.glow(glowConfig);\n\t            if(g != null){\n\t                g.forEach(function(shape2, index2){\n\t                    ret.push(shape2);\n\t                });\n\t            }\n\t        });\n\t        return ret;\n\t    };\n\n\n\t    /*\\\n\t     * Set.isPointInside\n\t     [ method ]\n\t     **\n\t     * Determine if given point is inside this sets elements\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (boolean) `true` if point is inside any of the set's elements\n\t     \\*/\n\t    setproto.isPointInside = function (x, y) {\n\t        var isPointInside = false;\n\t        this.forEach(function (el) {\n\t            if (el.isPointInside(x, y)) {\n\t                isPointInside = true;\n\t                return false; // stop loop\n\t            }\n\t        });\n\t        return isPointInside;\n\t    };\n\n\t    /*\\\n\t     * Raphael.registerFont\n\t     [ method ]\n\t     **\n\t     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.\n\t     * Returns original parameter, so it could be used with chaining.\n\t     # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\n\t     **\n\t     > Parameters\n\t     **\n\t     - font (object) the font to register\n\t     = (object) the font you passed in\n\t     > Usage\n\t     | Cufon.registerFont(Raphael.registerFont({}));\n\t    \\*/\n\t    R.registerFont = function (font) {\n\t        if (!font.face) {\n\t            return font;\n\t        }\n\t        this.fonts = this.fonts || {};\n\t        var fontcopy = {\n\t                w: font.w,\n\t                face: {},\n\t                glyphs: {}\n\t            },\n\t            family = font.face[\"font-family\"];\n\t        for (var prop in font.face) if (font.face[has](prop)) {\n\t            fontcopy.face[prop] = font.face[prop];\n\t        }\n\t        if (this.fonts[family]) {\n\t            this.fonts[family].push(fontcopy);\n\t        } else {\n\t            this.fonts[family] = [fontcopy];\n\t        }\n\t        if (!font.svg) {\n\t            fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\n\t            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {\n\t                var path = font.glyphs[glyph];\n\t                fontcopy.glyphs[glyph] = {\n\t                    w: path.w,\n\t                    k: {},\n\t                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\n\t                            return {l: \"L\", c: \"C\", x: \"z\", t: \"m\", r: \"l\", v: \"c\"}[command] || \"M\";\n\t                        }) + \"z\"\n\t                };\n\t                if (path.k) {\n\t                    for (var k in path.k) if (path[has](k)) {\n\t                        fontcopy.glyphs[glyph].k[k] = path.k[k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return font;\n\t    };\n\t    /*\\\n\t     * Paper.getFont\n\t     [ method ]\n\t     **\n\t     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.\n\t     **\n\t     > Parameters\n\t     **\n\t     - family (string) font family name or any word from it\n\t     - weight (string) #optional font weight\n\t     - style (string) #optional font style\n\t     - stretch (string) #optional font stretch\n\t     = (object) the font object\n\t     > Usage\n\t     | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\n\t    \\*/\n\t    paperproto.getFont = function (family, weight, style, stretch) {\n\t        stretch = stretch || \"normal\";\n\t        style = style || \"normal\";\n\t        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;\n\t        if (!R.fonts) {\n\t            return;\n\t        }\n\t        var font = R.fonts[family];\n\t        if (!font) {\n\t            var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\n\t            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {\n\t                if (name.test(fontName)) {\n\t                    font = R.fonts[fontName];\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        var thefont;\n\t        if (font) {\n\t            for (var i = 0, ii = font.length; i < ii; i++) {\n\t                thefont = font[i];\n\t                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return thefont;\n\t    };\n\t    /*\\\n\t     * Paper.print\n\t     [ method ]\n\t     **\n\t     * Creates path that represent given text written using given font at given position with given size.\n\t     * Result of the method is path element that contains whole text as a separate path.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x position of the text\n\t     - y (number) y position of the text\n\t     - string (string) text to print\n\t     - font (object) font object, see @Paper.getFont\n\t     - size (number) #optional size of the font, default is `16`\n\t     - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\n\t     - letter_spacing (number) #optional number in range `-1..1`, default is `0`\n\t     - line_spacing (number) #optional number in range `1..3`, default is `1`\n\t     = (object) resulting path element, which consist of all letters\n\t     > Usage\n\t     | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\n\t    \\*/\n\t    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\n\t        origin = origin || \"middle\"; // baseline|middle\n\t        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\n\t        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\n\t        var letters = Str(string)[split](E),\n\t            shift = 0,\n\t            notfirst = 0,\n\t            path = E,\n\t            scale;\n\t        R.is(font, \"string\") && (font = this.getFont(font));\n\t        if (font) {\n\t            scale = (size || 16) / font.face[\"units-per-em\"];\n\t            var bb = font.face.bbox[split](separator),\n\t                top = +bb[0],\n\t                lineHeight = bb[3] - bb[1],\n\t                shifty = 0,\n\t                height = +bb[1] + (origin == \"baseline\" ? lineHeight + (+font.face.descent) : lineHeight / 2);\n\t            for (var i = 0, ii = letters.length; i < ii; i++) {\n\t                if (letters[i] == \"\\n\") {\n\t                    shift = 0;\n\t                    curr = 0;\n\t                    notfirst = 0;\n\t                    shifty += lineHeight * line_spacing;\n\t                } else {\n\t                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},\n\t                        curr = font.glyphs[letters[i]];\n\t                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;\n\t                    notfirst = 1;\n\t                }\n\t                if (curr && curr.d) {\n\t                    path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\n\t                }\n\t            }\n\t        }\n\t        return this.path(path).attr({\n\t            fill: \"#000\",\n\t            stroke: \"none\"\n\t        });\n\t    };\n\n\t    /*\\\n\t     * Paper.add\n\t     [ method ]\n\t     **\n\t     * Imports elements in JSON array in format `{type: type, <attributes>}`\n\t     **\n\t     > Parameters\n\t     **\n\t     - json (array)\n\t     = (object) resulting set of imported elements\n\t     > Usage\n\t     | paper.add([\n\t     |     {\n\t     |         type: \"circle\",\n\t     |         cx: 10,\n\t     |         cy: 10,\n\t     |         r: 5\n\t     |     },\n\t     |     {\n\t     |         type: \"rect\",\n\t     |         x: 10,\n\t     |         y: 10,\n\t     |         width: 10,\n\t     |         height: 10,\n\t     |         fill: \"#fc0\"\n\t     |     }\n\t     | ]);\n\t    \\*/\n\t    paperproto.add = function (json) {\n\t        if (R.is(json, \"array\")) {\n\t            var res = this.set(),\n\t                i = 0,\n\t                ii = json.length,\n\t                j;\n\t            for (; i < ii; i++) {\n\t                j = json[i] || {};\n\t                elements[has](j.type) && res.push(this[j.type]().attr(j));\n\t            }\n\t        }\n\t        return res;\n\t    };\n\n\t    /*\\\n\t     * Raphael.format\n\t     [ method ]\n\t     **\n\t     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.\n\t     **\n\t     > Parameters\n\t     **\n\t     - token (string) string to format\n\t     -  (string) rest of arguments will be treated as parameters for replacement\n\t     = (string) formated string\n\t     > Usage\n\t     | var x = 10,\n\t     |     y = 20,\n\t     |     width = 40,\n\t     |     height = 50;\n\t     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t     | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\n\t    \\*/\n\t    R.format = function (token, params) {\n\t        var args = R.is(params, array) ? [0][concat](params) : arguments;\n\t        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\n\t            return args[++i] == null ? E : args[i];\n\t        }));\n\t        return token || E;\n\t    };\n\t    /*\\\n\t     * Raphael.fullfill\n\t     [ method ]\n\t     **\n\t     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.\n\t     **\n\t     > Parameters\n\t     **\n\t     - token (string) string to format\n\t     - json (object) object which properties will be used as a replacement\n\t     = (string) formated string\n\t     > Usage\n\t     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t     | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n\t     |     x: 10,\n\t     |     y: 20,\n\t     |     dim: {\n\t     |         width: 40,\n\t     |         height: 50,\n\t     |         \"negative width\": -40\n\t     |     }\n\t     | }));\n\t    \\*/\n\t    R.fullfill = (function () {\n\t        var tokenRegex = /\\{([^\\}]+)\\}/g,\n\t            objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\t            replacer = function (all, key, obj) {\n\t                var res = obj;\n\t                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n\t                    name = name || quotedName;\n\t                    if (res) {\n\t                        if (name in res) {\n\t                            res = res[name];\n\t                        }\n\t                        typeof res == \"function\" && isFunc && (res = res());\n\t                    }\n\t                });\n\t                res = (res == null || res == obj ? all : res) + \"\";\n\t                return res;\n\t            };\n\t        return function (str, obj) {\n\t            return String(str).replace(tokenRegex, function (all, key) {\n\t                return replacer(all, key, obj);\n\t            });\n\t        };\n\t    })();\n\t    /*\\\n\t     * Raphael.ninja\n\t     [ method ]\n\t     **\n\t     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\n\t     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\n\t     **\n\t     = (object) Raphael object\n\t     > Usage\n\t     | (function (local_raphael) {\n\t     |     var paper = local_raphael(10, 10, 320, 200);\n\t     |     \n\t     | })(Raphael.ninja());\n\t    \\*/\n\t    R.ninja = function () {\n\t        if (oldRaphael.was) {\n\t            g.win.Raphael = oldRaphael.is;\n\t        } else {\n\t            // IE8 raises an error when deleting window property\n\t            window.Raphael = undefined;\n\t            try {\n\t                delete window.Raphael;\n\t            } catch(e) {}\n\t        }\n\t        return R;\n\t    };\n\t    /*\\\n\t     * Raphael.st\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to elements and sets. It is wise to add a set method for each element method\n\t     * you added, so you will be able to call the same method on sets too.\n\t     **\n\t     * See also @Raphael.el.\n\t     > Usage\n\t     | Raphael.el.red = function () {\n\t     |     this.attr({fill: \"#f00\"});\n\t     | };\n\t     | Raphael.st.red = function () {\n\t     |     this.forEach(function (el) {\n\t     |         el.red();\n\t     |     });\n\t     | };\n\t     | // then use it\n\t     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\n\t    \\*/\n\t    R.st = setproto;\n\n\t    eve.on(\"raphael.DOMload\", function () {\n\t        loaded = true;\n\t    });\n\n\t    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\t    (function (doc, loaded, f) {\n\t        if (doc.readyState == null && doc.addEventListener){\n\t            doc.addEventListener(loaded, f = function () {\n\t                doc.removeEventListener(loaded, f, false);\n\t                doc.readyState = \"complete\";\n\t            }, false);\n\t            doc.readyState = \"loading\";\n\t        }\n\t        function isLoaded() {\n\t            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\n\t        }\n\t        isLoaded();\n\t    })(document, \"DOMContentLoaded\");\n\n\t    return R;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t//  \\\\\n\t//  Eve 0.5.0 - JavaScript Events Library                       \\\\\n\t//  \\\\\n\t//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n\t//  \\\\\n\n\t(function (glob) {\n\t    var version = \"0.5.0\",\n\t        has = \"hasOwnProperty\",\n\t        separator = /[\\.\\/]/,\n\t        comaseparator = /\\s*,\\s*/,\n\t        wildcard = \"*\",\n\t        fun = function () {},\n\t        numsort = function (a, b) {\n\t            return a - b;\n\t        },\n\t        current_event,\n\t        stop,\n\t        events = {n: {}},\n\t        firstDefined = function () {\n\t            for (var i = 0, ii = this.length; i < ii; i++) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        lastDefined = function () {\n\t            var i = this.length;\n\t            while (--i) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        objtos = Object.prototype.toString,\n\t        Str = String,\n\t        isArray = Array.isArray || function (ar) {\n\t            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n\t        };\n\t    /*\\\n\t     * eve\n\t     [ method ]\n\n\t     * Fires event with given `name`, given scope and other parameters.\n\n\t     > Arguments\n\n\t     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n\t     - scope (object) context for the event handlers\n\t     - varargs (...) the rest of arguments will be sent to event handlers\n\n\t     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n\t    \\*/\n\t        eve = function (name, scope) {\n\t            var e = events,\n\t                oldstop = stop,\n\t                args = Array.prototype.slice.call(arguments, 2),\n\t                listeners = eve.listeners(name),\n\t                z = 0,\n\t                f = false,\n\t                l,\n\t                indexed = [],\n\t                queue = {},\n\t                out = [],\n\t                ce = current_event,\n\t                errors = [];\n\t            out.firstDefined = firstDefined;\n\t            out.lastDefined = lastDefined;\n\t            current_event = name;\n\t            stop = 0;\n\t            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n\t                indexed.push(listeners[i].zIndex);\n\t                if (listeners[i].zIndex < 0) {\n\t                    queue[listeners[i].zIndex] = listeners[i];\n\t                }\n\t            }\n\t            indexed.sort(numsort);\n\t            while (indexed[z] < 0) {\n\t                l = queue[indexed[z++]];\n\t                out.push(l.apply(scope, args));\n\t                if (stop) {\n\t                    stop = oldstop;\n\t                    return out;\n\t                }\n\t            }\n\t            for (i = 0; i < ii; i++) {\n\t                l = listeners[i];\n\t                if (\"zIndex\" in l) {\n\t                    if (l.zIndex == indexed[z]) {\n\t                        out.push(l.apply(scope, args));\n\t                        if (stop) {\n\t                            break;\n\t                        }\n\t                        do {\n\t                            z++;\n\t                            l = queue[indexed[z]];\n\t                            l && out.push(l.apply(scope, args));\n\t                            if (stop) {\n\t                                break;\n\t                            }\n\t                        } while (l)\n\t                    } else {\n\t                        queue[l.zIndex] = l;\n\t                    }\n\t                } else {\n\t                    out.push(l.apply(scope, args));\n\t                    if (stop) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            stop = oldstop;\n\t            current_event = ce;\n\t            return out;\n\t        };\n\t        // Undocumented. Debug only.\n\t        eve._events = events;\n\t    /*\\\n\t     * eve.listeners\n\t     [ method ]\n\n\t     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n\t     > Arguments\n\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n\t     = (array) array of event handlers\n\t    \\*/\n\t    eve.listeners = function (name) {\n\t        var names = isArray(name) ? name : name.split(separator),\n\t            e = events,\n\t            item,\n\t            items,\n\t            k,\n\t            i,\n\t            ii,\n\t            j,\n\t            jj,\n\t            nes,\n\t            es = [e],\n\t            out = [];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            nes = [];\n\t            for (j = 0, jj = es.length; j < jj; j++) {\n\t                e = es[j].n;\n\t                items = [e[names[i]], e[wildcard]];\n\t                k = 2;\n\t                while (k--) {\n\t                    item = items[k];\n\t                    if (item) {\n\t                        nes.push(item);\n\t                        out = out.concat(item.f || []);\n\t                    }\n\t                }\n\t            }\n\t            es = nes;\n\t        }\n\t        return out;\n\t    };\n\t    /*\\\n\t     * eve.separator\n\t     [ method ]\n\n\t     * If for some reasons you dont like default separators (`.` or `/`) you can specify yours\n\t     * here. Be aware that if you pass a string longer than one character it will be treated as\n\t     * a list of characters.\n\n\t     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n\t    \\*/\n\t    eve.separator = function (sep) {\n\t        if (sep) {\n\t            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n\t            sep = \"[\" + sep + \"]\";\n\t            separator = new RegExp(sep);\n\t        } else {\n\t            separator = /[\\.\\/]/;\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.on\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n\t     | eve.on(\"*.under.*\", f);\n\t     | eve(\"mouse.under.floor\"); // triggers f\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     - name (array) if you dont want to use separators, you can use array of strings\n\t     - f (function) event handler function\n\t     **\n\t     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n\t     > Example:\n\t     | eve.on(\"mouse\", eatIt)(2);\n\t     | eve.on(\"mouse\", scream);\n\t     | eve.on(\"mouse\", catchIt)(1);\n\t     * This will ensure that `catchIt` function will be called before `eatIt`.\n\t     *\n\t     * If you want to put your handler before non-indexed handlers, specify a negative value.\n\t     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n\t    \\*/\n\t    eve.on = function (name, f) {\n\t        if (typeof f != \"function\") {\n\t            return function () {};\n\t        }\n\t        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n\t        for (var i = 0, ii = names.length; i < ii; i++) {\n\t            (function (name) {\n\t                var names = isArray(name) ? name : Str(name).split(separator),\n\t                    e = events,\n\t                    exist;\n\t                for (var i = 0, ii = names.length; i < ii; i++) {\n\t                    e = e.n;\n\t                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n\t                }\n\t                e.f = e.f || [];\n\t                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t                !exist && e.f.push(f);\n\t            }(names[i]));\n\t        }\n\t        return function (zIndex) {\n\t            if (+zIndex == +zIndex) {\n\t                f.zIndex = +zIndex;\n\t            }\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.f\n\t     [ method ]\n\t     **\n\t     * Returns function that will fire given event with optional arguments.\n\t     * Arguments that will be passed to the result function will be also\n\t     * concated to the list of final arguments.\n\t     | el.onclick = eve.f(\"click\", 1, 2);\n\t     | eve.on(\"click\", function (a, b, c) {\n\t     |     console.log(a, b, c); // 1, 2, [event object]\n\t     | });\n\t     > Arguments\n\t     - event (string) event name\n\t     - varargs () and any other arguments\n\t     = (function) possible event handler function\n\t    \\*/\n\t    eve.f = function (event) {\n\t        var attrs = [].slice.call(arguments, 1);\n\t        return function () {\n\t            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.stop\n\t     [ method ]\n\t     **\n\t     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n\t    \\*/\n\t    eve.stop = function () {\n\t        stop = 1;\n\t    };\n\t    /*\\\n\t     * eve.nt\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     > Arguments\n\t     **\n\t     - subname (string) #optional subname of the event\n\t     **\n\t     = (string) name of the event, if `subname` is not specified\n\t     * or\n\t     = (boolean) `true`, if current events name contains `subname`\n\t    \\*/\n\t    eve.nt = function (subname) {\n\t        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\t        if (subname) {\n\t            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n\t        }\n\t        return cur;\n\t    };\n\t    /*\\\n\t     * eve.nts\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     **\n\t     = (array) names of the event\n\t    \\*/\n\t    eve.nts = function () {\n\t        return isArray(current_event) ? current_event : current_event.split(separator);\n\t    };\n\t    /*\\\n\t     * eve.off\n\t     [ method ]\n\t     **\n\t     * Removes given function from the list of event listeners assigned to given name.\n\t     * If no arguments specified all the events will be cleared.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t    \\*/\n\t    /*\\\n\t     * eve.unbind\n\t     [ method ]\n\t     **\n\t     * See @eve.off\n\t    \\*/\n\t    eve.off = eve.unbind = function (name, f) {\n\t        if (!name) {\n\t            eve._events = events = {n: {}};\n\t            return;\n\t        }\n\t        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n\t        if (names.length > 1) {\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                eve.off(names[i], f);\n\t            }\n\t            return;\n\t        }\n\t        names = isArray(name) ? name : Str(name).split(separator);\n\t        var e,\n\t            key,\n\t            splice,\n\t            i, ii, j, jj,\n\t            cur = [events];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            for (j = 0; j < cur.length; j += splice.length - 2) {\n\t                splice = [j, 1];\n\t                e = cur[j].n;\n\t                if (names[i] != wildcard) {\n\t                    if (e[names[i]]) {\n\t                        splice.push(e[names[i]]);\n\t                    }\n\t                } else {\n\t                    for (key in e) if (e[has](key)) {\n\t                        splice.push(e[key]);\n\t                    }\n\t                }\n\t                cur.splice.apply(cur, splice);\n\t            }\n\t        }\n\t        for (i = 0, ii = cur.length; i < ii; i++) {\n\t            e = cur[i];\n\t            while (e.n) {\n\t                if (f) {\n\t                    if (e.f) {\n\t                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n\t                            e.f.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !e.f.length && delete e.f;\n\t                    }\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        var funcs = e.n[key].f;\n\t                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n\t                            funcs.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !funcs.length && delete e.n[key].f;\n\t                    }\n\t                } else {\n\t                    delete e.f;\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        delete e.n[key].f;\n\t                    }\n\t                }\n\t                e = e.n;\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.once\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name to only run once then unbind itself.\n\t     | eve.once(\"login\", f);\n\t     | eve(\"login\"); // triggers f\n\t     | eve(\"login\"); // no listeners\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) same return function as @eve.on\n\t    \\*/\n\t    eve.once = function (name, f) {\n\t        var f2 = function () {\n\t            eve.off(name, f2);\n\t            return f.apply(this, arguments);\n\t        };\n\t        return eve.on(name, f2);\n\t    };\n\t    /*\\\n\t     * eve.version\n\t     [ property (string) ]\n\t     **\n\t     * Current version of the library.\n\t    \\*/\n\t    eve.version = version;\n\t    eve.toString = function () {\n\t        return \"You are running Eve \" + version;\n\t    };\n\t    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));\n\t})(this);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\t    if (R && !R.svg) {\n\t        return;\n\t    }\n\n\t    var has = \"hasOwnProperty\",\n\t        Str = String,\n\t        toFloat = parseFloat,\n\t        toInt = parseInt,\n\t        math = Math,\n\t        mmax = math.max,\n\t        abs = math.abs,\n\t        pow = math.pow,\n\t        separator = /[, ]+/,\n\t        eve = R.eve,\n\t        E = \"\",\n\t        S = \" \";\n\t    var xlink = \"http://www.w3.org/1999/xlink\",\n\t        markers = {\n\t            block: \"M5,0 0,2.5 5,5z\",\n\t            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\n\t            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\n\t            open: \"M6,1 1,3.5 6,6\",\n\t            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\n\t        },\n\t        markerCounter = {};\n\t    R.toString = function () {\n\t        return  \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\n\t    };\n\t    var $ = function (el, attr) {\n\t        if (attr) {\n\t            if (typeof el == \"string\") {\n\t                el = $(el);\n\t            }\n\t            for (var key in attr) if (attr[has](key)) {\n\t                if (key.substring(0, 6) == \"xlink:\") {\n\t                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\n\t                } else {\n\t                    el.setAttribute(key, Str(attr[key]));\n\t                }\n\t            }\n\t        } else {\n\t            el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\n\t            el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\n\t        }\n\t        return el;\n\t    },\n\t    addGradientFill = function (element, gradient) {\n\t        var type = \"linear\",\n\t            id = element.id + gradient,\n\t            fx = .5, fy = .5,\n\t            o = element.node,\n\t            SVG = element.paper,\n\t            s = o.style,\n\t            el = R._g.doc.getElementById(id);\n\t        if (!el) {\n\t            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\n\t                type = \"radial\";\n\t                if (_fx && _fy) {\n\t                    fx = toFloat(_fx);\n\t                    fy = toFloat(_fy);\n\t                    var dir = ((fy > .5) * 2 - 1);\n\t                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&\n\t                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&\n\t                        fy != .5 &&\n\t                        (fy = fy.toFixed(5) - 1e-5 * dir);\n\t                }\n\t                return E;\n\t            });\n\t            gradient = gradient.split(/\\s*\\-\\s*/);\n\t            if (type == \"linear\") {\n\t                var angle = gradient.shift();\n\t                angle = -toFloat(angle);\n\t                if (isNaN(angle)) {\n\t                    return null;\n\t                }\n\t                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\n\t                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\n\t                vector[2] *= max;\n\t                vector[3] *= max;\n\t                if (vector[2] < 0) {\n\t                    vector[0] = -vector[2];\n\t                    vector[2] = 0;\n\t                }\n\t                if (vector[3] < 0) {\n\t                    vector[1] = -vector[3];\n\t                    vector[3] = 0;\n\t                }\n\t            }\n\t            var dots = R._parseDots(gradient);\n\t            if (!dots) {\n\t                return null;\n\t            }\n\t            id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\n\n\t            if (element.gradient && id != element.gradient.id) {\n\t                SVG.defs.removeChild(element.gradient);\n\t                delete element.gradient;\n\t            }\n\n\t            if (!element.gradient) {\n\t                el = $(type + \"Gradient\", {id: id});\n\t                element.gradient = el;\n\t                $(el, type == \"radial\" ? {\n\t                    fx: fx,\n\t                    fy: fy\n\t                } : {\n\t                    x1: vector[0],\n\t                    y1: vector[1],\n\t                    x2: vector[2],\n\t                    y2: vector[3],\n\t                    gradientTransform: element.matrix.invert()\n\t                });\n\t                SVG.defs.appendChild(el);\n\t                for (var i = 0, ii = dots.length; i < ii; i++) {\n\t                    el.appendChild($(\"stop\", {\n\t                        offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\n\t                        \"stop-color\": dots[i].color || \"#fff\",\n\t                        \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\n\t                    }));\n\t                }\n\t            }\n\t        }\n\t        $(o, {\n\t            fill: fillurl(id),\n\t            opacity: 1,\n\t            \"fill-opacity\": 1\n\t        });\n\t        s.fill = E;\n\t        s.opacity = 1;\n\t        s.fillOpacity = 1;\n\t        return 1;\n\t    },\n\t    isIE9or10 = function () {\n\t      var mode = document.documentMode;\n\t      return mode && (mode === 9 || mode === 10);\n\t    },\n\t    fillurl = function (id) {\n\t      if (isIE9or10()) {\n\t          return \"url('#\" + id + \"')\";\n\t      }\n\t      var location = document.location;\n\t      var locationString = (\n\t          location.protocol + '//' +\n\t          location.host +\n\t          location.pathname +\n\t          location.search\n\t      );\n\t      return \"url('\" + locationString + \"#\" + id + \"')\";\n\t    },\n\t    updatePosition = function (o) {\n\t        var bbox = o.getBBox(1);\n\t        $(o.pattern, {patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"});\n\t    },\n\t    addArrow = function (o, value, isEnd) {\n\t        if (o.type == \"path\") {\n\t            var values = Str(value).toLowerCase().split(\"-\"),\n\t                p = o.paper,\n\t                se = isEnd ? \"end\" : \"start\",\n\t                node = o.node,\n\t                attrs = o.attrs,\n\t                stroke = attrs[\"stroke-width\"],\n\t                i = values.length,\n\t                type = \"classic\",\n\t                from,\n\t                to,\n\t                dx,\n\t                refX,\n\t                attr,\n\t                w = 3,\n\t                h = 3,\n\t                t = 5;\n\t            while (i--) {\n\t                switch (values[i]) {\n\t                    case \"block\":\n\t                    case \"classic\":\n\t                    case \"oval\":\n\t                    case \"diamond\":\n\t                    case \"open\":\n\t                    case \"none\":\n\t                        type = values[i];\n\t                        break;\n\t                    case \"wide\": h = 5; break;\n\t                    case \"narrow\": h = 2; break;\n\t                    case \"long\": w = 5; break;\n\t                    case \"short\": w = 2; break;\n\t                }\n\t            }\n\t            if (type == \"open\") {\n\t                w += 2;\n\t                h += 2;\n\t                t += 2;\n\t                dx = 1;\n\t                refX = isEnd ? 4 : 1;\n\t                attr = {\n\t                    fill: \"none\",\n\t                    stroke: attrs.stroke\n\t                };\n\t            } else {\n\t                refX = dx = w / 2;\n\t                attr = {\n\t                    fill: attrs.stroke,\n\t                    stroke: \"none\"\n\t                };\n\t            }\n\t            if (o._.arrows) {\n\t                if (isEnd) {\n\t                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\n\t                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\n\t                } else {\n\t                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\n\t                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\n\t                }\n\t            } else {\n\t                o._.arrows = {};\n\t            }\n\t            if (type != \"none\") {\n\t                var pathId = \"raphael-marker-\" + type,\n\t                    markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\n\t                if (!R._g.doc.getElementById(pathId)) {\n\t                    p.defs.appendChild($($(\"path\"), {\n\t                        \"stroke-linecap\": \"round\",\n\t                        d: markers[type],\n\t                        id: pathId\n\t                    }));\n\t                    markerCounter[pathId] = 1;\n\t                } else {\n\t                    markerCounter[pathId]++;\n\t                }\n\t                var marker = R._g.doc.getElementById(markerId),\n\t                    use;\n\t                if (!marker) {\n\t                    marker = $($(\"marker\"), {\n\t                        id: markerId,\n\t                        markerHeight: h,\n\t                        markerWidth: w,\n\t                        orient: \"auto\",\n\t                        refX: refX,\n\t                        refY: h / 2\n\t                    });\n\t                    use = $($(\"use\"), {\n\t                        \"xlink:href\": \"#\" + pathId,\n\t                        transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\n\t                        \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\n\t                    });\n\t                    marker.appendChild(use);\n\t                    p.defs.appendChild(marker);\n\t                    markerCounter[markerId] = 1;\n\t                } else {\n\t                    markerCounter[markerId]++;\n\t                    use = marker.getElementsByTagName(\"use\")[0];\n\t                }\n\t                $(use, attr);\n\t                var delta = dx * (type != \"diamond\" && type != \"oval\");\n\t                if (isEnd) {\n\t                    from = o._.arrows.startdx * stroke || 0;\n\t                    to = R.getTotalLength(attrs.path) - delta * stroke;\n\t                } else {\n\t                    from = delta * stroke;\n\t                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n\t                }\n\t                attr = {};\n\t                attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\n\t                if (to || from) {\n\t                    attr.d = R.getSubpath(attrs.path, from, to);\n\t                }\n\t                $(node, attr);\n\t                o._.arrows[se + \"Path\"] = pathId;\n\t                o._.arrows[se + \"Marker\"] = markerId;\n\t                o._.arrows[se + \"dx\"] = delta;\n\t                o._.arrows[se + \"Type\"] = type;\n\t                o._.arrows[se + \"String\"] = value;\n\t            } else {\n\t                if (isEnd) {\n\t                    from = o._.arrows.startdx * stroke || 0;\n\t                    to = R.getTotalLength(attrs.path) - from;\n\t                } else {\n\t                    from = 0;\n\t                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n\t                }\n\t                o._.arrows[se + \"Path\"] && $(node, {d: R.getSubpath(attrs.path, from, to)});\n\t                delete o._.arrows[se + \"Path\"];\n\t                delete o._.arrows[se + \"Marker\"];\n\t                delete o._.arrows[se + \"dx\"];\n\t                delete o._.arrows[se + \"Type\"];\n\t                delete o._.arrows[se + \"String\"];\n\t            }\n\t            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {\n\t                var item = R._g.doc.getElementById(attr);\n\t                item && item.parentNode.removeChild(item);\n\t            }\n\t        }\n\t    },\n\t    dasharray = {\n\t        \"-\": [3, 1],\n\t        \".\": [1, 1],\n\t        \"-.\": [3, 1, 1, 1],\n\t        \"-..\": [3, 1, 1, 1, 1, 1],\n\t        \". \": [1, 3],\n\t        \"- \": [4, 3],\n\t        \"--\": [8, 3],\n\t        \"- .\": [4, 3, 1, 3],\n\t        \"--.\": [8, 3, 1, 3],\n\t        \"--..\": [8, 3, 1, 3, 1, 3]\n\t    },\n\t    addDashes = function (o, value, params) {\n\t        value = dasharray[Str(value).toLowerCase()];\n\t        if (value) {\n\t            var width = o.attrs[\"stroke-width\"] || \"1\",\n\t                butt = {round: width, square: width, butt: 0}[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\n\t                dashes = [],\n\t                i = value.length;\n\t            while (i--) {\n\t                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;\n\t            }\n\t            $(o.node, {\"stroke-dasharray\": dashes.join(\",\")});\n\t        }\n\t        else {\n\t          $(o.node, {\"stroke-dasharray\": \"none\"});\n\t        }\n\t    },\n\t    setFillAndStroke = function (o, params) {\n\t        var node = o.node,\n\t            attrs = o.attrs,\n\t            vis = node.style.visibility;\n\t        node.style.visibility = \"hidden\";\n\t        for (var att in params) {\n\t            if (params[has](att)) {\n\t                if (!R._availableAttrs[has](att)) {\n\t                    continue;\n\t                }\n\t                var value = params[att];\n\t                attrs[att] = value;\n\t                switch (att) {\n\t                    case \"blur\":\n\t                        o.blur(value);\n\t                        break;\n\t                    case \"title\":\n\t                        var title = node.getElementsByTagName(\"title\");\n\n\t                        // Use the existing <title>.\n\t                        if (title.length && (title = title[0])) {\n\t                          title.firstChild.nodeValue = value;\n\t                        } else {\n\t                          title = $(\"title\");\n\t                          var val = R._g.doc.createTextNode(value);\n\t                          title.appendChild(val);\n\t                          node.appendChild(title);\n\t                        }\n\t                        break;\n\t                    case \"href\":\n\t                    case \"target\":\n\t                        var pn = node.parentNode;\n\t                        if (pn.tagName.toLowerCase() != \"a\") {\n\t                            var hl = $(\"a\");\n\t                            pn.insertBefore(hl, node);\n\t                            hl.appendChild(node);\n\t                            pn = hl;\n\t                        }\n\t                        if (att == \"target\") {\n\t                            pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\n\t                        } else {\n\t                            pn.setAttributeNS(xlink, att, value);\n\t                        }\n\t                        break;\n\t                    case \"cursor\":\n\t                        node.style.cursor = value;\n\t                        break;\n\t                    case \"transform\":\n\t                        o.transform(value);\n\t                        break;\n\t                    case \"arrow-start\":\n\t                        addArrow(o, value);\n\t                        break;\n\t                    case \"arrow-end\":\n\t                        addArrow(o, value, 1);\n\t                        break;\n\t                    case \"clip-rect\":\n\t                        var rect = Str(value).split(separator);\n\t                        if (rect.length == 4) {\n\t                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\n\t                            var el = $(\"clipPath\"),\n\t                                rc = $(\"rect\");\n\t                            el.id = R.createUUID();\n\t                            $(rc, {\n\t                                x: rect[0],\n\t                                y: rect[1],\n\t                                width: rect[2],\n\t                                height: rect[3]\n\t                            });\n\t                            el.appendChild(rc);\n\t                            o.paper.defs.appendChild(el);\n\t                            $(node, {\"clip-path\": \"url(#\" + el.id + \")\"});\n\t                            o.clip = rc;\n\t                        }\n\t                        if (!value) {\n\t                            var path = node.getAttribute(\"clip-path\");\n\t                            if (path) {\n\t                                var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\n\t                                clip && clip.parentNode.removeChild(clip);\n\t                                $(node, {\"clip-path\": E});\n\t                                delete o.clip;\n\t                            }\n\t                        }\n\t                    break;\n\t                    case \"path\":\n\t                        if (o.type == \"path\") {\n\t                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"});\n\t                            o._.dirty = 1;\n\t                            if (o._.arrows) {\n\t                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                            }\n\t                        }\n\t                        break;\n\t                    case \"width\":\n\t                        node.setAttribute(att, value);\n\t                        o._.dirty = 1;\n\t                        if (attrs.fx) {\n\t                            att = \"x\";\n\t                            value = attrs.x;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    case \"x\":\n\t                        if (attrs.fx) {\n\t                            value = -attrs.x - (attrs.width || 0);\n\t                        }\n\t                    case \"rx\":\n\t                        if (att == \"rx\" && o.type == \"rect\") {\n\t                            break;\n\t                        }\n\t                    case \"cx\":\n\t                        node.setAttribute(att, value);\n\t                        o.pattern && updatePosition(o);\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"height\":\n\t                        node.setAttribute(att, value);\n\t                        o._.dirty = 1;\n\t                        if (attrs.fy) {\n\t                            att = \"y\";\n\t                            value = attrs.y;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    case \"y\":\n\t                        if (attrs.fy) {\n\t                            value = -attrs.y - (attrs.height || 0);\n\t                        }\n\t                    case \"ry\":\n\t                        if (att == \"ry\" && o.type == \"rect\") {\n\t                            break;\n\t                        }\n\t                    case \"cy\":\n\t                        node.setAttribute(att, value);\n\t                        o.pattern && updatePosition(o);\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"r\":\n\t                        if (o.type == \"rect\") {\n\t                            $(node, {rx: value, ry: value});\n\t                        } else {\n\t                            node.setAttribute(att, value);\n\t                        }\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"src\":\n\t                        if (o.type == \"image\") {\n\t                            node.setAttributeNS(xlink, \"href\", value);\n\t                        }\n\t                        break;\n\t                    case \"stroke-width\":\n\t                        if (o._.sx != 1 || o._.sy != 1) {\n\t                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\n\t                        }\n\t                        node.setAttribute(att, value);\n\t                        if (attrs[\"stroke-dasharray\"]) {\n\t                            addDashes(o, attrs[\"stroke-dasharray\"], params);\n\t                        }\n\t                        if (o._.arrows) {\n\t                            \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                            \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                        }\n\t                        break;\n\t                    case \"stroke-dasharray\":\n\t                        addDashes(o, value, params);\n\t                        break;\n\t                    case \"fill\":\n\t                        var isURL = Str(value).match(R._ISURL);\n\t                        if (isURL) {\n\t                            el = $(\"pattern\");\n\t                            var ig = $(\"image\");\n\t                            el.id = R.createUUID();\n\t                            $(el, {x: 0, y: 0, patternUnits: \"userSpaceOnUse\", height: 1, width: 1});\n\t                            $(ig, {x: 0, y: 0, \"xlink:href\": isURL[1]});\n\t                            el.appendChild(ig);\n\n\t                            (function (el) {\n\t                                R._preload(isURL[1], function () {\n\t                                    var w = this.offsetWidth,\n\t                                        h = this.offsetHeight;\n\t                                    $(el, {width: w, height: h});\n\t                                    $(ig, {width: w, height: h});\n\t                                });\n\t                            })(el);\n\t                            o.paper.defs.appendChild(el);\n\t                            $(node, {fill: \"url(#\" + el.id + \")\"});\n\t                            o.pattern = el;\n\t                            o.pattern && updatePosition(o);\n\t                            break;\n\t                        }\n\t                        var clr = R.getRGB(value);\n\t                        if (!clr.error) {\n\t                            delete params.gradient;\n\t                            delete attrs.gradient;\n\t                            !R.is(attrs.opacity, \"undefined\") &&\n\t                                R.is(params.opacity, \"undefined\") &&\n\t                                $(node, {opacity: attrs.opacity});\n\t                            !R.is(attrs[\"fill-opacity\"], \"undefined\") &&\n\t                                R.is(params[\"fill-opacity\"], \"undefined\") &&\n\t                                $(node, {\"fill-opacity\": attrs[\"fill-opacity\"]});\n\t                        } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\n\t                            if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\n\t                                var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\t                                if (gradient) {\n\t                                    var stops = gradient.getElementsByTagName(\"stop\");\n\t                                    $(stops[stops.length - 1], {\"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)});\n\t                                }\n\t                            }\n\t                            attrs.gradient = value;\n\t                            attrs.fill = \"none\";\n\t                            break;\n\t                        }\n\t                        clr[has](\"opacity\") && $(node, {\"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n\t                    case \"stroke\":\n\t                        clr = R.getRGB(value);\n\t                        node.setAttribute(att, clr.hex);\n\t                        att == \"stroke\" && clr[has](\"opacity\") && $(node, {\"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n\t                        if (att == \"stroke\" && o._.arrows) {\n\t                            \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                            \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                        }\n\t                        break;\n\t                    case \"gradient\":\n\t                        (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\n\t                        break;\n\t                    case \"opacity\":\n\t                        if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\n\t                            $(node, {\"stroke-opacity\": value > 1 ? value / 100 : value});\n\t                        }\n\t                        // fall\n\t                    case \"fill-opacity\":\n\t                        if (attrs.gradient) {\n\t                            gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\t                            if (gradient) {\n\t                                stops = gradient.getElementsByTagName(\"stop\");\n\t                                $(stops[stops.length - 1], {\"stop-opacity\": value});\n\t                            }\n\t                            break;\n\t                        }\n\t                    default:\n\t                        att == \"font-size\" && (value = toInt(value, 10) + \"px\");\n\t                        var cssrule = att.replace(/(\\-.)/g, function (w) {\n\t                            return w.substring(1).toUpperCase();\n\t                        });\n\t                        node.style[cssrule] = value;\n\t                        o._.dirty = 1;\n\t                        node.setAttribute(att, value);\n\t                        break;\n\t                }\n\t            }\n\t        }\n\n\t        tuneText(o, params);\n\t        node.style.visibility = vis;\n\t    },\n\t    leading = 1.2,\n\t    tuneText = function (el, params) {\n\t        if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\n\t            return;\n\t        }\n\t        var a = el.attrs,\n\t            node = el.node,\n\t            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\n\n\t        if (params[has](\"text\")) {\n\t            a.text = params.text;\n\t            while (node.firstChild) {\n\t                node.removeChild(node.firstChild);\n\t            }\n\t            var texts = Str(params.text).split(\"\\n\"),\n\t                tspans = [],\n\t                tspan;\n\t            for (var i = 0, ii = texts.length; i < ii; i++) {\n\t                tspan = $(\"tspan\");\n\t                i && $(tspan, {dy: fontSize * leading, x: a.x});\n\t                tspan.appendChild(R._g.doc.createTextNode(texts[i]));\n\t                node.appendChild(tspan);\n\t                tspans[i] = tspan;\n\t            }\n\t        } else {\n\t            tspans = node.getElementsByTagName(\"tspan\");\n\t            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {\n\t                $(tspans[i], {dy: fontSize * leading, x: a.x});\n\t            } else {\n\t                $(tspans[0], {dy: 0});\n\t            }\n\t        }\n\t        $(node, {x: a.x, y: a.y});\n\t        el._.dirty = 1;\n\t        var bb = el._getBBox(),\n\t            dif = a.y - (bb.y + bb.height / 2);\n\t        dif && R.is(dif, \"finite\") && $(tspans[0], {dy: dif});\n\t    },\n\t    getRealNode = function (node) {\n\t        if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\n\t            return node.parentNode;\n\t        } else {\n\t            return node;\n\t        }\n\t    },\n\t    Element = function (node, svg) {\n\t        var X = 0,\n\t            Y = 0;\n\t        /*\\\n\t         * Element.node\n\t         [ property (object) ]\n\t         **\n\t         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n\t         **\n\t         * Note: Dont mess with it.\n\t         > Usage\n\t         | // draw a circle at coordinate 10,10 with radius of 10\n\t         | var c = paper.circle(10, 10, 10);\n\t         | c.node.onclick = function () {\n\t         |     c.attr(\"fill\", \"red\");\n\t         | };\n\t        \\*/\n\t        this[0] = this.node = node;\n\t        /*\\\n\t         * Element.raphael\n\t         [ property (object) ]\n\t         **\n\t         * Internal reference to @Raphael object. In case it is not available.\n\t         > Usage\n\t         | Raphael.el.red = function () {\n\t         |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\n\t         |     hsb.h = 1;\n\t         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\n\t         | }\n\t        \\*/\n\t        node.raphael = true;\n\t        /*\\\n\t         * Element.id\n\t         [ property (number) ]\n\t         **\n\t         * Unique id of the element. Especially useful when you want to listen to events of the element,\n\t         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\n\t        \\*/\n\t        this.id = guid();\n\t        node.raphaelid = this.id;\n\n\t        /**\n\t        * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements\n\t        * @returns {string} id\n\t        */\n\t        function guid() {\n\t            return (\"0000\" + (Math.random()*Math.pow(36,5) << 0).toString(36)).slice(-5);\n\t        }\n\n\t        this.matrix = R.matrix();\n\t        this.realPath = null;\n\t        /*\\\n\t         * Element.paper\n\t         [ property (object) ]\n\t         **\n\t         * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.\n\t         > Usage\n\t         | Raphael.el.cross = function () {\n\t         |     this.attr({fill: \"red\"});\n\t         |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\n\t         |         .attr({stroke: \"red\"});\n\t         | }\n\t        \\*/\n\t        this.paper = svg;\n\t        this.attrs = this.attrs || {};\n\t        this._ = {\n\t            transform: [],\n\t            sx: 1,\n\t            sy: 1,\n\t            deg: 0,\n\t            dx: 0,\n\t            dy: 0,\n\t            dirty: 1\n\t        };\n\t        !svg.bottom && (svg.bottom = this);\n\t        /*\\\n\t         * Element.prev\n\t         [ property (object) ]\n\t         **\n\t         * Reference to the previous element in the hierarchy.\n\t        \\*/\n\t        this.prev = svg.top;\n\t        svg.top && (svg.top.next = this);\n\t        svg.top = this;\n\t        /*\\\n\t         * Element.next\n\t         [ property (object) ]\n\t         **\n\t         * Reference to the next element in the hierarchy.\n\t        \\*/\n\t        this.next = null;\n\t    },\n\t    elproto = R.el;\n\n\t    Element.prototype = elproto;\n\t    elproto.constructor = Element;\n\n\t    R._engine.path = function (pathString, SVG) {\n\t        var el = $(\"path\");\n\t        SVG.canvas && SVG.canvas.appendChild(el);\n\t        var p = new Element(el, SVG);\n\t        p.type = \"path\";\n\t        setFillAndStroke(p, {\n\t            fill: \"none\",\n\t            stroke: \"#000\",\n\t            path: pathString\n\t        });\n\t        return p;\n\t    };\n\t    /*\\\n\t     * Element.rotate\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds rotation by given angle around given point to the list of\n\t     * transformations of the element.\n\t     > Parameters\n\t     - deg (number) angle in degrees\n\t     - cx (number) #optional x coordinate of the centre of rotation\n\t     - cy (number) #optional y coordinate of the centre of rotation\n\t     * If cx & cy arent specified centre of the shape is used as a point of rotation.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.rotate = function (deg, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        deg = Str(deg).split(separator);\n\t        if (deg.length - 1) {\n\t            cx = toFloat(deg[1]);\n\t            cy = toFloat(deg[2]);\n\t        }\n\t        deg = toFloat(deg[0]);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t            cx = bbox.x + bbox.width / 2;\n\t            cy = bbox.y + bbox.height / 2;\n\t        }\n\t        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.scale\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds scale by given amount relative to given point to the list of\n\t     * transformations of the element.\n\t     > Parameters\n\t     - sx (number) horisontal scale amount\n\t     - sy (number) vertical scale amount\n\t     - cx (number) #optional x coordinate of the centre of scale\n\t     - cy (number) #optional y coordinate of the centre of scale\n\t     * If cx & cy arent specified centre of the shape is used instead.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.scale = function (sx, sy, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        sx = Str(sx).split(separator);\n\t        if (sx.length - 1) {\n\t            sy = toFloat(sx[1]);\n\t            cx = toFloat(sx[2]);\n\t            cy = toFloat(sx[3]);\n\t        }\n\t        sx = toFloat(sx[0]);\n\t        (sy == null) && (sy = sx);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t        }\n\t        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n\t        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n\t        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.translate\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds translation by given amount to the list of transformations of the element.\n\t     > Parameters\n\t     - dx (number) horisontal shift\n\t     - dy (number) vertical shift\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.translate = function (dx, dy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        dx = Str(dx).split(separator);\n\t        if (dx.length - 1) {\n\t            dy = toFloat(dx[1]);\n\t        }\n\t        dx = toFloat(dx[0]) || 0;\n\t        dy = +dy || 0;\n\t        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.transform\n\t     [ method ]\n\t     **\n\t     * Adds transformation to the element which is separate to other attributes,\n\t     * i.e. translation doesnt change `x` or `y` of the rectange. The format\n\t     * of transformation string is similar to the path string syntax:\n\t     | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\n\t     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\n\t     * scale and `m` is for matrix.\n\t     *\n\t     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\n\t     *\n\t     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;\n\t     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin\n\t     * coordinates as optional parameters, the default is the centre point of the element.\n\t     * Matrix accepts six parameters.\n\t     > Usage\n\t     | var el = paper.rect(10, 20, 300, 200);\n\t     | // translate 100, 100, rotate 45, translate -100, 0\n\t     | el.transform(\"t100,100r45t-100,0\");\n\t     | // if you want you can append or prepend transformations\n\t     | el.transform(\"...t50,50\");\n\t     | el.transform(\"s2...\");\n\t     | // or even wrap\n\t     | el.transform(\"t50,50...t-50-50\");\n\t     | // to reset transformation call method with empty string\n\t     | el.transform(\"\");\n\t     | // to get current value call it without parameters\n\t     | console.log(el.transform());\n\t     > Parameters\n\t     - tstr (string) #optional transformation string\n\t     * If tstr isnt specified\n\t     = (string) current transformation string\n\t     * else\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.transform = function (tstr) {\n\t        var _ = this._;\n\t        if (tstr == null) {\n\t            return _.transform;\n\t        }\n\t        R._extractTransform(this, tstr);\n\n\t        this.clip && $(this.clip, {transform: this.matrix.invert()});\n\t        this.pattern && updatePosition(this);\n\t        this.node && $(this.node, {transform: this.matrix});\n\n\t        if (_.sx != 1 || _.sy != 1) {\n\t            var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\n\t            this.attr({\"stroke-width\": sw});\n\t        }\n\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.hide\n\t     [ method ]\n\t     **\n\t     * Makes element invisible. See @Element.show.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hide = function () {\n\t        if(!this.removed) this.node.style.display = \"none\";\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.show\n\t     [ method ]\n\t     **\n\t     * Makes element visible. See @Element.hide.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.show = function () {\n\t        if(!this.removed) this.node.style.display = \"\";\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.remove\n\t     [ method ]\n\t     **\n\t     * Removes element from the paper.\n\t    \\*/\n\t    elproto.remove = function () {\n\t        var node = getRealNode(this.node);\n\t        if (this.removed || !node.parentNode) {\n\t            return;\n\t        }\n\t        var paper = this.paper;\n\t        paper.__set__ && paper.__set__.exclude(this);\n\t        eve.unbind(\"raphael.*.*.\" + this.id);\n\t        if (this.gradient) {\n\t            paper.defs.removeChild(this.gradient);\n\t        }\n\t        R._tear(this, paper);\n\n\t        node.parentNode.removeChild(node);\n\n\t        // Remove custom data for element\n\t        this.removeData();\n\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        this.removed = true;\n\t    };\n\t    elproto._getBBox = function () {\n\t        if (this.node.style.display == \"none\") {\n\t            this.show();\n\t            var hide = true;\n\t        }\n\t        var canvasHidden = false,\n\t            containerStyle;\n\t        if (this.paper.canvas.parentElement) {\n\t          containerStyle = this.paper.canvas.parentElement.style;\n\t        } //IE10+ can't find parentElement\n\t        else if (this.paper.canvas.parentNode) {\n\t          containerStyle = this.paper.canvas.parentNode.style;\n\t        }\n\n\t        if(containerStyle && containerStyle.display == \"none\") {\n\t          canvasHidden = true;\n\t          containerStyle.display = \"\";\n\t        }\n\t        var bbox = {};\n\t        try {\n\t            bbox = this.node.getBBox();\n\t        } catch(e) {\n\t            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\n\t            bbox = {\n\t                x: this.node.clientLeft,\n\t                y: this.node.clientTop,\n\t                width: this.node.clientWidth,\n\t                height: this.node.clientHeight\n\t            }\n\t        } finally {\n\t            bbox = bbox || {};\n\t            if(canvasHidden){\n\t              containerStyle.display = \"none\";\n\t            }\n\t        }\n\t        hide && this.hide();\n\t        return bbox;\n\t    };\n\t    /*\\\n\t     * Element.attr\n\t     [ method ]\n\t     **\n\t     * Sets the attributes of the element.\n\t     > Parameters\n\t     - attrName (string) attributes name\n\t     - value (string) value\n\t     * or\n\t     - params (object) object of name/value pairs\n\t     * or\n\t     - attrName (string) attributes name\n\t     * or\n\t     - attrNames (array) in this case method returns array of current values for given attribute names\n\t     = (object) @Element if attrsName & value or params are passed in.\n\t     = (...) value of the attribute if only attrsName is passed in.\n\t     = (array) array of values of the attribute if attrsNames is passed in.\n\t     = (object) object of attributes if nothing is passed in.\n\t     > Possible parameters\n\t     # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\n\t     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\n\t     o clip-rect (string) comma or space separated values: x, y, width and height\n\t     o cursor (string) CSS type of the cursor\n\t     o cx (number) the x-axis coordinate of the center of the circle, or ellipse\n\t     o cy (number) the y-axis coordinate of the center of the circle, or ellipse\n\t     o fill (string) colour, gradient or image\n\t     o fill-opacity (number)\n\t     o font (string)\n\t     o font-family (string)\n\t     o font-size (number) font size in pixels\n\t     o font-weight (string)\n\t     o height (number)\n\t     o href (string) URL, if specified element behaves as hyperlink\n\t     o opacity (number)\n\t     o path (string) SVG path string format\n\t     o r (number) radius of the circle, ellipse or rounded corner on the rect\n\t     o rx (number) horisontal radius of the ellipse\n\t     o ry (number) vertical radius of the ellipse\n\t     o src (string) image URL, only works for @Element.image element\n\t     o stroke (string) stroke colour\n\t     o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]\n\t     o stroke-linecap (string) [`butt`, `square`, `round`]\n\t     o stroke-linejoin (string) [`bevel`, `round`, `miter`]\n\t     o stroke-miterlimit (number)\n\t     o stroke-opacity (number)\n\t     o stroke-width (number) stroke width in pixels, default is '1'\n\t     o target (string) used with href\n\t     o text (string) contents of the text element. Use `\\n` for multiline text\n\t     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`\n\t     o title (string) will create tooltip with a given text\n\t     o transform (string) see @Element.transform\n\t     o width (number)\n\t     o x (number)\n\t     o y (number)\n\t     > Gradients\n\t     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90\n\t     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.\n\t     *\n\t     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` \n\t     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point\n\t     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\n\t     > Path String\n\t     # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a paths data attributes format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphal fully supports it.</p>\n\t     > Colour Parsing\n\t     # <ul>\n\t     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n\t     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>\n\t     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>\n\t     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t     #     <li>hsb(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsba(, , , )  same as above, but with opacity</li>\n\t     #     <li>hsl(, , )  almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\n\t     #     <li>hsl(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsla(, , , )  same as above, but with opacity</li>\n\t     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>\n\t     # </ul>\n\t    \\*/\n\t    elproto.attr = function (name, value) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (name == null) {\n\t            var res = {};\n\t            for (var a in this.attrs) if (this.attrs[has](a)) {\n\t                res[a] = this.attrs[a];\n\t            }\n\t            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n\t            res.transform = this._.transform;\n\t            return res;\n\t        }\n\t        if (value == null && R.is(name, \"string\")) {\n\t            if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\n\t                return this.attrs.gradient;\n\t            }\n\t            if (name == \"transform\") {\n\t                return this._.transform;\n\t            }\n\t            var names = name.split(separator),\n\t                out = {};\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                name = names[i];\n\t                if (name in this.attrs) {\n\t                    out[name] = this.attrs[name];\n\t                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n\t                    out[name] = this.paper.customAttributes[name].def;\n\t                } else {\n\t                    out[name] = R._availableAttrs[name];\n\t                }\n\t            }\n\t            return ii - 1 ? out : out[names[0]];\n\t        }\n\t        if (value == null && R.is(name, \"array\")) {\n\t            out = {};\n\t            for (i = 0, ii = name.length; i < ii; i++) {\n\t                out[name[i]] = this.attr(name[i]);\n\t            }\n\t            return out;\n\t        }\n\t        if (value != null) {\n\t            var params = {};\n\t            params[name] = value;\n\t        } else if (name != null && R.is(name, \"object\")) {\n\t            params = name;\n\t        }\n\t        for (var key in params) {\n\t            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n\t        }\n\t        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n\t            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n\t            this.attrs[key] = params[key];\n\t            for (var subkey in par) if (par[has](subkey)) {\n\t                params[subkey] = par[subkey];\n\t            }\n\t        }\n\t        setFillAndStroke(this, params);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toFront\n\t     [ method ]\n\t     **\n\t     * Moves the element so it is the closest to the viewers eyes, on top of other elements.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.toFront = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        var node = getRealNode(this.node);\n\t        node.parentNode.appendChild(node);\n\t        var svg = this.paper;\n\t        svg.top != this && R._tofront(this, svg);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toBack\n\t     [ method ]\n\t     **\n\t     * Moves the element so it is the furthest from the viewers eyes, behind other elements.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.toBack = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        var node = getRealNode(this.node);\n\t        var parentNode = node.parentNode;\n\t        parentNode.insertBefore(node, parentNode.firstChild);\n\t        R._toback(this, this.paper);\n\t        var svg = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertAfter\n\t     [ method ]\n\t     **\n\t     * Inserts current object after the given one.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.insertAfter = function (element) {\n\t        if (this.removed || !element) {\n\t            return this;\n\t        }\n\n\t        var node = getRealNode(this.node);\n\t        var afterNode = getRealNode(element.node || element[element.length - 1].node);\n\t        if (afterNode.nextSibling) {\n\t            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\n\t        } else {\n\t            afterNode.parentNode.appendChild(node);\n\t        }\n\t        R._insertafter(this, element, this.paper);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertBefore\n\t     [ method ]\n\t     **\n\t     * Inserts current object before the given one.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.insertBefore = function (element) {\n\t        if (this.removed || !element) {\n\t            return this;\n\t        }\n\n\t        var node = getRealNode(this.node);\n\t        var beforeNode = getRealNode(element.node || element[0].node);\n\t        beforeNode.parentNode.insertBefore(node, beforeNode);\n\t        R._insertbefore(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.blur = function (size) {\n\t        // Experimental. No Safari support. Use it on your own risk.\n\t        var t = this;\n\t        if (+size !== 0) {\n\t            var fltr = $(\"filter\"),\n\t                blur = $(\"feGaussianBlur\");\n\t            t.attrs.blur = size;\n\t            fltr.id = R.createUUID();\n\t            $(blur, {stdDeviation: +size || 1.5});\n\t            fltr.appendChild(blur);\n\t            t.paper.defs.appendChild(fltr);\n\t            t._blur = fltr;\n\t            $(t.node, {filter: \"url(#\" + fltr.id + \")\"});\n\t        } else {\n\t            if (t._blur) {\n\t                t._blur.parentNode.removeChild(t._blur);\n\t                delete t._blur;\n\t                delete t.attrs.blur;\n\t            }\n\t            t.node.removeAttribute(\"filter\");\n\t        }\n\t        return t;\n\t    };\n\t    R._engine.circle = function (svg, x, y, r) {\n\t        var el = $(\"circle\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {cx: x, cy: y, r: r, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"circle\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.rect = function (svg, x, y, w, h, r) {\n\t        var el = $(\"rect\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"rect\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.ellipse = function (svg, x, y, rx, ry) {\n\t        var el = $(\"ellipse\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"ellipse\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.image = function (svg, src, x, y, w, h) {\n\t        var el = $(\"image\");\n\t        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: \"none\"});\n\t        el.setAttributeNS(xlink, \"href\", src);\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {x: x, y: y, width: w, height: h, src: src};\n\t        res.type = \"image\";\n\t        return res;\n\t    };\n\t    R._engine.text = function (svg, x, y, text) {\n\t        var el = $(\"text\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {\n\t            x: x,\n\t            y: y,\n\t            \"text-anchor\": \"middle\",\n\t            text: text,\n\t            \"font-family\": R._availableAttrs[\"font-family\"],\n\t            \"font-size\": R._availableAttrs[\"font-size\"],\n\t            stroke: \"none\",\n\t            fill: \"#000\"\n\t        };\n\t        res.type = \"text\";\n\t        setFillAndStroke(res, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.setSize = function (width, height) {\n\t        this.width = width || this.width;\n\t        this.height = height || this.height;\n\t        this.canvas.setAttribute(\"width\", this.width);\n\t        this.canvas.setAttribute(\"height\", this.height);\n\t        if (this._viewBox) {\n\t            this.setViewBox.apply(this, this._viewBox);\n\t        }\n\t        return this;\n\t    };\n\t    R._engine.create = function () {\n\t        var con = R._getContainer.apply(0, arguments),\n\t            container = con && con.container,\n\t            x = con.x,\n\t            y = con.y,\n\t            width = con.width,\n\t            height = con.height;\n\t        if (!container) {\n\t            throw new Error(\"SVG container not found.\");\n\t        }\n\t        var cnvs = $(\"svg\"),\n\t            css = \"overflow:hidden;\",\n\t            isFloating;\n\t        x = x || 0;\n\t        y = y || 0;\n\t        width = width || 512;\n\t        height = height || 342;\n\t        $(cnvs, {\n\t            height: height,\n\t            version: 1.1,\n\t            width: width,\n\t            xmlns: \"http://www.w3.org/2000/svg\",\n\t            \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n\t        });\n\t        if (container == 1) {\n\t            cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\n\t            R._g.doc.body.appendChild(cnvs);\n\t            isFloating = 1;\n\t        } else {\n\t            cnvs.style.cssText = css + \"position:relative\";\n\t            if (container.firstChild) {\n\t                container.insertBefore(cnvs, container.firstChild);\n\t            } else {\n\t                container.appendChild(cnvs);\n\t            }\n\t        }\n\t        container = new R._Paper;\n\t        container.width = width;\n\t        container.height = height;\n\t        container.canvas = cnvs;\n\t        container.clear();\n\t        container._left = container._top = 0;\n\t        isFloating && (container.renderfix = function () {});\n\t        container.renderfix();\n\t        return container;\n\t    };\n\t    R._engine.setViewBox = function (x, y, w, h, fit) {\n\t        eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n\t        var paperSize = this.getSize(),\n\t            size = mmax(w / paperSize.width, h / paperSize.height),\n\t            top = this.top,\n\t            aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\n\t            vb,\n\t            sw;\n\t        if (x == null) {\n\t            if (this._vbSize) {\n\t                size = 1;\n\t            }\n\t            delete this._vbSize;\n\t            vb = \"0 0 \" + this.width + S + this.height;\n\t        } else {\n\t            this._vbSize = size;\n\t            vb = x + S + y + S + w + S + h;\n\t        }\n\t        $(this.canvas, {\n\t            viewBox: vb,\n\t            preserveAspectRatio: aspectRatio\n\t        });\n\t        while (size && top) {\n\t            sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\n\t            top.attr({\"stroke-width\": sw});\n\t            top._.dirty = 1;\n\t            top._.dirtyT = 1;\n\t            top = top.prev;\n\t        }\n\t        this._viewBox = [x, y, w, h, !!fit];\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Paper.renderfix\n\t     [ method ]\n\t     **\n\t     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent\n\t     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\n\t     * This method fixes the issue.\n\t     **\n\t       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\n\t    \\*/\n\t    R.prototype.renderfix = function () {\n\t        var cnvs = this.canvas,\n\t            s = cnvs.style,\n\t            pos;\n\t        try {\n\t            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\n\t        } catch (e) {\n\t            pos = cnvs.createSVGMatrix();\n\t        }\n\t        var left = -pos.e % 1,\n\t            top = -pos.f % 1;\n\t        if (left || top) {\n\t            if (left) {\n\t                this._left = (this._left + left) % 1;\n\t                s.left = this._left + \"px\";\n\t            }\n\t            if (top) {\n\t                this._top = (this._top + top) % 1;\n\t                s.top = this._top + \"px\";\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * Paper.clear\n\t     [ method ]\n\t     **\n\t     * Clears the paper, i.e. removes all the elements.\n\t    \\*/\n\t    R.prototype.clear = function () {\n\t        R.eve(\"raphael.clear\", this);\n\t        var c = this.canvas;\n\t        while (c.firstChild) {\n\t            c.removeChild(c.firstChild);\n\t        }\n\t        this.bottom = this.top = null;\n\t        (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\n\t        c.appendChild(this.desc);\n\t        c.appendChild(this.defs = $(\"defs\"));\n\t    };\n\t    /*\\\n\t     * Paper.remove\n\t     [ method ]\n\t     **\n\t     * Removes the paper from the DOM.\n\t    \\*/\n\t    R.prototype.remove = function () {\n\t        eve(\"raphael.remove\", this);\n\t        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t    };\n\t    var setproto = R.st;\n\t    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname].apply(el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\t    if (R && !R.vml) {\n\t        return;\n\t    }\n\n\t    var has = \"hasOwnProperty\",\n\t        Str = String,\n\t        toFloat = parseFloat,\n\t        math = Math,\n\t        round = math.round,\n\t        mmax = math.max,\n\t        mmin = math.min,\n\t        abs = math.abs,\n\t        fillString = \"fill\",\n\t        separator = /[, ]+/,\n\t        eve = R.eve,\n\t        ms = \" progid:DXImageTransform.Microsoft\",\n\t        S = \" \",\n\t        E = \"\",\n\t        map = {M: \"m\", L: \"l\", C: \"c\", Z: \"x\", m: \"t\", l: \"r\", c: \"v\", z: \"x\"},\n\t        bites = /([clmz]),?([^clmz]*)/gi,\n\t        blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\n\t        val = /-?[^,\\s-]+/g,\n\t        cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\n\t        zoom = 21600,\n\t        pathTypes = {path: 1, rect: 1, image: 1},\n\t        ovalTypes = {circle: 1, ellipse: 1},\n\t        path2vml = function (path) {\n\t            var total =  /[ahqstv]/ig,\n\t                command = R._pathToAbsolute;\n\t            Str(path).match(total) && (command = R._path2curve);\n\t            total = /[clmz]/g;\n\t            if (command == R._pathToAbsolute && !Str(path).match(total)) {\n\t                var res = Str(path).replace(bites, function (all, command, args) {\n\t                    var vals = [],\n\t                        isMove = command.toLowerCase() == \"m\",\n\t                        res = map[command];\n\t                    args.replace(val, function (value) {\n\t                        if (isMove && vals.length == 2) {\n\t                            res += vals + map[command == \"m\" ? \"l\" : \"L\"];\n\t                            vals = [];\n\t                        }\n\t                        vals.push(round(value * zoom));\n\t                    });\n\t                    return res + vals;\n\t                });\n\t                return res;\n\t            }\n\t            var pa = command(path), p, r;\n\t            res = [];\n\t            for (var i = 0, ii = pa.length; i < ii; i++) {\n\t                p = pa[i];\n\t                r = pa[i][0].toLowerCase();\n\t                r == \"z\" && (r = \"x\");\n\t                for (var j = 1, jj = p.length; j < jj; j++) {\n\t                    r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\n\t                }\n\t                res.push(r);\n\t            }\n\t            return res.join(S);\n\t        },\n\t        compensation = function (deg, dx, dy) {\n\t            var m = R.matrix();\n\t            m.rotate(-deg, .5, .5);\n\t            return {\n\t                dx: m.x(dx, dy),\n\t                dy: m.y(dx, dy)\n\t            };\n\t        },\n\t        setCoords = function (p, sx, sy, dx, dy, deg) {\n\t            var _ = p._,\n\t                m = p.matrix,\n\t                fillpos = _.fillpos,\n\t                o = p.node,\n\t                s = o.style,\n\t                y = 1,\n\t                flip = \"\",\n\t                dxdy,\n\t                kx = zoom / sx,\n\t                ky = zoom / sy;\n\t            s.visibility = \"hidden\";\n\t            if (!sx || !sy) {\n\t                return;\n\t            }\n\t            o.coordsize = abs(kx) + S + abs(ky);\n\t            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\n\t            if (deg) {\n\t                var c = compensation(deg, dx, dy);\n\t                dx = c.dx;\n\t                dy = c.dy;\n\t            }\n\t            sx < 0 && (flip += \"x\");\n\t            sy < 0 && (flip += \" y\") && (y = -1);\n\t            s.flip = flip;\n\t            o.coordorigin = (dx * -kx) + S + (dy * -ky);\n\t            if (fillpos || _.fillsize) {\n\t                var fill = o.getElementsByTagName(fillString);\n\t                fill = fill && fill[0];\n\t                o.removeChild(fill);\n\t                if (fillpos) {\n\t                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\n\t                    fill.position = c.dx * y + S + c.dy * y;\n\t                }\n\t                if (_.fillsize) {\n\t                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\n\t                }\n\t                o.appendChild(fill);\n\t            }\n\t            s.visibility = \"visible\";\n\t        };\n\t    R.toString = function () {\n\t        return  \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xebl \" + this.version;\n\t    };\n\t    var addArrow = function (o, value, isEnd) {\n\t        var values = Str(value).toLowerCase().split(\"-\"),\n\t            se = isEnd ? \"end\" : \"start\",\n\t            i = values.length,\n\t            type = \"classic\",\n\t            w = \"medium\",\n\t            h = \"medium\";\n\t        while (i--) {\n\t            switch (values[i]) {\n\t                case \"block\":\n\t                case \"classic\":\n\t                case \"oval\":\n\t                case \"diamond\":\n\t                case \"open\":\n\t                case \"none\":\n\t                    type = values[i];\n\t                    break;\n\t                case \"wide\":\n\t                case \"narrow\": h = values[i]; break;\n\t                case \"long\":\n\t                case \"short\": w = values[i]; break;\n\t            }\n\t        }\n\t        var stroke = o.node.getElementsByTagName(\"stroke\")[0];\n\t        stroke[se + \"arrow\"] = type;\n\t        stroke[se + \"arrowlength\"] = w;\n\t        stroke[se + \"arrowwidth\"] = h;\n\t    },\n\t    setFillAndStroke = function (o, params) {\n\t        // o.paper.canvas.style.display = \"none\";\n\t        o.attrs = o.attrs || {};\n\t        var node = o.node,\n\t            a = o.attrs,\n\t            s = node.style,\n\t            xy,\n\t            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\n\t            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\n\t            res = o;\n\n\n\t        for (var par in params) if (params[has](par)) {\n\t            a[par] = params[par];\n\t        }\n\t        if (newpath) {\n\t            a.path = R._getPath[o.type](o);\n\t            o._.dirty = 1;\n\t        }\n\t        params.href && (node.href = params.href);\n\t        params.title && (node.title = params.title);\n\t        params.target && (node.target = params.target);\n\t        params.cursor && (s.cursor = params.cursor);\n\t        \"blur\" in params && o.blur(params.blur);\n\t        if (params.path && o.type == \"path\" || newpath) {\n\t            node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\n\t            o._.dirty = 1;\n\t            if (o.type == \"image\") {\n\t                o._.fillpos = [a.x, a.y];\n\t                o._.fillsize = [a.width, a.height];\n\t                setCoords(o, 1, 1, 0, 0, 0);\n\t            }\n\t        }\n\t        \"transform\" in params && o.transform(params.transform);\n\t        if (isOval) {\n\t            var cx = +a.cx,\n\t                cy = +a.cy,\n\t                rx = +a.rx || +a.r || 0,\n\t                ry = +a.ry || +a.r || 0;\n\t            node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\n\t            o._.dirty = 1;\n\t        }\n\t        if (\"clip-rect\" in params) {\n\t            var rect = Str(params[\"clip-rect\"]).split(separator);\n\t            if (rect.length == 4) {\n\t                rect[2] = +rect[2] + (+rect[0]);\n\t                rect[3] = +rect[3] + (+rect[1]);\n\t                var div = node.clipRect || R._g.doc.createElement(\"div\"),\n\t                    dstyle = div.style;\n\t                dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\n\t                if (!node.clipRect) {\n\t                    dstyle.position = \"absolute\";\n\t                    dstyle.top = 0;\n\t                    dstyle.left = 0;\n\t                    dstyle.width = o.paper.width + \"px\";\n\t                    dstyle.height = o.paper.height + \"px\";\n\t                    node.parentNode.insertBefore(div, node);\n\t                    div.appendChild(node);\n\t                    node.clipRect = div;\n\t                }\n\t            }\n\t            if (!params[\"clip-rect\"]) {\n\t                node.clipRect && (node.clipRect.style.clip = \"auto\");\n\t            }\n\t        }\n\t        if (o.textpath) {\n\t            var textpathStyle = o.textpath.style;\n\t            params.font && (textpathStyle.font = params.font);\n\t            params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\n\t            params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\n\t            params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\n\t            params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\n\t        }\n\t        if (\"arrow-start\" in params) {\n\t            addArrow(res, params[\"arrow-start\"]);\n\t        }\n\t        if (\"arrow-end\" in params) {\n\t            addArrow(res, params[\"arrow-end\"], 1);\n\t        }\n\t        if (params.opacity != null ||\n\t            params.fill != null ||\n\t            params.src != null ||\n\t            params.stroke != null ||\n\t            params[\"stroke-width\"] != null ||\n\t            params[\"stroke-opacity\"] != null ||\n\t            params[\"fill-opacity\"] != null ||\n\t            params[\"stroke-dasharray\"] != null ||\n\t            params[\"stroke-miterlimit\"] != null ||\n\t            params[\"stroke-linejoin\"] != null ||\n\t            params[\"stroke-linecap\"] != null) {\n\t            var fill = node.getElementsByTagName(fillString),\n\t                newfill = false;\n\t            fill = fill && fill[0];\n\t            !fill && (newfill = fill = createNode(fillString));\n\t            if (o.type == \"image\" && params.src) {\n\t                fill.src = params.src;\n\t            }\n\t            params.fill && (fill.on = true);\n\t            if (fill.on == null || params.fill == \"none\" || params.fill === null) {\n\t                fill.on = false;\n\t            }\n\t            if (fill.on && params.fill) {\n\t                var isURL = Str(params.fill).match(R._ISURL);\n\t                if (isURL) {\n\t                    fill.parentNode == node && node.removeChild(fill);\n\t                    fill.rotate = true;\n\t                    fill.src = isURL[1];\n\t                    fill.type = \"tile\";\n\t                    var bbox = o.getBBox(1);\n\t                    fill.position = bbox.x + S + bbox.y;\n\t                    o._.fillpos = [bbox.x, bbox.y];\n\n\t                    R._preload(isURL[1], function () {\n\t                        o._.fillsize = [this.offsetWidth, this.offsetHeight];\n\t                    });\n\t                } else {\n\t                    fill.color = R.getRGB(params.fill).hex;\n\t                    fill.src = E;\n\t                    fill.type = \"solid\";\n\t                    if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\n\t                        a.fill = \"none\";\n\t                        a.gradient = params.fill;\n\t                        fill.rotate = false;\n\t                    }\n\t                }\n\t            }\n\t            if (\"fill-opacity\" in params || \"opacity\" in params) {\n\t                var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\n\t                opacity = mmin(mmax(opacity, 0), 1);\n\t                fill.opacity = opacity;\n\t                if (fill.src) {\n\t                    fill.color = \"none\";\n\t                }\n\t            }\n\t            node.appendChild(fill);\n\t            var stroke = (node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0]),\n\t            newstroke = false;\n\t            !stroke && (newstroke = stroke = createNode(\"stroke\"));\n\t            if ((params.stroke && params.stroke != \"none\") ||\n\t                params[\"stroke-width\"] ||\n\t                params[\"stroke-opacity\"] != null ||\n\t                params[\"stroke-dasharray\"] ||\n\t                params[\"stroke-miterlimit\"] ||\n\t                params[\"stroke-linejoin\"] ||\n\t                params[\"stroke-linecap\"]) {\n\t                stroke.on = true;\n\t            }\n\t            (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\n\t            var strokeColor = R.getRGB(params.stroke);\n\t            stroke.on && params.stroke && (stroke.color = strokeColor.hex);\n\t            opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\n\t            var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\n\t            opacity = mmin(mmax(opacity, 0), 1);\n\t            params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\n\t            params[\"stroke-width\"] && (stroke.weight = width);\n\t            width && width < 1 && (opacity *= width) && (stroke.weight = 1);\n\t            stroke.opacity = opacity;\n\n\t            params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\n\t            stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\n\t            params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\n\t            if (\"stroke-dasharray\" in params) {\n\t                var dasharray = {\n\t                    \"-\": \"shortdash\",\n\t                    \".\": \"shortdot\",\n\t                    \"-.\": \"shortdashdot\",\n\t                    \"-..\": \"shortdashdotdot\",\n\t                    \". \": \"dot\",\n\t                    \"- \": \"dash\",\n\t                    \"--\": \"longdash\",\n\t                    \"- .\": \"dashdot\",\n\t                    \"--.\": \"longdashdot\",\n\t                    \"--..\": \"longdashdotdot\"\n\t                };\n\t                stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\n\t            }\n\t            newstroke && node.appendChild(stroke);\n\t        }\n\t        if (res.type == \"text\") {\n\t            res.paper.canvas.style.display = E;\n\t            var span = res.paper.span,\n\t                m = 100,\n\t                fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\n\t            s = span.style;\n\t            a.font && (s.font = a.font);\n\t            a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\n\t            a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\n\t            a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\n\t            fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\n\t            s.fontSize = fontSize * m + \"px\";\n\t            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\n\t            var brect = span.getBoundingClientRect();\n\t            res.W = a.w = (brect.right - brect.left) / m;\n\t            res.H = a.h = (brect.bottom - brect.top) / m;\n\t            // res.paper.canvas.style.display = \"none\";\n\t            res.X = a.x;\n\t            res.Y = a.y + res.H / 2;\n\n\t            (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\n\t            var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\n\t            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {\n\t                res._.dirty = 1;\n\t                break;\n\t            }\n\n\t            // text-anchor emulation\n\t            switch (a[\"text-anchor\"]) {\n\t                case \"start\":\n\t                    res.textpath.style[\"v-text-align\"] = \"left\";\n\t                    res.bbx = res.W / 2;\n\t                break;\n\t                case \"end\":\n\t                    res.textpath.style[\"v-text-align\"] = \"right\";\n\t                    res.bbx = -res.W / 2;\n\t                break;\n\t                default:\n\t                    res.textpath.style[\"v-text-align\"] = \"center\";\n\t                    res.bbx = 0;\n\t                break;\n\t            }\n\t            res.textpath.style[\"v-text-kern\"] = true;\n\t        }\n\t        // res.paper.canvas.style.display = E;\n\t    },\n\t    addGradientFill = function (o, gradient, fill) {\n\t        o.attrs = o.attrs || {};\n\t        var attrs = o.attrs,\n\t            pow = Math.pow,\n\t            opacity,\n\t            oindex,\n\t            type = \"linear\",\n\t            fxfy = \".5 .5\";\n\t        o.attrs.gradient = gradient;\n\t        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\n\t            type = \"radial\";\n\t            if (fx && fy) {\n\t                fx = toFloat(fx);\n\t                fy = toFloat(fy);\n\t                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\n\t                fxfy = fx + S + fy;\n\t            }\n\t            return E;\n\t        });\n\t        gradient = gradient.split(/\\s*\\-\\s*/);\n\t        if (type == \"linear\") {\n\t            var angle = gradient.shift();\n\t            angle = -toFloat(angle);\n\t            if (isNaN(angle)) {\n\t                return null;\n\t            }\n\t        }\n\t        var dots = R._parseDots(gradient);\n\t        if (!dots) {\n\t            return null;\n\t        }\n\t        o = o.shape || o.node;\n\t        if (dots.length) {\n\t            o.removeChild(fill);\n\t            fill.on = true;\n\t            fill.method = \"none\";\n\t            fill.color = dots[0].color;\n\t            fill.color2 = dots[dots.length - 1].color;\n\t            var clrs = [];\n\t            for (var i = 0, ii = dots.length; i < ii; i++) {\n\t                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\n\t            }\n\t            fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\n\t            if (type == \"radial\") {\n\t                fill.type = \"gradientTitle\";\n\t                fill.focus = \"100%\";\n\t                fill.focussize = \"0 0\";\n\t                fill.focusposition = fxfy;\n\t                fill.angle = 0;\n\t            } else {\n\t                // fill.rotate= true;\n\t                fill.type = \"gradient\";\n\t                fill.angle = (270 - angle) % 360;\n\t            }\n\t            o.appendChild(fill);\n\t        }\n\t        return 1;\n\t    },\n\t    Element = function (node, vml) {\n\t        this[0] = this.node = node;\n\t        node.raphael = true;\n\t        this.id = R._oid++;\n\t        node.raphaelid = this.id;\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.attrs = {};\n\t        this.paper = vml;\n\t        this.matrix = R.matrix();\n\t        this._ = {\n\t            transform: [],\n\t            sx: 1,\n\t            sy: 1,\n\t            dx: 0,\n\t            dy: 0,\n\t            deg: 0,\n\t            dirty: 1,\n\t            dirtyT: 1\n\t        };\n\t        !vml.bottom && (vml.bottom = this);\n\t        this.prev = vml.top;\n\t        vml.top && (vml.top.next = this);\n\t        vml.top = this;\n\t        this.next = null;\n\t    };\n\t    var elproto = R.el;\n\n\t    Element.prototype = elproto;\n\t    elproto.constructor = Element;\n\t    elproto.transform = function (tstr) {\n\t        if (tstr == null) {\n\t            return this._.transform;\n\t        }\n\t        var vbs = this.paper._viewBoxShift,\n\t            vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\n\t            oldt;\n\t        if (vbs) {\n\t            oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\n\t        }\n\t        R._extractTransform(this, vbt + tstr);\n\t        var matrix = this.matrix.clone(),\n\t            skew = this.skew,\n\t            o = this.node,\n\t            split,\n\t            isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\n\t            isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\n\t        matrix.translate(1, 1);\n\t        if (isPatt || isGrad || this.type == \"image\") {\n\t            skew.matrix = \"1 0 0 1\";\n\t            skew.offset = \"0 0\";\n\t            split = matrix.split();\n\t            if ((isGrad && split.noRotation) || !split.isSimple) {\n\t                o.style.filter = matrix.toFilter();\n\t                var bb = this.getBBox(),\n\t                    bbt = this.getBBox(1),\n\t                    dx = bb.x - bbt.x,\n\t                    dy = bb.y - bbt.y;\n\t                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);\n\t                setCoords(this, 1, 1, dx, dy, 0);\n\t            } else {\n\t                o.style.filter = E;\n\t                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\n\t            }\n\t        } else {\n\t            o.style.filter = E;\n\t            skew.matrix = Str(matrix);\n\t            skew.offset = matrix.offset();\n\t        }\n\t        if (oldt !== null) { // empty string value is true as well\n\t            this._.transform = oldt;\n\t            R._extractTransform(this, oldt);\n\t        }\n\t        return this;\n\t    };\n\t    elproto.rotate = function (deg, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (deg == null) {\n\t            return;\n\t        }\n\t        deg = Str(deg).split(separator);\n\t        if (deg.length - 1) {\n\t            cx = toFloat(deg[1]);\n\t            cy = toFloat(deg[2]);\n\t        }\n\t        deg = toFloat(deg[0]);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t            cx = bbox.x + bbox.width / 2;\n\t            cy = bbox.y + bbox.height / 2;\n\t        }\n\t        this._.dirtyT = 1;\n\t        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n\t        return this;\n\t    };\n\t    elproto.translate = function (dx, dy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        dx = Str(dx).split(separator);\n\t        if (dx.length - 1) {\n\t            dy = toFloat(dx[1]);\n\t        }\n\t        dx = toFloat(dx[0]) || 0;\n\t        dy = +dy || 0;\n\t        if (this._.bbox) {\n\t            this._.bbox.x += dx;\n\t            this._.bbox.y += dy;\n\t        }\n\t        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n\t        return this;\n\t    };\n\t    elproto.scale = function (sx, sy, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        sx = Str(sx).split(separator);\n\t        if (sx.length - 1) {\n\t            sy = toFloat(sx[1]);\n\t            cx = toFloat(sx[2]);\n\t            cy = toFloat(sx[3]);\n\t            isNaN(cx) && (cx = null);\n\t            isNaN(cy) && (cy = null);\n\t        }\n\t        sx = toFloat(sx[0]);\n\t        (sy == null) && (sy = sx);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t        }\n\t        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n\t        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n\n\t        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n\t        this._.dirtyT = 1;\n\t        return this;\n\t    };\n\t    elproto.hide = function () {\n\t        !this.removed && (this.node.style.display = \"none\");\n\t        return this;\n\t    };\n\t    elproto.show = function () {\n\t        !this.removed && (this.node.style.display = E);\n\t        return this;\n\t    };\n\t    // Needed to fix the vml setViewBox issues\n\t    elproto.auxGetBBox = R.el.getBBox;\n\t    elproto.getBBox = function(){\n\t      var b = this.auxGetBBox();\n\t      if (this.paper && this.paper._viewBoxShift)\n\t      {\n\t        var c = {};\n\t        var z = 1/this.paper._viewBoxShift.scale;\n\t        c.x = b.x - this.paper._viewBoxShift.dx;\n\t        c.x *= z;\n\t        c.y = b.y - this.paper._viewBoxShift.dy;\n\t        c.y *= z;\n\t        c.width  = b.width  * z;\n\t        c.height = b.height * z;\n\t        c.x2 = c.x + c.width;\n\t        c.y2 = c.y + c.height;\n\t        return c;\n\t      }\n\t      return b;\n\t    };\n\t    elproto._getBBox = function () {\n\t        if (this.removed) {\n\t            return {};\n\t        }\n\t        return {\n\t            x: this.X + (this.bbx || 0) - this.W / 2,\n\t            y: this.Y - this.H,\n\t            width: this.W,\n\t            height: this.H\n\t        };\n\t    };\n\t    elproto.remove = function () {\n\t        if (this.removed || !this.node.parentNode) {\n\t            return;\n\t        }\n\t        this.paper.__set__ && this.paper.__set__.exclude(this);\n\t        R.eve.unbind(\"raphael.*.*.\" + this.id);\n\t        R._tear(this, this.paper);\n\t        this.node.parentNode.removeChild(this.node);\n\t        this.shape && this.shape.parentNode.removeChild(this.shape);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        this.removed = true;\n\t    };\n\t    elproto.attr = function (name, value) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (name == null) {\n\t            var res = {};\n\t            for (var a in this.attrs) if (this.attrs[has](a)) {\n\t                res[a] = this.attrs[a];\n\t            }\n\t            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n\t            res.transform = this._.transform;\n\t            return res;\n\t        }\n\t        if (value == null && R.is(name, \"string\")) {\n\t            if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\n\t                return this.attrs.gradient;\n\t            }\n\t            var names = name.split(separator),\n\t                out = {};\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                name = names[i];\n\t                if (name in this.attrs) {\n\t                    out[name] = this.attrs[name];\n\t                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n\t                    out[name] = this.paper.customAttributes[name].def;\n\t                } else {\n\t                    out[name] = R._availableAttrs[name];\n\t                }\n\t            }\n\t            return ii - 1 ? out : out[names[0]];\n\t        }\n\t        if (this.attrs && value == null && R.is(name, \"array\")) {\n\t            out = {};\n\t            for (i = 0, ii = name.length; i < ii; i++) {\n\t                out[name[i]] = this.attr(name[i]);\n\t            }\n\t            return out;\n\t        }\n\t        var params;\n\t        if (value != null) {\n\t            params = {};\n\t            params[name] = value;\n\t        }\n\t        value == null && R.is(name, \"object\") && (params = name);\n\t        for (var key in params) {\n\t            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n\t        }\n\t        if (params) {\n\t            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n\t                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n\t                this.attrs[key] = params[key];\n\t                for (var subkey in par) if (par[has](subkey)) {\n\t                    params[subkey] = par[subkey];\n\t                }\n\t            }\n\t            // this.paper.canvas.style.display = \"none\";\n\t            if (params.text && this.type == \"text\") {\n\t                this.textpath.string = params.text;\n\t            }\n\t            setFillAndStroke(this, params);\n\t            // this.paper.canvas.style.display = E;\n\t        }\n\t        return this;\n\t    };\n\t    elproto.toFront = function () {\n\t        !this.removed && this.node.parentNode.appendChild(this.node);\n\t        this.paper && this.paper.top != this && R._tofront(this, this.paper);\n\t        return this;\n\t    };\n\t    elproto.toBack = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (this.node.parentNode.firstChild != this.node) {\n\t            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\n\t            R._toback(this, this.paper);\n\t        }\n\t        return this;\n\t    };\n\t    elproto.insertAfter = function (element) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (element.constructor == R.st.constructor) {\n\t            element = element[element.length - 1];\n\t        }\n\t        if (element.node.nextSibling) {\n\t            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\n\t        } else {\n\t            element.node.parentNode.appendChild(this.node);\n\t        }\n\t        R._insertafter(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.insertBefore = function (element) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (element.constructor == R.st.constructor) {\n\t            element = element[0];\n\t        }\n\t        element.node.parentNode.insertBefore(this.node, element.node);\n\t        R._insertbefore(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.blur = function (size) {\n\t        var s = this.node.runtimeStyle,\n\t            f = s.filter;\n\t        f = f.replace(blurregexp, E);\n\t        if (+size !== 0) {\n\t            this.attrs.blur = size;\n\t            s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\n\t            s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\n\t        } else {\n\t            s.filter = f;\n\t            s.margin = 0;\n\t            delete this.attrs.blur;\n\t        }\n\t        return this;\n\t    };\n\n\t    R._engine.path = function (pathString, vml) {\n\t        var el = createNode(\"shape\");\n\t        el.style.cssText = cssDot;\n\t        el.coordsize = zoom + S + zoom;\n\t        el.coordorigin = vml.coordorigin;\n\t        var p = new Element(el, vml),\n\t            attr = {fill: \"none\", stroke: \"#000\"};\n\t        pathString && (attr.path = pathString);\n\t        p.type = \"path\";\n\t        p.path = [];\n\t        p.Path = E;\n\t        setFillAndStroke(p, attr);\n\t        vml.canvas && vml.canvas.appendChild(el);\n\t        var skew = createNode(\"skew\");\n\t        skew.on = true;\n\t        el.appendChild(skew);\n\t        p.skew = skew;\n\t        p.transform(E);\n\t        return p;\n\t    };\n\t    R._engine.rect = function (vml, x, y, w, h, r) {\n\t        var path = R._rectPath(x, y, w, h, r),\n\t            res = vml.path(path),\n\t            a = res.attrs;\n\t        res.X = a.x = x;\n\t        res.Y = a.y = y;\n\t        res.W = a.width = w;\n\t        res.H = a.height = h;\n\t        a.r = r;\n\t        a.path = path;\n\t        res.type = \"rect\";\n\t        return res;\n\t    };\n\t    R._engine.ellipse = function (vml, x, y, rx, ry) {\n\t        var res = vml.path(),\n\t            a = res.attrs;\n\t        res.X = x - rx;\n\t        res.Y = y - ry;\n\t        res.W = rx * 2;\n\t        res.H = ry * 2;\n\t        res.type = \"ellipse\";\n\t        setFillAndStroke(res, {\n\t            cx: x,\n\t            cy: y,\n\t            rx: rx,\n\t            ry: ry\n\t        });\n\t        return res;\n\t    };\n\t    R._engine.circle = function (vml, x, y, r) {\n\t        var res = vml.path(),\n\t            a = res.attrs;\n\t        res.X = x - r;\n\t        res.Y = y - r;\n\t        res.W = res.H = r * 2;\n\t        res.type = \"circle\";\n\t        setFillAndStroke(res, {\n\t            cx: x,\n\t            cy: y,\n\t            r: r\n\t        });\n\t        return res;\n\t    };\n\t    R._engine.image = function (vml, src, x, y, w, h) {\n\t        var path = R._rectPath(x, y, w, h),\n\t            res = vml.path(path).attr({stroke: \"none\"}),\n\t            a = res.attrs,\n\t            node = res.node,\n\t            fill = node.getElementsByTagName(fillString)[0];\n\t        a.src = src;\n\t        res.X = a.x = x;\n\t        res.Y = a.y = y;\n\t        res.W = a.width = w;\n\t        res.H = a.height = h;\n\t        a.path = path;\n\t        res.type = \"image\";\n\t        fill.parentNode == node && node.removeChild(fill);\n\t        fill.rotate = true;\n\t        fill.src = src;\n\t        fill.type = \"tile\";\n\t        res._.fillpos = [x, y];\n\t        res._.fillsize = [w, h];\n\t        node.appendChild(fill);\n\t        setCoords(res, 1, 1, 0, 0, 0);\n\t        return res;\n\t    };\n\t    R._engine.text = function (vml, x, y, text) {\n\t        var el = createNode(\"shape\"),\n\t            path = createNode(\"path\"),\n\t            o = createNode(\"textpath\");\n\t        x = x || 0;\n\t        y = y || 0;\n\t        text = text || \"\";\n\t        path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\n\t        path.textpathok = true;\n\t        o.string = Str(text);\n\t        o.on = true;\n\t        el.style.cssText = cssDot;\n\t        el.coordsize = zoom + S + zoom;\n\t        el.coordorigin = \"0 0\";\n\t        var p = new Element(el, vml),\n\t            attr = {\n\t                fill: \"#000\",\n\t                stroke: \"none\",\n\t                font: R._availableAttrs.font,\n\t                text: text\n\t            };\n\t        p.shape = el;\n\t        p.path = path;\n\t        p.textpath = o;\n\t        p.type = \"text\";\n\t        p.attrs.text = Str(text);\n\t        p.attrs.x = x;\n\t        p.attrs.y = y;\n\t        p.attrs.w = 1;\n\t        p.attrs.h = 1;\n\t        setFillAndStroke(p, attr);\n\t        el.appendChild(o);\n\t        el.appendChild(path);\n\t        vml.canvas.appendChild(el);\n\t        var skew = createNode(\"skew\");\n\t        skew.on = true;\n\t        el.appendChild(skew);\n\t        p.skew = skew;\n\t        p.transform(E);\n\t        return p;\n\t    };\n\t    R._engine.setSize = function (width, height) {\n\t        var cs = this.canvas.style;\n\t        this.width = width;\n\t        this.height = height;\n\t        width == +width && (width += \"px\");\n\t        height == +height && (height += \"px\");\n\t        cs.width = width;\n\t        cs.height = height;\n\t        cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\n\t        if (this._viewBox) {\n\t            R._engine.setViewBox.apply(this, this._viewBox);\n\t        }\n\t        return this;\n\t    };\n\t    R._engine.setViewBox = function (x, y, w, h, fit) {\n\t        R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n\t        var paperSize = this.getSize(),\n\t            width = paperSize.width,\n\t            height = paperSize.height,\n\t            H, W;\n\t        if (fit) {\n\t            H = height / h;\n\t            W = width / w;\n\t            if (w * H < width) {\n\t                x -= (width - w * H) / 2 / H;\n\t            }\n\t            if (h * W < height) {\n\t                y -= (height - h * W) / 2 / W;\n\t            }\n\t        }\n\t        this._viewBox = [x, y, w, h, !!fit];\n\t        this._viewBoxShift = {\n\t            dx: -x,\n\t            dy: -y,\n\t            scale: paperSize\n\t        };\n\t        this.forEach(function (el) {\n\t            el.transform(\"...\");\n\t        });\n\t        return this;\n\t    };\n\t    var createNode;\n\t    R._engine.initWin = function (win) {\n\t            var doc = win.document;\n\t            if (doc.styleSheets.length < 31) {\n\t                doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\n\t            } else {\n\t                // no more room, add to the existing one\n\t                // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t                doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\n\t            }\n\t            try {\n\t                !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\n\t                createNode = function (tagName) {\n\t                    return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\n\t                };\n\t            } catch (e) {\n\t                createNode = function (tagName) {\n\t                    return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\n\t                };\n\t            }\n\t        };\n\t    R._engine.initWin(R._g.win);\n\t    R._engine.create = function () {\n\t        var con = R._getContainer.apply(0, arguments),\n\t            container = con.container,\n\t            height = con.height,\n\t            s,\n\t            width = con.width,\n\t            x = con.x,\n\t            y = con.y;\n\t        if (!container) {\n\t            throw new Error(\"VML container not found.\");\n\t        }\n\t        var res = new R._Paper,\n\t            c = res.canvas = R._g.doc.createElement(\"div\"),\n\t            cs = c.style;\n\t        x = x || 0;\n\t        y = y || 0;\n\t        width = width || 512;\n\t        height = height || 342;\n\t        res.width = width;\n\t        res.height = height;\n\t        width == +width && (width += \"px\");\n\t        height == +height && (height += \"px\");\n\t        res.coordsize = zoom * 1e3 + S + zoom * 1e3;\n\t        res.coordorigin = \"0 0\";\n\t        res.span = R._g.doc.createElement(\"span\");\n\t        res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\n\t        c.appendChild(res.span);\n\t        cs.cssText = R.format(\"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden\", width, height);\n\t        if (container == 1) {\n\t            R._g.doc.body.appendChild(c);\n\t            cs.left = x + \"px\";\n\t            cs.top = y + \"px\";\n\t            cs.position = \"absolute\";\n\t        } else {\n\t            if (container.firstChild) {\n\t                container.insertBefore(c, container.firstChild);\n\t            } else {\n\t                container.appendChild(c);\n\t            }\n\t        }\n\t        res.renderfix = function () {};\n\t        return res;\n\t    };\n\t    R.prototype.clear = function () {\n\t        R.eve(\"raphael.clear\", this);\n\t        this.canvas.innerHTML = E;\n\t        this.span = R._g.doc.createElement(\"span\");\n\t        this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\n\t        this.canvas.appendChild(this.span);\n\t        this.bottom = this.top = null;\n\t    };\n\t    R.prototype.remove = function () {\n\t        R.eve(\"raphael.remove\", this);\n\t        this.canvas.parentNode.removeChild(this.canvas);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        return true;\n\t    };\n\n\t    var setproto = R.st;\n\t    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname].apply(el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(14);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(20)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../css-loader/index.js!./morris.css\", function() {\n\t\t\tvar newContent = require(\"!!./../css-loader/index.js!./morris.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = __webpack_require__(10)\n\n/* template */\nvar __vue_template__ = __webpack_require__(19)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = __webpack_require__(11)\n\n/* template */\nvar __vue_template__ = __webpack_require__(18)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = __webpack_require__(12)\n\n/* template */\nvar __vue_template__ = __webpack_require__(17)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = __webpack_require__(13)\n\n/* template */\nvar __vue_template__ = __webpack_require__(16)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raphael = __webpack_require__(3);\n\nvar _raphael2 = _interopRequireDefault(_raphael);\n\n__webpack_require__(2);\n\n__webpack_require__(4);\n\nvar _converter = __webpack_require__(1);\n\nvar _converter2 = _interopRequireDefault(_converter);\n\nvar _chartProps = __webpack_require__(0);\n\nvar _chartProps2 = _interopRequireDefault(_chartProps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nglobal.Raphael = _raphael2.default;\nexports.default = {\n  name: 'area-chart',\n\n  mixins: [_chartProps2.default.area],\n\n  data: function data() {\n    return {\n      chart: null\n    };\n  },\n\n\n  watch: {\n    data: function data(val) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        _this.chart.setData(_converter2.default.toObject(_this.data));\n      });\n    }\n  },\n\n  mounted: function mounted() {\n    var options = {\n      element: this.id,\n      data: _converter2.default.toObject(this.data),\n      resize: _converter2.default.toBoolean(this.resize),\n      labels: _converter2.default.toObject(this.labels),\n      xkey: this.xkey,\n      ykeys: _converter2.default.toObject(this.ykeys),\n      grid: _converter2.default.toBoolean(this.grid),\n      gridTextColor: this.gridTextColor,\n      gridTextSize: _converter2.default.toInt(this.gridTextSize),\n      gridTextFamily: this.gridTextFamily,\n      gridTextWeight: this.gridTextWeight\n    };\n\n    if (this.lineColors) {\n      options.lineColors = _converter2.default.toObject(this.lineColors);\n    }\n\n    if (this.xLabels) {\n      options.xLabels = this.xLabels;\n    }\n\n    console.log(options.data);\n\n    this.chart = Morris.Area(options);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raphael = __webpack_require__(3);\n\nvar _raphael2 = _interopRequireDefault(_raphael);\n\n__webpack_require__(2);\n\n__webpack_require__(4);\n\nvar _converter = __webpack_require__(1);\n\nvar _converter2 = _interopRequireDefault(_converter);\n\nvar _chartProps = __webpack_require__(0);\n\nvar _chartProps2 = _interopRequireDefault(_chartProps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nglobal.Raphael = _raphael2.default;\nexports.default = {\n  name: 'bar-chart',\n\n  data: function data() {\n    return {\n      chart: null\n    };\n  },\n\n\n  watch: {\n    data: function data(val) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        _this.chart.setData(_this.data);\n      });\n    }\n  },\n\n  mixins: [_chartProps2.default.bar],\n\n  mounted: function mounted() {\n    var options = {\n      element: this.id,\n      data: _converter2.default.toObject(this.data),\n      labels: _converter2.default.toObject(this.labels),\n      resize: _converter2.default.toBoolean(this.resize),\n      xkey: this.xkey,\n      ykeys: _converter2.default.toObject(this.ykeys),\n      axes: _converter2.default.toBoolean(this.axes),\n      hideHover: this.hideHover,\n      stacked: _converter2.default.toBoolean(this.stacked),\n      grid: _converter2.default.toBoolean(this.grid),\n      gridTextColor: this.gridTextColor,\n      gridTextSize: _converter2.default.toInt(this.gridTextSize),\n      gridTextFamily: this.gridTextFamily,\n      gridTextWeight: this.gridTextWeight\n    };\n\n    if (this.barColors) {\n      options.barColors = _converter2.default.toObject(this.barColors);\n    }\n\n    if (this.hoverCallback) {\n      options.hoverCallback = this.hoverCallback;\n    }\n\n    this.chart = Morris.Bar(options);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raphael = __webpack_require__(3);\n\nvar _raphael2 = _interopRequireDefault(_raphael);\n\n__webpack_require__(2);\n\n__webpack_require__(4);\n\nvar _converter = __webpack_require__(1);\n\nvar _converter2 = _interopRequireDefault(_converter);\n\nvar _chartProps = __webpack_require__(0);\n\nvar _chartProps2 = _interopRequireDefault(_chartProps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nglobal.Raphael = _raphael2.default;\nexports.default = {\n  name: 'donut-chart',\n\n  data: function data() {\n    return {\n      chart: null\n    };\n  },\n\n\n  watch: {\n    data: function data(val) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        _this.chart.setData(_converter2.default.toObject(_this.data));\n      });\n    }\n  },\n\n  mixins: [_chartProps2.default.donut],\n\n  mounted: function mounted() {\n    var options = {\n      element: this.id,\n      data: _converter2.default.toObject(this.data),\n      resize: _converter2.default.toBoolean(this.resize)\n    };\n\n    if (this.colors) {\n      options.colors = _converter2.default.toObject(this.colors);\n    }\n\n    if (this.formatter) {\n      options.formatter = this.formatter;\n    }\n\n    this.chart = Morris.Donut(options);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raphael = __webpack_require__(3);\n\nvar _raphael2 = _interopRequireDefault(_raphael);\n\n__webpack_require__(2);\n\n__webpack_require__(4);\n\nvar _converter = __webpack_require__(1);\n\nvar _converter2 = _interopRequireDefault(_converter);\n\nvar _chartProps = __webpack_require__(0);\n\nvar _chartProps2 = _interopRequireDefault(_chartProps);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nglobal.Raphael = _raphael2.default;\nexports.default = {\n  name: 'line-chart',\n\n  mixins: [_chartProps2.default.line],\n\n  data: function data() {\n    return {\n      chart: null\n    };\n  },\n\n\n  watch: {\n    data: function data(val) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        _this.chart.setData(_converter2.default.toObject(_this.data));\n      });\n    }\n  },\n\n  mounted: function mounted() {\n    var options = {\n      element: this.id,\n      data: _converter2.default.toObject(this.data),\n      resize: _converter2.default.toBoolean(this.resize),\n      labels: _converter2.default.toObject(this.labels),\n      xkey: this.xkey,\n      ykeys: _converter2.default.toObject(this.ykeys),\n      grid: _converter2.default.toBoolean(this.grid),\n      gridTextColor: this.gridTextColor,\n      gridTextSize: _converter2.default.toInt(this.gridTextSize),\n      gridTextFamily: this.gridTextFamily,\n      gridTextWeight: this.gridTextWeight\n    };\n\n    if (this.lineColors) {\n      options.lineColors = _converter2.default.toObject(this.lineColors);\n    }\n\n    if (this.xLabels) {\n      options.xLabels = this.xLabels;\n    }\n\n    console.log(options.data);\n\n    this.chart = Morris.Line(options);\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(15)();\n// imports\n\n\n// module\nexports.push([module.i, \".morris-hover{position:absolute;z-index:1000}.morris-hover.morris-default-style{border-radius:10px;padding:6px;color:#666;background:hsla(0,0%,100%,.8);border:2px solid hsla(0,0%,90%,.8);font-family:sans-serif;font-size:12px;text-align:center}.morris-hover.morris-default-style .morris-hover-row-label{font-weight:700;margin:.25em 0}.morris-hover.morris-default-style .morris-hover-point{white-space:nowrap;margin:.1em 0}\", \"\"]);\n\n// exports\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _donutChart = __webpack_require__(8);\n\nvar _donutChart2 = _interopRequireDefault(_donutChart);\n\nvar _barChart = __webpack_require__(7);\n\nvar _barChart2 = _interopRequireDefault(_barChart);\n\nvar _lineChart = __webpack_require__(9);\n\nvar _lineChart2 = _interopRequireDefault(_lineChart);\n\nvar _areaChart = __webpack_require__(6);\n\nvar _areaChart2 = _interopRequireDefault(_areaChart);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VueMorris = {\n  DonutChart: _donutChart2.default, BarChart: _barChart2.default, LineChart: _lineChart2.default, AreaChart: _areaChart2.default\n};\n\nmodule.exports = VueMorris;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// vue-morris.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a92ee7b6912111d1a0e9","/*\r\nTODO:\r\n  lineWidth: { type: [ Number, String ], required: false },\r\n  pointSize: { type: [ Number, String ], required: false },\r\n  pointFillColors: { type: [ String, Array ], required: false}, // Colors for the series points. By default uses the same values as lineColors\r\n  pointStrokeColors: {}, // Colors for the outlines of the series points. (#ffffff by default).\r\n  ymax: {}, // Max. bound for Y-values. Alternatively, set this to 'auto' to compute automatically, or 'auto [num]' to automatically compute and ensure that the max y-value is at least [num].\r\n  ymin: {}, // Min. bound for Y-values. Alternatively, set this to 'auto' to compute automatically, or 'auto [num]' to automatically compute and ensure that the min y-value is at most [num]. \r\n  smooth: { type: [ Boolean, String ], required: false, default: true }, // Set to false to disable line smoothing.\r\n  parseTime: {}, // Set to false to skip time/date parsing for X values, instead treating them as an equally-spaced series.\r\n  postUnits: {}, // Set to a string value (eg: '%') to add a label suffix all y-labels.\r\n  preUnits: {}, // Set to a string value (eg: '$') to add a label prefix all y-labels.\r\n  dateFormat: {}, // A function that accepts millisecond timestamps and formats them for display as chart labels. \r\n  \r\n  xLabelFormat: {}, //  A function that accepts Date objects and formats them for display as x-axis labels. Overrides the default formatter chosen by the automatic labeller or the xLabels option. \r\n  xLabelAngle: {}, // The angle in degrees from horizontal to draw x-axis labels.\r\n  yLabelFormat: {}, //  A function that accepts y-values and formats them for display as y-axis labels. \r\n  goals: {}, // A list of y-values to draw as horizontal 'goal' lines on the chart. \r\n  goalStrokeWidth: {}, // Width, in pixels, of the goal lines.\r\n  goalLineColors: {}, //  Array of color values to use for the goal line colors. If you list fewer colors here than you have lines in goals, then the values will be cycled.\r\n  events: {}, // A list of x-values to draw as vertical 'event' lines on the chart. \r\n  eventStrokeWidth: {}, //  Width, in pixels, of the event lines.\r\n  eventLineColors: {}, // Array of color values to use for the event line colors. If you list fewer colors here than you have lines in events, then the values will be cycled.\r\n  fillOpacity: {}, //  Change the opacity of the area fill colour. Accepts values between 0.0 (for completely transparent) and 1.0 (for completely opaque).\r\n\r\n  behaveLikeLine: {}, //   Set to true to overlay the areas on top of each other instead of stacking them.\r\n}\r\n*/\r\n\r\nconst Props = {\r\n  id: { type: String, required: true }, \r\n  data: { type: [ String, Array ], required: true },\r\n  barColors: { type: [ String, Array ], required: false },\r\n  xkey: { type: String, required: false, default: 'key' },\r\n  ykeys: { type: [ String, Array ], required: false, default: [ 'value' ] },\r\n  labels: { type: [ String, Array ], required: false, default: [ 'Value' ] },\r\n  hoverCallback: { type: Function, required: false },\r\n  axes: { type: [ Boolean, String ], required: false, default: true },\r\n  hideHover: { type: String, required: false },\r\n  stacked: { type: [ Boolean, String ], required: false },\r\n  resize: { type: [ Boolean, String ], required: false },\r\n  grid: { type: [ Boolean, String ], required: false, default: true },\r\n  gridTextColor: { type: String, required: false, default: '#888' },\r\n  gridTextSize: { type: [ Number, String ], required: false, default: 12 },\r\n  gridTextFamily: { type: String, required: false, default: 'sans-serif' },\r\n  gridTextWeight: { type: String, required: false, default: 'normal' },\r\n\r\n  colors: { type: [ String, Array ], required: false },\r\n  formatter: { type: Function, required: false },\r\n\r\n  lineColors: { type: [ String, Array ], required: false },\r\n  xLabels: { type: String, required: false },\r\n}\r\n\r\nconst ChartProps = {\r\n\r\n  bar: {\r\n    props: {\r\n      id: Props.id,\r\n      data: Props.data,\r\n      barColors: Props.barColors,\r\n      xkey: Props.xkey,\r\n      ykeys: Props.ykeys,\r\n      labels: Props.labels,\r\n      hoverCallback: Props.hoverCallback,\r\n      grid: Props.grid,\r\n      axes: Props.axes,\r\n      hideHover: Props.hideHover,\r\n      stacked: Props.stacked,\r\n      resize: Props.resize,\r\n      gridTextColor: Props.gridTextColor,\r\n      gridTextSize: Props.gridTextSize,\r\n      gridTextFamily: Props.gridTextFamily,\r\n      gridTextWeight: Props.gridTextWeight\r\n    }\r\n  },\r\n\r\n  donut: {\r\n    props: {\r\n      id: Props.id, \r\n      data: Props.data,\r\n      colors: Props.colors,\r\n      formatter: Props.formatter,\r\n      resize: Props.resize\r\n    }\r\n  },\r\n\r\n  line: {\r\n    props: {\r\n      id: Props.id, \r\n      data: Props.data,\r\n      resize: Props.resize,\r\n      lineColors: Props.lineColors,\r\n      xkey: Props.xkey,\r\n      ykeys: Props.ykeys,\r\n      labels: Props.labels,\r\n      xLabels: Props.xLabels,\r\n      grid: Props.grid,\r\n      gridTextColor: Props.gridTextColor,\r\n      gridTextSize: Props.gridTextSize,\r\n      gridTextFamily: Props.gridTextFamily,\r\n      gridTextWeight: Props.gridTextWeight\r\n    }\r\n  },\r\n\r\n  area: {\r\n    props: {\r\n      id: Props.id, \r\n      data: Props.data,\r\n      resize: Props.resize,\r\n      lineColors: Props.lineColors,\r\n      xkey: Props.xkey,\r\n      ykeys: Props.ykeys,\r\n      labels: Props.labels,\r\n      xLabels: Props.xLabels,\r\n      grid: Props.grid,\r\n      gridTextColor: Props.gridTextColor,\r\n      gridTextSize: Props.gridTextSize,\r\n      gridTextFamily: Props.gridTextFamily,\r\n      gridTextWeight: Props.gridTextWeight\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default ChartProps\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/chart-props.js","const Converter = {\r\n  toObject (data) {\r\n    if (typeof data === 'string') {\r\n      return JSON.parse(data)\r\n    }\r\n    return data\r\n  },\r\n\r\n  toBoolean (data) {\r\n    if (typeof data === 'string') {\r\n      return data === 'true'\r\n    }\r\n    return data\r\n  },\r\n\r\n  toInt (data) {\r\n    if (typeof data === 'string') {\r\n      return parseInt(data)\r\n    }\r\n    return data\r\n  },\r\n}\r\n\r\nmodule.exports = Converter\n\n\n// WEBPACK FOOTER //\n// ./src/util/converter.js","/* @license\nmorris.js v0.5.0\nCopyright 2014 Olly Smith All rights reserved.\nLicensed under the BSD-2-Clause License.\n*/\n\n\n(function() {\n  var $, Morris, minutesSpecHelper, secondsSpecHelper,\n    __slice = [].slice,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    __hasProp = {}.hasOwnProperty,\n    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  Morris = window.Morris = {};\n\n  $ = jQuery;\n\n  Morris.EventEmitter = (function() {\n    function EventEmitter() {}\n\n    EventEmitter.prototype.on = function(name, handler) {\n      if (this.handlers == null) {\n        this.handlers = {};\n      }\n      if (this.handlers[name] == null) {\n        this.handlers[name] = [];\n      }\n      this.handlers[name].push(handler);\n      return this;\n    };\n\n    EventEmitter.prototype.fire = function() {\n      var args, handler, name, _i, _len, _ref, _results;\n      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if ((this.handlers != null) && (this.handlers[name] != null)) {\n        _ref = this.handlers[name];\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          handler = _ref[_i];\n          _results.push(handler.apply(null, args));\n        }\n        return _results;\n      }\n    };\n\n    return EventEmitter;\n\n  })();\n\n  Morris.commas = function(num) {\n    var absnum, intnum, ret, strabsnum;\n    if (num != null) {\n      ret = num < 0 ? \"-\" : \"\";\n      absnum = Math.abs(num);\n      intnum = Math.floor(absnum).toFixed(0);\n      ret += intnum.replace(/(?=(?:\\d{3})+$)(?!^)/g, ',');\n      strabsnum = absnum.toString();\n      if (strabsnum.length > intnum.length) {\n        ret += strabsnum.slice(intnum.length);\n      }\n      return ret;\n    } else {\n      return '-';\n    }\n  };\n\n  Morris.pad2 = function(number) {\n    return (number < 10 ? '0' : '') + number;\n  };\n\n  Morris.Grid = (function(_super) {\n    __extends(Grid, _super);\n\n    function Grid(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      var _this = this;\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if ((this.el == null) || this.el.length === 0) {\n        throw new Error(\"Graph container element not found\");\n      }\n      if (this.el.css('position') === 'static') {\n        this.el.css('position', 'relative');\n      }\n      this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);\n      if (typeof this.options.units === 'string') {\n        this.options.postUnits = options.units;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      this.elementWidth = null;\n      this.elementHeight = null;\n      this.dirty = false;\n      this.selectFrom = null;\n      if (this.init) {\n        this.init();\n      }\n      this.setData(this.options.data);\n      this.el.bind('mousemove', function(evt) {\n        var left, offset, right, width, x;\n        offset = _this.el.offset();\n        x = evt.pageX - offset.left;\n        if (_this.selectFrom) {\n          left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;\n          right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;\n          width = right - left;\n          return _this.selectionRect.attr({\n            x: left,\n            width: width\n          });\n        } else {\n          return _this.fire('hovermove', x, evt.pageY - offset.top);\n        }\n      });\n      this.el.bind('mouseleave', function(evt) {\n        if (_this.selectFrom) {\n          _this.selectionRect.hide();\n          _this.selectFrom = null;\n        }\n        return _this.fire('hoverout');\n      });\n      this.el.bind('touchstart touchmove touchend', function(evt) {\n        var offset, touch;\n        touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];\n        offset = _this.el.offset();\n        return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);\n      });\n      this.el.bind('click', function(evt) {\n        var offset;\n        offset = _this.el.offset();\n        return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);\n      });\n      if (this.options.rangeSelect) {\n        this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({\n          fill: this.options.rangeSelectColor,\n          stroke: false\n        }).toBack().hide();\n        this.el.bind('mousedown', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          return _this.startRange(evt.pageX - offset.left);\n        });\n        this.el.bind('mouseup', function(evt) {\n          var offset;\n          offset = _this.el.offset();\n          _this.endRange(evt.pageX - offset.left);\n          return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);\n        });\n      }\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');\n      if (this.postInit) {\n        this.postInit();\n      }\n    }\n\n    Grid.prototype.gridDefaults = {\n      dateFormat: null,\n      axes: true,\n      grid: true,\n      gridLineColor: '#aaa',\n      gridStrokeWidth: 0.5,\n      gridTextColor: '#888',\n      gridTextSize: 12,\n      gridTextFamily: 'sans-serif',\n      gridTextWeight: 'normal',\n      hideHover: false,\n      yLabelFormat: null,\n      xLabelAngle: 0,\n      numLines: 5,\n      padding: 25,\n      parseTime: true,\n      postUnits: '',\n      preUnits: '',\n      ymax: 'auto',\n      ymin: 'auto 0',\n      goals: [],\n      goalStrokeWidth: 1.0,\n      goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],\n      events: [],\n      eventStrokeWidth: 1.0,\n      eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],\n      rangeSelect: null,\n      rangeSelectColor: '#eef',\n      resize: false\n    };\n\n    Grid.prototype.setData = function(data, redraw) {\n      var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;\n      if (redraw == null) {\n        redraw = true;\n      }\n      this.options.data = data;\n      if ((data == null) || data.length === 0) {\n        this.data = [];\n        this.raphael.clear();\n        if (this.hover != null) {\n          this.hover.hide();\n        }\n        return;\n      }\n      ymax = this.cumulative ? 0 : null;\n      ymin = this.cumulative ? 0 : null;\n      if (this.options.goals.length > 0) {\n        minGoal = Math.min.apply(Math, this.options.goals);\n        maxGoal = Math.max.apply(Math, this.options.goals);\n        ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;\n        ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;\n      }\n      this.data = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {\n          row = data[index];\n          ret = {\n            src: row\n          };\n          ret.label = row[this.options.xkey];\n          if (this.options.parseTime) {\n            ret.x = Morris.parseDate(ret.label);\n            if (this.options.dateFormat) {\n              ret.label = this.options.dateFormat(ret.x);\n            } else if (typeof ret.label === 'number') {\n              ret.label = new Date(ret.label).toString();\n            }\n          } else {\n            ret.x = index;\n            if (this.options.xLabelFormat) {\n              ret.label = this.options.xLabelFormat(ret);\n            }\n          }\n          total = 0;\n          ret.y = (function() {\n            var _j, _len1, _ref, _results1;\n            _ref = this.options.ykeys;\n            _results1 = [];\n            for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {\n              ykey = _ref[idx];\n              yval = row[ykey];\n              if (typeof yval === 'string') {\n                yval = parseFloat(yval);\n              }\n              if ((yval != null) && typeof yval !== 'number') {\n                yval = null;\n              }\n              if (yval != null) {\n                if (this.cumulative) {\n                  total += yval;\n                } else {\n                  if (ymax != null) {\n                    ymax = Math.max(yval, ymax);\n                    ymin = Math.min(yval, ymin);\n                  } else {\n                    ymax = ymin = yval;\n                  }\n                }\n              }\n              if (this.cumulative && (total != null)) {\n                ymax = Math.max(total, ymax);\n                ymin = Math.min(total, ymin);\n              }\n              _results1.push(yval);\n            }\n            return _results1;\n          }).call(this);\n          _results.push(ret);\n        }\n        return _results;\n      }).call(this);\n      if (this.options.parseTime) {\n        this.data = this.data.sort(function(a, b) {\n          return (a.x > b.x) - (b.x > a.x);\n        });\n      }\n      this.xmin = this.data[0].x;\n      this.xmax = this.data[this.data.length - 1].x;\n      this.events = [];\n      if (this.options.events.length > 0) {\n        if (this.options.parseTime) {\n          this.events = (function() {\n            var _i, _len, _ref, _results;\n            _ref = this.options.events;\n            _results = [];\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              e = _ref[_i];\n              _results.push(Morris.parseDate(e));\n            }\n            return _results;\n          }).call(this);\n        } else {\n          this.events = this.options.events;\n        }\n        this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));\n        this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));\n      }\n      if (this.xmin === this.xmax) {\n        this.xmin -= 1;\n        this.xmax += 1;\n      }\n      this.ymin = this.yboundary('min', ymin);\n      this.ymax = this.yboundary('max', ymax);\n      if (this.ymin === this.ymax) {\n        if (ymin) {\n          this.ymin -= 1;\n        }\n        this.ymax += 1;\n      }\n      if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {\n        if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {\n          this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);\n          this.ymin = Math.min(this.ymin, this.grid[0]);\n          this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);\n        } else {\n          step = (this.ymax - this.ymin) / (this.options.numLines - 1);\n          this.grid = (function() {\n            var _i, _ref1, _ref2, _results;\n            _results = [];\n            for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {\n              _results.push(y);\n            }\n            return _results;\n          }).call(this);\n        }\n      }\n      this.dirty = true;\n      if (redraw) {\n        return this.redraw();\n      }\n    };\n\n    Grid.prototype.yboundary = function(boundaryType, currentValue) {\n      var boundaryOption, suggestedValue;\n      boundaryOption = this.options[\"y\" + boundaryType];\n      if (typeof boundaryOption === 'string') {\n        if (boundaryOption.slice(0, 4) === 'auto') {\n          if (boundaryOption.length > 5) {\n            suggestedValue = parseInt(boundaryOption.slice(5), 10);\n            if (currentValue == null) {\n              return suggestedValue;\n            }\n            return Math[boundaryType](currentValue, suggestedValue);\n          } else {\n            if (currentValue != null) {\n              return currentValue;\n            } else {\n              return 0;\n            }\n          }\n        } else {\n          return parseInt(boundaryOption, 10);\n        }\n      } else {\n        return boundaryOption;\n      }\n    };\n\n    Grid.prototype.autoGridLines = function(ymin, ymax, nlines) {\n      var gmax, gmin, grid, smag, span, step, unit, y, ymag;\n      span = ymax - ymin;\n      ymag = Math.floor(Math.log(span) / Math.log(10));\n      unit = Math.pow(10, ymag);\n      gmin = Math.floor(ymin / unit) * unit;\n      gmax = Math.ceil(ymax / unit) * unit;\n      step = (gmax - gmin) / (nlines - 1);\n      if (unit === 1 && step > 1 && Math.ceil(step) !== step) {\n        step = Math.ceil(step);\n        gmax = gmin + step * (nlines - 1);\n      }\n      if (gmin < 0 && gmax > 0) {\n        gmin = Math.floor(ymin / step) * step;\n        gmax = Math.ceil(ymax / step) * step;\n      }\n      if (step < 1) {\n        smag = Math.floor(Math.log(step) / Math.log(10));\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(parseFloat(y.toFixed(1 - smag)));\n          }\n          return _results;\n        })();\n      } else {\n        grid = (function() {\n          var _i, _results;\n          _results = [];\n          for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {\n            _results.push(y);\n          }\n          return _results;\n        })();\n      }\n      return grid;\n    };\n\n    Grid.prototype._calc = function() {\n      var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;\n      w = this.el.width();\n      h = this.el.height();\n      if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {\n        this.elementWidth = w;\n        this.elementHeight = h;\n        this.dirty = false;\n        this.left = this.options.padding;\n        this.right = this.elementWidth - this.options.padding;\n        this.top = this.options.padding;\n        this.bottom = this.elementHeight - this.options.padding;\n        if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {\n          yLabelWidths = (function() {\n            var _i, _len, _ref1, _results;\n            _ref1 = this.grid;\n            _results = [];\n            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n              gridLine = _ref1[_i];\n              _results.push(this.measureText(this.yAxisFormat(gridLine)).width);\n            }\n            return _results;\n          }).call(this);\n          this.left += Math.max.apply(Math, yLabelWidths);\n        }\n        if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {\n          bottomOffsets = (function() {\n            var _i, _ref2, _results;\n            _results = [];\n            for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {\n              _results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);\n            }\n            return _results;\n          }).call(this);\n          this.bottom -= Math.max.apply(Math, bottomOffsets);\n        }\n        this.width = Math.max(1, this.right - this.left);\n        this.height = Math.max(1, this.bottom - this.top);\n        this.dx = this.width / (this.xmax - this.xmin);\n        this.dy = this.height / (this.ymax - this.ymin);\n        if (this.calc) {\n          return this.calc();\n        }\n      }\n    };\n\n    Grid.prototype.transY = function(y) {\n      return this.bottom - (y - this.ymin) * this.dy;\n    };\n\n    Grid.prototype.transX = function(x) {\n      if (this.data.length === 1) {\n        return (this.left + this.right) / 2;\n      } else {\n        return this.left + (x - this.xmin) * this.dx;\n      }\n    };\n\n    Grid.prototype.redraw = function() {\n      this.raphael.clear();\n      this._calc();\n      this.drawGrid();\n      this.drawGoals();\n      this.drawEvents();\n      if (this.draw) {\n        return this.draw();\n      }\n    };\n\n    Grid.prototype.measureText = function(text, angle) {\n      var ret, tt;\n      if (angle == null) {\n        angle = 0;\n      }\n      tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);\n      ret = tt.getBBox();\n      tt.remove();\n      return ret;\n    };\n\n    Grid.prototype.yAxisFormat = function(label) {\n      return this.yLabelFormat(label);\n    };\n\n    Grid.prototype.yLabelFormat = function(label) {\n      if (typeof this.options.yLabelFormat === 'function') {\n        return this.options.yLabelFormat(label);\n      } else {\n        return \"\" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;\n      }\n    };\n\n    Grid.prototype.drawGrid = function() {\n      var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;\n      if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {\n        return;\n      }\n      _ref1 = this.grid;\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        lineY = _ref1[_i];\n        y = this.transY(lineY);\n        if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {\n          this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));\n        }\n        if (this.options.grid) {\n          _results.push(this.drawGridLine(\"M\" + this.left + \",\" + y + \"H\" + (this.left + this.width)));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoals = function() {\n      var color, goal, i, _i, _len, _ref, _results;\n      _ref = this.options.goals;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        goal = _ref[i];\n        color = this.options.goalLineColors[i % this.options.goalLineColors.length];\n        _results.push(this.drawGoal(goal, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawEvents = function() {\n      var color, event, i, _i, _len, _ref, _results;\n      _ref = this.events;\n      _results = [];\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        event = _ref[i];\n        color = this.options.eventLineColors[i % this.options.eventLineColors.length];\n        _results.push(this.drawEvent(event, color));\n      }\n      return _results;\n    };\n\n    Grid.prototype.drawGoal = function(goal, color) {\n      return this.raphael.path(\"M\" + this.left + \",\" + (this.transY(goal)) + \"H\" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);\n    };\n\n    Grid.prototype.drawEvent = function(event, color) {\n      return this.raphael.path(\"M\" + (this.transX(event)) + \",\" + this.bottom + \"V\" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);\n    };\n\n    Grid.prototype.drawYAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');\n    };\n\n    Grid.prototype.drawGridLine = function(path) {\n      return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);\n    };\n\n    Grid.prototype.startRange = function(x) {\n      this.hover.hide();\n      this.selectFrom = x;\n      return this.selectionRect.attr({\n        x: x,\n        width: 0\n      }).show();\n    };\n\n    Grid.prototype.endRange = function(x) {\n      var end, start;\n      if (this.selectFrom) {\n        start = Math.min(this.selectFrom, x);\n        end = Math.max(this.selectFrom, x);\n        this.options.rangeSelect.call(this.el, {\n          start: this.data[this.hitTest(start)].x,\n          end: this.data[this.hitTest(end)].x\n        });\n        return this.selectFrom = null;\n      }\n    };\n\n    Grid.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Grid;\n\n  })(Morris.EventEmitter);\n\n  Morris.parseDate = function(date) {\n    var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;\n    if (typeof date === 'number') {\n      return date;\n    }\n    m = date.match(/^(\\d+) Q(\\d)$/);\n    n = date.match(/^(\\d+)-(\\d+)$/);\n    o = date.match(/^(\\d+)-(\\d+)-(\\d+)$/);\n    p = date.match(/^(\\d+) W(\\d+)$/);\n    q = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    r = date.match(/^(\\d+)-(\\d+)-(\\d+)[ T](\\d+):(\\d+):(\\d+(\\.\\d+)?)(Z|([+-])(\\d\\d):?(\\d\\d))?$/);\n    if (m) {\n      return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();\n    } else if (n) {\n      return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();\n    } else if (o) {\n      return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();\n    } else if (p) {\n      ret = new Date(parseInt(p[1], 10), 0, 1);\n      if (ret.getDay() !== 4) {\n        ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);\n      }\n      return ret.getTime() + parseInt(p[2], 10) * 604800000;\n    } else if (q) {\n      if (!q[6]) {\n        return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();\n      } else {\n        offsetmins = 0;\n        if (q[6] !== 'Z') {\n          offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);\n          if (q[7] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);\n      }\n    } else if (r) {\n      secs = parseFloat(r[6]);\n      isecs = Math.floor(secs);\n      msecs = Math.round((secs - isecs) * 1000);\n      if (!r[8]) {\n        return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();\n      } else {\n        offsetmins = 0;\n        if (r[8] !== 'Z') {\n          offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);\n          if (r[9] === '+') {\n            offsetmins = 0 - offsetmins;\n          }\n        }\n        return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);\n      }\n    } else {\n      return new Date(parseInt(date, 10), 0, 1).getTime();\n    }\n  };\n\n  Morris.Hover = (function() {\n    Hover.defaults = {\n      \"class\": 'morris-hover morris-default-style'\n    };\n\n    function Hover(options) {\n      if (options == null) {\n        options = {};\n      }\n      this.options = $.extend({}, Morris.Hover.defaults, options);\n      this.el = $(\"<div class='\" + this.options[\"class\"] + \"'></div>\");\n      this.el.hide();\n      this.options.parent.append(this.el);\n    }\n\n    Hover.prototype.update = function(html, x, y) {\n      if (!html) {\n        return this.hide();\n      } else {\n        this.html(html);\n        this.show();\n        return this.moveTo(x, y);\n      }\n    };\n\n    Hover.prototype.html = function(content) {\n      return this.el.html(content);\n    };\n\n    Hover.prototype.moveTo = function(x, y) {\n      var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;\n      parentWidth = this.options.parent.innerWidth();\n      parentHeight = this.options.parent.innerHeight();\n      hoverWidth = this.el.outerWidth();\n      hoverHeight = this.el.outerHeight();\n      left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);\n      if (y != null) {\n        top = y - hoverHeight - 10;\n        if (top < 0) {\n          top = y + 10;\n          if (top + hoverHeight > parentHeight) {\n            top = parentHeight / 2 - hoverHeight / 2;\n          }\n        }\n      } else {\n        top = parentHeight / 2 - hoverHeight / 2;\n      }\n      return this.el.css({\n        left: left + \"px\",\n        top: parseInt(top) + \"px\"\n      });\n    };\n\n    Hover.prototype.show = function() {\n      return this.el.show();\n    };\n\n    Hover.prototype.hide = function() {\n      return this.el.hide();\n    };\n\n    return Hover;\n\n  })();\n\n  Morris.Line = (function(_super) {\n    __extends(Line, _super);\n\n    function Line(options) {\n      this.hilight = __bind(this.hilight, this);\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Line)) {\n        return new Morris.Line(options);\n      }\n      Line.__super__.constructor.call(this, options);\n    }\n\n    Line.prototype.init = function() {\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Line.prototype.defaults = {\n      lineWidth: 3,\n      pointSize: 4,\n      lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      pointStrokeWidths: [1],\n      pointStrokeColors: ['#ffffff'],\n      pointFillColors: [],\n      smooth: true,\n      xLabels: 'auto',\n      xLabelFormat: null,\n      xLabelMargin: 24,\n      hideHover: false\n    };\n\n    Line.prototype.calc = function() {\n      this.calcPoints();\n      return this.generatePaths();\n    };\n\n    Line.prototype.calcPoints = function() {\n      var row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row._y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(y);\n            }\n          }\n          return _results1;\n        })())));\n      }\n      return _results;\n    };\n\n    Line.prototype.hitTest = function(x) {\n      var index, r, _i, _len, _ref;\n      if (this.data.length === 0) {\n        return null;\n      }\n      _ref = this.data.slice(1);\n      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n        r = _ref[index];\n        if (x < (r._x + this.data[index]._x) / 2) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    Line.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Line.prototype.onHoverMove = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.displayHoverForRow(index);\n    };\n\n    Line.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.displayHoverForRow(null);\n      }\n    };\n\n    Line.prototype.displayHoverForRow = function(index) {\n      var _ref;\n      if (index != null) {\n        (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n        return this.hilight(index);\n      } else {\n        this.hover.hide();\n        return this.hilight();\n      }\n    };\n\n    Line.prototype.hoverContentForRow = function(index) {\n      var content, j, row, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      return [content, row._x, row._ymax];\n    };\n\n    Line.prototype.generatePaths = function() {\n      var coords, i, r, smooth;\n      return this.paths = (function() {\n        var _i, _ref, _ref1, _results;\n        _results = [];\n        for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          smooth = typeof this.options.smooth === \"boolean\" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);\n          coords = (function() {\n            var _j, _len, _ref2, _results1;\n            _ref2 = this.data;\n            _results1 = [];\n            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {\n              r = _ref2[_j];\n              if (r._y[i] !== void 0) {\n                _results1.push({\n                  x: r._x,\n                  y: r._y[i]\n                });\n              }\n            }\n            return _results1;\n          }).call(this);\n          if (coords.length > 1) {\n            _results.push(Morris.Line.createPath(coords, smooth, this.bottom));\n          } else {\n            _results.push(null);\n          }\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Line.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      this.drawSeries();\n      if (this.options.hideHover === false) {\n        return this.displayHoverForRow(this.data.length - 1);\n      }\n    };\n\n    Line.prototype.drawXAxis = function() {\n      var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,\n        _this = this;\n      ypos = this.bottom + this.options.padding / 2;\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      drawLabel = function(labelText, xpos) {\n        var label, labelBox, margin, offset, textBox;\n        label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-_this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (_this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        labelBox = label.getBBox();\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {\n          if (_this.options.xLabelAngle !== 0) {\n            margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;\n        } else {\n          return label.remove();\n        }\n      };\n      if (this.options.parseTime) {\n        if (this.data.length === 1 && this.options.xLabels === 'auto') {\n          labels = [[this.data[0].label, this.data[0].x]];\n        } else {\n          labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);\n        }\n      } else {\n        labels = (function() {\n          var _i, _len, _ref, _results;\n          _ref = this.data;\n          _results = [];\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            row = _ref[_i];\n            _results.push([row.label, row.x]);\n          }\n          return _results;\n        }).call(this);\n      }\n      labels.reverse();\n      _results = [];\n      for (_i = 0, _len = labels.length; _i < _len; _i++) {\n        l = labels[_i];\n        _results.push(drawLabel(l[0], l[1]));\n      }\n      return _results;\n    };\n\n    Line.prototype.drawSeries = function() {\n      var i, _i, _j, _ref, _ref1, _results;\n      this.seriesPoints = [];\n      for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {\n        this._drawLineFor(i);\n      }\n      _results = [];\n      for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {\n        _results.push(this._drawPointFor(i));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawPointFor = function(index) {\n      var circle, row, _i, _len, _ref, _results;\n      this.seriesPoints[index] = [];\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        circle = null;\n        if (row._y[index] != null) {\n          circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);\n        }\n        _results.push(this.seriesPoints[index].push(circle));\n      }\n      return _results;\n    };\n\n    Line.prototype._drawLineFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);\n      }\n    };\n\n    Line.createPath = function(coords, smooth, bottom) {\n      var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;\n      path = \"\";\n      if (smooth) {\n        grads = Morris.Line.gradients(coords);\n      }\n      prevCoord = {\n        y: null\n      };\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          if (prevCoord.y != null) {\n            if (smooth) {\n              g = grads[i];\n              lg = grads[i - 1];\n              ix = (coord.x - prevCoord.x) / 4;\n              x1 = prevCoord.x + ix;\n              y1 = Math.min(bottom, prevCoord.y + ix * lg);\n              x2 = coord.x - ix;\n              y2 = Math.min(bottom, coord.y - ix * g);\n              path += \"C\" + x1 + \",\" + y1 + \",\" + x2 + \",\" + y2 + \",\" + coord.x + \",\" + coord.y;\n            } else {\n              path += \"L\" + coord.x + \",\" + coord.y;\n            }\n          } else {\n            if (!smooth || (grads[i] != null)) {\n              path += \"M\" + coord.x + \",\" + coord.y;\n            }\n          }\n        }\n        prevCoord = coord;\n      }\n      return path;\n    };\n\n    Line.gradients = function(coords) {\n      var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;\n      grad = function(a, b) {\n        return (a.y - b.y) / (a.x - b.x);\n      };\n      _results = [];\n      for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {\n        coord = coords[i];\n        if (coord.y != null) {\n          nextCoord = coords[i + 1] || {\n            y: null\n          };\n          prevCoord = coords[i - 1] || {\n            y: null\n          };\n          if ((prevCoord.y != null) && (nextCoord.y != null)) {\n            _results.push(grad(prevCoord, nextCoord));\n          } else if (prevCoord.y != null) {\n            _results.push(grad(prevCoord, coord));\n          } else if (nextCoord.y != null) {\n            _results.push(grad(coord, nextCoord));\n          } else {\n            _results.push(null);\n          }\n        } else {\n          _results.push(null);\n        }\n      }\n      return _results;\n    };\n\n    Line.prototype.hilight = function(index) {\n      var i, _i, _j, _ref, _ref1;\n      if (this.prevHilight !== null && this.prevHilight !== index) {\n        for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\n          if (this.seriesPoints[i][this.prevHilight]) {\n            this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));\n          }\n        }\n      }\n      if (index !== null && this.prevHilight !== index) {\n        for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n          if (this.seriesPoints[i][index]) {\n            this.seriesPoints[i][index].animate(this.pointGrowSeries(i));\n          }\n        }\n      }\n      return this.prevHilight = index;\n    };\n\n    Line.prototype.colorFor = function(row, sidx, type) {\n      if (typeof this.options.lineColors === 'function') {\n        return this.options.lineColors.call(this, row, sidx, type);\n      } else if (type === 'point') {\n        return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];\n      } else {\n        return this.options.lineColors[sidx % this.options.lineColors.length];\n      }\n    };\n\n    Line.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Line.prototype.drawLinePath = function(path, lineColor, lineIndex) {\n      return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));\n    };\n\n    Line.prototype.drawLinePoint = function(xPos, yPos, pointColor, lineIndex) {\n      return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));\n    };\n\n    Line.prototype.pointStrokeWidthForSeries = function(index) {\n      return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];\n    };\n\n    Line.prototype.pointStrokeColorForSeries = function(index) {\n      return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];\n    };\n\n    Line.prototype.lineWidthForSeries = function(index) {\n      if (this.options.lineWidth instanceof Array) {\n        return this.options.lineWidth[index % this.options.lineWidth.length];\n      } else {\n        return this.options.lineWidth;\n      }\n    };\n\n    Line.prototype.pointSizeForSeries = function(index) {\n      if (this.options.pointSize instanceof Array) {\n        return this.options.pointSize[index % this.options.pointSize.length];\n      } else {\n        return this.options.pointSize;\n      }\n    };\n\n    Line.prototype.pointGrowSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index) + 3\n      }, 25, 'linear');\n    };\n\n    Line.prototype.pointShrinkSeries = function(index) {\n      return Raphael.animation({\n        r: this.pointSizeForSeries(index)\n      }, 25, 'linear');\n    };\n\n    return Line;\n\n  })(Morris.Grid);\n\n  Morris.labelSeries = function(dmin, dmax, pxwidth, specName, xLabelFormat) {\n    var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;\n    ddensity = 200 * (dmax - dmin) / pxwidth;\n    d0 = new Date(dmin);\n    spec = Morris.LABEL_SPECS[specName];\n    if (spec === void 0) {\n      _ref = Morris.AUTO_LABEL_ORDER;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        s = Morris.LABEL_SPECS[name];\n        if (ddensity >= s.span) {\n          spec = s;\n          break;\n        }\n      }\n    }\n    if (spec === void 0) {\n      spec = Morris.LABEL_SPECS[\"second\"];\n    }\n    if (xLabelFormat) {\n      spec = $.extend({}, spec, {\n        fmt: xLabelFormat\n      });\n    }\n    d = spec.start(d0);\n    ret = [];\n    while ((t = d.getTime()) <= dmax) {\n      if (t >= dmin) {\n        ret.push([spec.fmt(d), t]);\n      }\n      spec.incr(d);\n    }\n    return ret;\n  };\n\n  minutesSpecHelper = function(interval) {\n    return {\n      span: interval * 60 * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes()));\n      },\n      incr: function(d) {\n        return d.setUTCMinutes(d.getUTCMinutes() + interval);\n      }\n    };\n  };\n\n  secondsSpecHelper = function(interval) {\n    return {\n      span: interval * 1000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n      },\n      fmt: function(d) {\n        return \"\" + (Morris.pad2(d.getHours())) + \":\" + (Morris.pad2(d.getMinutes())) + \":\" + (Morris.pad2(d.getSeconds()));\n      },\n      incr: function(d) {\n        return d.setUTCSeconds(d.getUTCSeconds() + interval);\n      }\n    };\n  };\n\n  Morris.LABEL_SPECS = {\n    \"decade\": {\n      span: 172800000000,\n      start: function(d) {\n        return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 10);\n      }\n    },\n    \"year\": {\n      span: 17280000000,\n      start: function(d) {\n        return new Date(d.getFullYear(), 0, 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear());\n      },\n      incr: function(d) {\n        return d.setFullYear(d.getFullYear() + 1);\n      }\n    },\n    \"month\": {\n      span: 2419200000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), 1);\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1));\n      },\n      incr: function(d) {\n        return d.setMonth(d.getMonth() + 1);\n      }\n    },\n    \"week\": {\n      span: 604800000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 7);\n      }\n    },\n    \"day\": {\n      span: 86400000,\n      start: function(d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      },\n      fmt: function(d) {\n        return \"\" + (d.getFullYear()) + \"-\" + (Morris.pad2(d.getMonth() + 1)) + \"-\" + (Morris.pad2(d.getDate()));\n      },\n      incr: function(d) {\n        return d.setDate(d.getDate() + 1);\n      }\n    },\n    \"hour\": minutesSpecHelper(60),\n    \"30min\": minutesSpecHelper(30),\n    \"15min\": minutesSpecHelper(15),\n    \"10min\": minutesSpecHelper(10),\n    \"5min\": minutesSpecHelper(5),\n    \"minute\": minutesSpecHelper(1),\n    \"30sec\": secondsSpecHelper(30),\n    \"15sec\": secondsSpecHelper(15),\n    \"10sec\": secondsSpecHelper(10),\n    \"5sec\": secondsSpecHelper(5),\n    \"second\": secondsSpecHelper(1)\n  };\n\n  Morris.AUTO_LABEL_ORDER = [\"decade\", \"year\", \"month\", \"week\", \"day\", \"hour\", \"30min\", \"15min\", \"10min\", \"5min\", \"minute\", \"30sec\", \"15sec\", \"10sec\", \"5sec\", \"second\"];\n\n  Morris.Area = (function(_super) {\n    var areaDefaults;\n\n    __extends(Area, _super);\n\n    areaDefaults = {\n      fillOpacity: 'auto',\n      behaveLikeLine: false\n    };\n\n    function Area(options) {\n      var areaOptions;\n      if (!(this instanceof Morris.Area)) {\n        return new Morris.Area(options);\n      }\n      areaOptions = $.extend({}, areaDefaults, options);\n      this.cumulative = !areaOptions.behaveLikeLine;\n      if (areaOptions.fillOpacity === 'auto') {\n        areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;\n      }\n      Area.__super__.constructor.call(this, areaOptions);\n    }\n\n    Area.prototype.calcPoints = function() {\n      var row, total, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        row = _ref[_i];\n        row._x = this.transX(row.x);\n        total = 0;\n        row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (this.options.behaveLikeLine) {\n              _results1.push(this.transY(y));\n            } else {\n              total += y || 0;\n              _results1.push(this.transY(total));\n            }\n          }\n          return _results1;\n        }).call(this);\n        _results.push(row._ymax = Math.max.apply(Math, row._y));\n      }\n      return _results;\n    };\n\n    Area.prototype.drawSeries = function() {\n      var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;\n      this.seriesPoints = [];\n      if (this.options.behaveLikeLine) {\n        range = (function() {\n          _results = [];\n          for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }\n          return _results;\n        }).apply(this);\n      } else {\n        range = (function() {\n          _results1 = [];\n          for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results1.push(_j); }\n          return _results1;\n        }).apply(this);\n      }\n      _results2 = [];\n      for (_k = 0, _len = range.length; _k < _len; _k++) {\n        i = range[_k];\n        this._drawFillFor(i);\n        this._drawLineFor(i);\n        _results2.push(this._drawPointFor(i));\n      }\n      return _results2;\n    };\n\n    Area.prototype._drawFillFor = function(index) {\n      var path;\n      path = this.paths[index];\n      if (path !== null) {\n        path = path + (\"L\" + (this.transX(this.xmax)) + \",\" + this.bottom + \"L\" + (this.transX(this.xmin)) + \",\" + this.bottom + \"Z\");\n        return this.drawFilledPath(path, this.fillForSeries(index));\n      }\n    };\n\n    Area.prototype.fillForSeries = function(i) {\n      var color;\n      color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));\n      return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));\n    };\n\n    Area.prototype.drawFilledPath = function(path, fill) {\n      return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');\n    };\n\n    return Area;\n\n  })(Morris.Line);\n\n  Morris.Bar = (function(_super) {\n    __extends(Bar, _super);\n\n    function Bar(options) {\n      this.onHoverOut = __bind(this.onHoverOut, this);\n      this.onHoverMove = __bind(this.onHoverMove, this);\n      this.onGridClick = __bind(this.onGridClick, this);\n      if (!(this instanceof Morris.Bar)) {\n        return new Morris.Bar(options);\n      }\n      Bar.__super__.constructor.call(this, $.extend({}, options, {\n        parseTime: false\n      }));\n    }\n\n    Bar.prototype.init = function() {\n      this.cumulative = this.options.stacked;\n      if (this.options.hideHover !== 'always') {\n        this.hover = new Morris.Hover({\n          parent: this.el\n        });\n        this.on('hovermove', this.onHoverMove);\n        this.on('hoverout', this.onHoverOut);\n        return this.on('gridclick', this.onGridClick);\n      }\n    };\n\n    Bar.prototype.defaults = {\n      barSizeRatio: 0.75,\n      barGap: 3,\n      barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],\n      barOpacity: 1.0,\n      barRadius: [0, 0, 0, 0],\n      xLabelMargin: 50\n    };\n\n    Bar.prototype.calc = function() {\n      var _ref;\n      this.calcBars();\n      if (this.options.hideHover === false) {\n        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));\n      }\n    };\n\n    Bar.prototype.calcBars = function() {\n      var idx, row, y, _i, _len, _ref, _results;\n      _ref = this.data;\n      _results = [];\n      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n        row = _ref[idx];\n        row._x = this.left + this.width * (idx + 0.5) / this.data.length;\n        _results.push(row._y = (function() {\n          var _j, _len1, _ref1, _results1;\n          _ref1 = row.y;\n          _results1 = [];\n          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n            y = _ref1[_j];\n            if (y != null) {\n              _results1.push(this.transY(y));\n            } else {\n              _results1.push(null);\n            }\n          }\n          return _results1;\n        }).call(this));\n      }\n      return _results;\n    };\n\n    Bar.prototype.draw = function() {\n      var _ref;\n      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {\n        this.drawXAxis();\n      }\n      return this.drawSeries();\n    };\n\n    Bar.prototype.drawXAxis = function() {\n      var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref, _results;\n      ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);\n      prevLabelMargin = null;\n      prevAngleMargin = null;\n      _results = [];\n      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        row = this.data[this.data.length - 1 - i];\n        label = this.drawXAxisLabel(row._x, ypos, row.label);\n        textBox = label.getBBox();\n        label.transform(\"r\" + (-this.options.xLabelAngle));\n        labelBox = label.getBBox();\n        label.transform(\"t0,\" + (labelBox.height / 2) + \"...\");\n        if (this.options.xLabelAngle !== 0) {\n          offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);\n          label.transform(\"t\" + offset + \",0...\");\n        }\n        if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {\n          if (this.options.xLabelAngle !== 0) {\n            margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);\n            prevAngleMargin = labelBox.x - margin;\n          }\n          _results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);\n        } else {\n          _results.push(label.remove());\n        }\n      }\n      return _results;\n    };\n\n    Bar.prototype.drawSeries = function() {\n      var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos;\n      groupWidth = this.width / this.options.data.length;\n      numBars = this.options.stacked ? 1 : this.options.ykeys.length;\n      barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;\n      if (this.options.barSize) {\n        barWidth = Math.min(barWidth, this.options.barSize);\n      }\n      spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);\n      leftPadding = spaceLeft / 2;\n      zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;\n      return this.bars = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {\n          row = _ref[idx];\n          lastTop = 0;\n          _results.push((function() {\n            var _j, _len1, _ref1, _results1;\n            _ref1 = row._y;\n            _results1 = [];\n            for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {\n              ypos = _ref1[sidx];\n              if (ypos !== null) {\n                if (zeroPos) {\n                  top = Math.min(ypos, zeroPos);\n                  bottom = Math.max(ypos, zeroPos);\n                } else {\n                  top = ypos;\n                  bottom = this.bottom;\n                }\n                left = this.left + idx * groupWidth + leftPadding;\n                if (!this.options.stacked) {\n                  left += sidx * (barWidth + this.options.barGap);\n                }\n                size = bottom - top;\n                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {\n                  this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);\n                }\n                if (this.options.stacked) {\n                  top -= lastTop;\n                }\n                this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);\n                _results1.push(lastTop += size);\n              } else {\n                _results1.push(null);\n              }\n            }\n            return _results1;\n          }).call(this));\n        }\n        return _results;\n      }).call(this);\n    };\n\n    Bar.prototype.colorFor = function(row, sidx, type) {\n      var r, s;\n      if (typeof this.options.barColors === 'function') {\n        r = {\n          x: row.x,\n          y: row.y[sidx],\n          label: row.label\n        };\n        s = {\n          index: sidx,\n          key: this.options.ykeys[sidx],\n          label: this.options.labels[sidx]\n        };\n        return this.options.barColors.call(this, r, s, type);\n      } else {\n        return this.options.barColors[sidx % this.options.barColors.length];\n      }\n    };\n\n    Bar.prototype.hitTest = function(x) {\n      if (this.data.length === 0) {\n        return null;\n      }\n      x = Math.max(Math.min(x, this.right), this.left);\n      return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));\n    };\n\n    Bar.prototype.onGridClick = function(x, y) {\n      var index;\n      index = this.hitTest(x);\n      return this.fire('click', index, this.data[index].src, x, y);\n    };\n\n    Bar.prototype.onHoverMove = function(x, y) {\n      var index, _ref;\n      index = this.hitTest(x);\n      return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));\n    };\n\n    Bar.prototype.onHoverOut = function() {\n      if (this.options.hideHover !== false) {\n        return this.hover.hide();\n      }\n    };\n\n    Bar.prototype.hoverContentForRow = function(index) {\n      var content, j, row, x, y, _i, _len, _ref;\n      row = this.data[index];\n      content = \"<div class='morris-hover-row-label'>\" + row.label + \"</div>\";\n      _ref = row.y;\n      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {\n        y = _ref[j];\n        content += \"<div class='morris-hover-point' style='color: \" + (this.colorFor(row, j, 'label')) + \"'>\\n  \" + this.options.labels[j] + \":\\n  \" + (this.yLabelFormat(y)) + \"\\n</div>\";\n      }\n      if (typeof this.options.hoverCallback === 'function') {\n        content = this.options.hoverCallback(index, this.options, content, row.src);\n      }\n      x = this.left + (index + 0.5) * this.width / this.data.length;\n      return [content, x];\n    };\n\n    Bar.prototype.drawXAxisLabel = function(xPos, yPos, text) {\n      var label;\n      return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);\n    };\n\n    Bar.prototype.drawBar = function(xPos, yPos, width, height, barColor, opacity, radiusArray) {\n      var maxRadius, path;\n      maxRadius = Math.max.apply(Math, radiusArray);\n      if (maxRadius === 0 || maxRadius > height) {\n        path = this.raphael.rect(xPos, yPos, width, height);\n      } else {\n        path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));\n      }\n      return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');\n    };\n\n    Bar.prototype.roundedRect = function(x, y, w, h, r) {\n      if (r == null) {\n        r = [0, 0, 0, 0];\n      }\n      return [\"M\", x, r[0] + y, \"Q\", x, y, x + r[0], y, \"L\", x + w - r[1], y, \"Q\", x + w, y, x + w, y + r[1], \"L\", x + w, y + h - r[2], \"Q\", x + w, y + h, x + w - r[2], y + h, \"L\", x + r[3], y + h, \"Q\", x, y + h, x, y + h - r[3], \"Z\"];\n    };\n\n    return Bar;\n\n  })(Morris.Grid);\n\n  Morris.Donut = (function(_super) {\n    __extends(Donut, _super);\n\n    Donut.prototype.defaults = {\n      colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],\n      backgroundColor: '#FFFFFF',\n      labelColor: '#000000',\n      formatter: Morris.commas,\n      resize: false\n    };\n\n    function Donut(options) {\n      this.resizeHandler = __bind(this.resizeHandler, this);\n      this.select = __bind(this.select, this);\n      this.click = __bind(this.click, this);\n      var _this = this;\n      if (!(this instanceof Morris.Donut)) {\n        return new Morris.Donut(options);\n      }\n      this.options = $.extend({}, this.defaults, options);\n      if (typeof options.element === 'string') {\n        this.el = $(document.getElementById(options.element));\n      } else {\n        this.el = $(options.element);\n      }\n      if (this.el === null || this.el.length === 0) {\n        throw new Error(\"Graph placeholder not found.\");\n      }\n      if (options.data === void 0 || options.data.length === 0) {\n        return;\n      }\n      this.raphael = new Raphael(this.el[0]);\n      if (this.options.resize) {\n        $(window).bind('resize', function(evt) {\n          if (_this.timeoutId != null) {\n            window.clearTimeout(_this.timeoutId);\n          }\n          return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);\n        });\n      }\n      this.setData(options.data);\n    }\n\n    Donut.prototype.redraw = function() {\n      var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;\n      this.raphael.clear();\n      cx = this.el.width() / 2;\n      cy = this.el.height() / 2;\n      w = (Math.min(cx, cy) - 10) / 3;\n      total = 0;\n      _ref = this.values;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        value = _ref[_i];\n        total += value;\n      }\n      min = 5 / (2 * w);\n      C = 1.9999 * Math.PI - min * this.data.length;\n      last = 0;\n      idx = 0;\n      this.segments = [];\n      _ref1 = this.values;\n      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n        value = _ref1[i];\n        next = last + min + C * (value / total);\n        seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);\n        seg.render();\n        this.segments.push(seg);\n        seg.on('hover', this.select);\n        seg.on('click', this.click);\n        last = next;\n        idx += 1;\n      }\n      this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);\n      this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);\n      max_value = Math.max.apply(Math, this.values);\n      idx = 0;\n      _ref2 = this.values;\n      _results = [];\n      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {\n        value = _ref2[_k];\n        if (value === max_value) {\n          this.select(idx);\n          break;\n        }\n        _results.push(idx += 1);\n      }\n      return _results;\n    };\n\n    Donut.prototype.setData = function(data) {\n      var row;\n      this.data = data;\n      this.values = (function() {\n        var _i, _len, _ref, _results;\n        _ref = this.data;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          row = _ref[_i];\n          _results.push(parseFloat(row.value));\n        }\n        return _results;\n      }).call(this);\n      return this.redraw();\n    };\n\n    Donut.prototype.click = function(idx) {\n      return this.fire('click', idx, this.data[idx]);\n    };\n\n    Donut.prototype.select = function(idx) {\n      var row, s, segment, _i, _len, _ref;\n      _ref = this.segments;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        s = _ref[_i];\n        s.deselect();\n      }\n      segment = this.segments[idx];\n      segment.select();\n      row = this.data[idx];\n      return this.setLabels(row.label, this.options.formatter(row.value, row));\n    };\n\n    Donut.prototype.setLabels = function(label1, label2) {\n      var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;\n      inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;\n      maxWidth = 1.8 * inner;\n      maxHeightTop = inner / 2;\n      maxHeightBottom = inner / 3;\n      this.text1.attr({\n        text: label1,\n        transform: ''\n      });\n      text1bbox = this.text1.getBBox();\n      text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);\n      this.text1.attr({\n        transform: \"S\" + text1scale + \",\" + text1scale + \",\" + (text1bbox.x + text1bbox.width / 2) + \",\" + (text1bbox.y + text1bbox.height)\n      });\n      this.text2.attr({\n        text: label2,\n        transform: ''\n      });\n      text2bbox = this.text2.getBBox();\n      text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);\n      return this.text2.attr({\n        transform: \"S\" + text2scale + \",\" + text2scale + \",\" + (text2bbox.x + text2bbox.width / 2) + \",\" + text2bbox.y\n      });\n    };\n\n    Donut.prototype.drawEmptyDonutLabel = function(xPos, yPos, color, fontSize, fontWeight) {\n      var text;\n      text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);\n      if (fontWeight != null) {\n        text.attr('font-weight', fontWeight);\n      }\n      return text;\n    };\n\n    Donut.prototype.resizeHandler = function() {\n      this.timeoutId = null;\n      this.raphael.setSize(this.el.width(), this.el.height());\n      return this.redraw();\n    };\n\n    return Donut;\n\n  })(Morris.EventEmitter);\n\n  Morris.DonutSegment = (function(_super) {\n    __extends(DonutSegment, _super);\n\n    function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {\n      this.cx = cx;\n      this.cy = cy;\n      this.inner = inner;\n      this.outer = outer;\n      this.color = color;\n      this.backgroundColor = backgroundColor;\n      this.index = index;\n      this.raphael = raphael;\n      this.deselect = __bind(this.deselect, this);\n      this.select = __bind(this.select, this);\n      this.sin_p0 = Math.sin(p0);\n      this.cos_p0 = Math.cos(p0);\n      this.sin_p1 = Math.sin(p1);\n      this.cos_p1 = Math.cos(p1);\n      this.is_long = (p1 - p0) > Math.PI ? 1 : 0;\n      this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);\n      this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);\n      this.hilight = this.calcArc(this.inner);\n    }\n\n    DonutSegment.prototype.calcArcPoints = function(r) {\n      return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];\n    };\n\n    DonutSegment.prototype.calcSegment = function(r1, r2) {\n      var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;\n      _ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      _ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r1 + \",\" + r1 + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1) + (\"L\" + ox1 + \",\" + oy1) + (\"A\" + r2 + \",\" + r2 + \",0,\" + this.is_long + \",1,\" + ox0 + \",\" + oy0) + \"Z\";\n    };\n\n    DonutSegment.prototype.calcArc = function(r) {\n      var ix0, ix1, iy0, iy1, _ref;\n      _ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];\n      return (\"M\" + ix0 + \",\" + iy0) + (\"A\" + r + \",\" + r + \",0,\" + this.is_long + \",0,\" + ix1 + \",\" + iy1);\n    };\n\n    DonutSegment.prototype.render = function() {\n      var _this = this;\n      this.arc = this.drawDonutArc(this.hilight, this.color);\n      return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {\n        return _this.fire('hover', _this.index);\n      }, function() {\n        return _this.fire('click', _this.index);\n      });\n    };\n\n    DonutSegment.prototype.drawDonutArc = function(path, color) {\n      return this.raphael.path(path).attr({\n        stroke: color,\n        'stroke-width': 2,\n        opacity: 0\n      });\n    };\n\n    DonutSegment.prototype.drawDonutSegment = function(path, fillColor, strokeColor, hoverFunction, clickFunction) {\n      return this.raphael.path(path).attr({\n        fill: fillColor,\n        stroke: strokeColor,\n        'stroke-width': 3\n      }).hover(hoverFunction).click(clickFunction);\n    };\n\n    DonutSegment.prototype.select = function() {\n      if (!this.selected) {\n        this.seg.animate({\n          path: this.selectedPath\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 1\n        }, 150, '<>');\n        return this.selected = true;\n      }\n    };\n\n    DonutSegment.prototype.deselect = function() {\n      if (this.selected) {\n        this.seg.animate({\n          path: this.path\n        }, 150, '<>');\n        this.arc.animate({\n          opacity: 0\n        }, 150, '<>');\n        return this.selected = false;\n      }\n    };\n\n    return DonutSegment;\n\n  })(Morris.EventEmitter);\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/morris.js/morris.js\n// module id = 2\n// module chunks = 0","//  \\\\\n//  Raphal 2.2.0 - JavaScript Vector Library                                                              \\\\\n//  \\\\\n//  Copyright  2008-2016 Dmitry Baranovskiy (http://raphaeljs.com)                                        \\\\\n//  Copyright  2008-2016 Sencha Labs (http://sencha.com)                                                  \\\\\n//  \\\\\n//  Licensed under the MIT (https://github.com/DmitryBaranovskiy/raphael/blob/master/license.txt) license. \\\\\n//  \\\\\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Raphael\"] = factory();\n\telse\n\t\troot[\"Raphael\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\n\t    return R;\n\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(eve) {\n\n\t    /*\\\n\t     * Raphael\n\t     [ method ]\n\t     **\n\t     * Creates a canvas object on which to draw.\n\t     * You must do this first, as all future calls to drawing methods\n\t     * from this instance will be bound to this canvas.\n\t     > Parameters\n\t     **\n\t     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\n\t     - width (number)\n\t     - height (number)\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - x (number)\n\t     - y (number)\n\t     - width (number)\n\t     - height (number)\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\n\t     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\n\t     * or\n\t     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.\n\t     = (object) @Paper\n\t     > Usage\n\t     | // Each of the following examples create a canvas\n\t     | // that is 320px wide by 200px high.\n\t     | // Canvas is created at the viewports 10,50 coordinate.\n\t     | var paper = Raphael(10, 50, 320, 200);\n\t     | // Canvas is created at the top left corner of the #notepad element\n\t     | // (or its top right corner in dir=\"rtl\" elements)\n\t     | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\n\t     | // Same as above\n\t     | var paper = Raphael(\"notepad\", 320, 200);\n\t     | // Image dump\n\t     | var set = Raphael([\"notepad\", 320, 200, {\n\t     |     type: \"rect\",\n\t     |     x: 10,\n\t     |     y: 10,\n\t     |     width: 25,\n\t     |     height: 25,\n\t     |     stroke: \"#f00\"\n\t     | }, {\n\t     |     type: \"text\",\n\t     |     x: 30,\n\t     |     y: 40,\n\t     |     text: \"Dump\"\n\t     | }]);\n\t    \\*/\n\t    function R(first) {\n\t        if (R.is(first, \"function\")) {\n\t            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\n\t        } else if (R.is(first, array)) {\n\t            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\n\t        } else {\n\t            var args = Array.prototype.slice.call(arguments, 0);\n\t            if (R.is(args[args.length - 1], \"function\")) {\n\t                var f = args.pop();\n\t                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\n\t                    f.call(R._engine.create[apply](R, args));\n\t                });\n\t            } else {\n\t                return R._engine.create[apply](R, arguments);\n\t            }\n\t        }\n\t    }\n\t    R.version = \"2.2.0\";\n\t    R.eve = eve;\n\t    var loaded,\n\t        separator = /[, ]+/,\n\t        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},\n\t        formatrg = /\\{(\\d+)\\}/g,\n\t        proto = \"prototype\",\n\t        has = \"hasOwnProperty\",\n\t        g = {\n\t            doc: document,\n\t            win: window\n\t        },\n\t        oldRaphael = {\n\t            was: Object.prototype[has].call(g.win, \"Raphael\"),\n\t            is: g.win.Raphael\n\t        },\n\t        Paper = function () {\n\t            /*\\\n\t             * Paper.ca\n\t             [ property (object) ]\n\t             **\n\t             * Shortcut for @Paper.customAttributes\n\t            \\*/\n\t            /*\\\n\t             * Paper.customAttributes\n\t             [ property (object) ]\n\t             **\n\t             * If you have a set of attributes that you would like to represent\n\t             * as a function of some number you can do it easily with custom attributes:\n\t             > Usage\n\t             | paper.customAttributes.hue = function (num) {\n\t             |     num = num % 1;\n\t             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\n\t             | };\n\t             | // Custom attribute hue will change fill\n\t             | // to be given hue with fixed saturation and brightness.\n\t             | // Now you can use it like this:\n\t             | var c = paper.circle(10, 10, 10).attr({hue: .45});\n\t             | // or even like this:\n\t             | c.animate({hue: 1}, 1e3);\n\t             |\n\t             | // You could also create custom attribute\n\t             | // with multiple parameters:\n\t             | paper.customAttributes.hsb = function (h, s, b) {\n\t             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\n\t             | };\n\t             | c.attr({hsb: \"0.5 .8 1\"});\n\t             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\n\t            \\*/\n\t            this.ca = this.customAttributes = {};\n\t        },\n\t        paperproto,\n\t        appendChild = \"appendChild\",\n\t        apply = \"apply\",\n\t        concat = \"concat\",\n\t        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test\n\t        E = \"\",\n\t        S = \" \",\n\t        Str = String,\n\t        split = \"split\",\n\t        events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\n\t        touchMap = {\n\t            mousedown: \"touchstart\",\n\t            mousemove: \"touchmove\",\n\t            mouseup: \"touchend\"\n\t        },\n\t        lowerCase = Str.prototype.toLowerCase,\n\t        math = Math,\n\t        mmax = math.max,\n\t        mmin = math.min,\n\t        abs = math.abs,\n\t        pow = math.pow,\n\t        PI = math.PI,\n\t        nu = \"number\",\n\t        string = \"string\",\n\t        array = \"array\",\n\t        toString = \"toString\",\n\t        fillString = \"fill\",\n\t        objectToString = Object.prototype.toString,\n\t        paper = {},\n\t        push = \"push\",\n\t        ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\n\t        colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\n\t        isnan = {\"NaN\": 1, \"Infinity\": 1, \"-Infinity\": 1},\n\t        bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n\t        round = math.round,\n\t        setAttribute = \"setAttribute\",\n\t        toFloat = parseFloat,\n\t        toInt = parseInt,\n\t        upperCase = Str.prototype.toUpperCase,\n\t        availableAttrs = R._availableAttrs = {\n\t            \"arrow-end\": \"none\",\n\t            \"arrow-start\": \"none\",\n\t            blur: 0,\n\t            \"clip-rect\": \"0 0 1e9 1e9\",\n\t            cursor: \"default\",\n\t            cx: 0,\n\t            cy: 0,\n\t            fill: \"#fff\",\n\t            \"fill-opacity\": 1,\n\t            font: '10px \"Arial\"',\n\t            \"font-family\": '\"Arial\"',\n\t            \"font-size\": \"10\",\n\t            \"font-style\": \"normal\",\n\t            \"font-weight\": 400,\n\t            gradient: 0,\n\t            height: 0,\n\t            href: \"http://raphaeljs.com/\",\n\t            \"letter-spacing\": 0,\n\t            opacity: 1,\n\t            path: \"M0,0\",\n\t            r: 0,\n\t            rx: 0,\n\t            ry: 0,\n\t            src: \"\",\n\t            stroke: \"#000\",\n\t            \"stroke-dasharray\": \"\",\n\t            \"stroke-linecap\": \"butt\",\n\t            \"stroke-linejoin\": \"butt\",\n\t            \"stroke-miterlimit\": 0,\n\t            \"stroke-opacity\": 1,\n\t            \"stroke-width\": 1,\n\t            target: \"_blank\",\n\t            \"text-anchor\": \"middle\",\n\t            title: \"Raphael\",\n\t            transform: \"\",\n\t            width: 0,\n\t            x: 0,\n\t            y: 0,\n\t            \"class\": \"\"\n\t        },\n\t        availableAnimAttrs = R._availableAnimAttrs = {\n\t            blur: nu,\n\t            \"clip-rect\": \"csv\",\n\t            cx: nu,\n\t            cy: nu,\n\t            fill: \"colour\",\n\t            \"fill-opacity\": nu,\n\t            \"font-size\": nu,\n\t            height: nu,\n\t            opacity: nu,\n\t            path: \"path\",\n\t            r: nu,\n\t            rx: nu,\n\t            ry: nu,\n\t            stroke: \"colour\",\n\t            \"stroke-opacity\": nu,\n\t            \"stroke-width\": nu,\n\t            transform: \"transform\",\n\t            width: nu,\n\t            x: nu,\n\t            y: nu\n\t        },\n\t        whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\n\t        commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\n\t        hsrg = {hs: 1, rg: 1},\n\t        p2s = /,?([achlmqrstvxz]),?/gi,\n\t        pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n\t        tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\n\t        pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\n\t        radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\n\t        eldata = {},\n\t        sortByKey = function (a, b) {\n\t            return a.key - b.key;\n\t        },\n\t        sortByNumber = function (a, b) {\n\t            return toFloat(a) - toFloat(b);\n\t        },\n\t        fun = function () {},\n\t        pipe = function (x) {\n\t            return x;\n\t        },\n\t        rectPath = R._rectPath = function (x, y, w, h, r) {\n\t            if (r) {\n\t                return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\n\t            }\n\t            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n\t        },\n\t        ellipsePath = function (x, y, rx, ry) {\n\t            if (ry == null) {\n\t                ry = rx;\n\t            }\n\t            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\n\t        },\n\t        getPath = R._getPath = {\n\t            path: function (el) {\n\t                return el.attr(\"path\");\n\t            },\n\t            circle: function (el) {\n\t                var a = el.attrs;\n\t                return ellipsePath(a.cx, a.cy, a.r);\n\t            },\n\t            ellipse: function (el) {\n\t                var a = el.attrs;\n\t                return ellipsePath(a.cx, a.cy, a.rx, a.ry);\n\t            },\n\t            rect: function (el) {\n\t                var a = el.attrs;\n\t                return rectPath(a.x, a.y, a.width, a.height, a.r);\n\t            },\n\t            image: function (el) {\n\t                var a = el.attrs;\n\t                return rectPath(a.x, a.y, a.width, a.height);\n\t            },\n\t            text: function (el) {\n\t                var bbox = el._getBBox();\n\t                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t            },\n\t            set : function(el) {\n\t                var bbox = el._getBBox();\n\t                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n\t            }\n\t        },\n\t        /*\\\n\t         * Raphael.mapPath\n\t         [ method ]\n\t         **\n\t         * Transform the path string with given matrix.\n\t         > Parameters\n\t         - path (string) path string\n\t         - matrix (object) see @Matrix\n\t         = (string) transformed path string\n\t        \\*/\n\t        mapPath = R.mapPath = function (path, matrix) {\n\t            if (!matrix) {\n\t                return path;\n\t            }\n\t            var x, y, i, j, ii, jj, pathi;\n\t            path = path2curve(path);\n\t            for (i = 0, ii = path.length; i < ii; i++) {\n\t                pathi = path[i];\n\t                for (j = 1, jj = pathi.length; j < jj; j += 2) {\n\t                    x = matrix.x(pathi[j], pathi[j + 1]);\n\t                    y = matrix.y(pathi[j], pathi[j + 1]);\n\t                    pathi[j] = x;\n\t                    pathi[j + 1] = y;\n\t                }\n\t            }\n\t            return path;\n\t        };\n\n\t    R._g = g;\n\t    /*\\\n\t     * Raphael.type\n\t     [ property (string) ]\n\t     **\n\t     * Can be SVG, VML or empty, depending on browser support.\n\t    \\*/\n\t    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\");\n\t    if (R.type == \"VML\") {\n\t        var d = g.doc.createElement(\"div\"),\n\t            b;\n\t        d.innerHTML = '<v:shape adj=\"1\"/>';\n\t        b = d.firstChild;\n\t        b.style.behavior = \"url(#default#VML)\";\n\t        if (!(b && typeof b.adj == \"object\")) {\n\t            return (R.type = E);\n\t        }\n\t        d = null;\n\t    }\n\t    /*\\\n\t     * Raphael.svg\n\t     [ property (boolean) ]\n\t     **\n\t     * `true` if browser supports SVG.\n\t    \\*/\n\t    /*\\\n\t     * Raphael.vml\n\t     [ property (boolean) ]\n\t     **\n\t     * `true` if browser supports VML.\n\t    \\*/\n\t    R.svg = !(R.vml = R.type == \"VML\");\n\t    R._Paper = Paper;\n\t    /*\\\n\t     * Raphael.fn\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to the canvas. For example if you want to draw a pie chart,\n\t     * you can create your own pie chart function and ship it as a Raphal plugin. To do this\n\t     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\n\t     * Raphal instance is created, otherwise it will take no effect. Please note that the\n\t     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\n\t     * ensure any namespacing ensures proper context.\n\t     > Usage\n\t     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\n\t     |     return this.path( ... );\n\t     | };\n\t     | // or create namespace\n\t     | Raphael.fn.mystuff = {\n\t     |     arrow: function () {},\n\t     |     star: function () {},\n\t     |     // etc\n\t     | };\n\t     | var paper = Raphael(10, 10, 630, 480);\n\t     | // then use it\n\t     | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\n\t     | paper.mystuff.arrow();\n\t     | paper.mystuff.star();\n\t    \\*/\n\t    R.fn = paperproto = Paper.prototype = R.prototype;\n\t    R._id = 0;\n\t    /*\\\n\t     * Raphael.is\n\t     [ method ]\n\t     **\n\t     * Handful of replacements for `typeof` operator.\n\t     > Parameters\n\t     - o () any object or primitive\n\t     - type (string) name of the type, i.e. string, function, number, etc.\n\t     = (boolean) is given value is of given type\n\t    \\*/\n\t    R.is = function (o, type) {\n\t        type = lowerCase.call(type);\n\t        if (type == \"finite\") {\n\t            return !isnan[has](+o);\n\t        }\n\t        if (type == \"array\") {\n\t            return o instanceof Array;\n\t        }\n\t        return  (type == \"null\" && o === null) ||\n\t                (type == typeof o && o !== null) ||\n\t                (type == \"object\" && o === Object(o)) ||\n\t                (type == \"array\" && Array.isArray && Array.isArray(o)) ||\n\t                objectToString.call(o).slice(8, -1).toLowerCase() == type;\n\t    };\n\n\t    function clone(obj) {\n\t        if (typeof obj == \"function\" || Object(obj) !== obj) {\n\t            return obj;\n\t        }\n\t        var res = new obj.constructor;\n\t        for (var key in obj) if (obj[has](key)) {\n\t            res[key] = clone(obj[key]);\n\t        }\n\t        return res;\n\t    }\n\n\t    /*\\\n\t     * Raphael.angle\n\t     [ method ]\n\t     **\n\t     * Returns angle between two or three points\n\t     > Parameters\n\t     - x1 (number) x coord of first point\n\t     - y1 (number) y coord of first point\n\t     - x2 (number) x coord of second point\n\t     - y2 (number) y coord of second point\n\t     - x3 (number) #optional x coord of third point\n\t     - y3 (number) #optional y coord of third point\n\t     = (number) angle in degrees.\n\t    \\*/\n\t    R.angle = function (x1, y1, x2, y2, x3, y3) {\n\t        if (x3 == null) {\n\t            var x = x1 - x2,\n\t                y = y1 - y2;\n\t            if (!x && !y) {\n\t                return 0;\n\t            }\n\t            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n\t        } else {\n\t            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\n\t        }\n\t    };\n\t    /*\\\n\t     * Raphael.rad\n\t     [ method ]\n\t     **\n\t     * Transform angle to radians\n\t     > Parameters\n\t     - deg (number) angle in degrees\n\t     = (number) angle in radians.\n\t    \\*/\n\t    R.rad = function (deg) {\n\t        return deg % 360 * PI / 180;\n\t    };\n\t    /*\\\n\t     * Raphael.deg\n\t     [ method ]\n\t     **\n\t     * Transform angle to degrees\n\t     > Parameters\n\t     - rad (number) angle in radians\n\t     = (number) angle in degrees.\n\t    \\*/\n\t    R.deg = function (rad) {\n\t        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;\n\t    };\n\t    /*\\\n\t     * Raphael.snapTo\n\t     [ method ]\n\t     **\n\t     * Snaps given value to given grid.\n\t     > Parameters\n\t     - values (array|number) given array of values or step of the grid\n\t     - value (number) value to adjust\n\t     - tolerance (number) #optional tolerance for snapping. Default is `10`.\n\t     = (number) adjusted value.\n\t    \\*/\n\t    R.snapTo = function (values, value, tolerance) {\n\t        tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\n\t        if (R.is(values, array)) {\n\t            var i = values.length;\n\t            while (i--) if (abs(values[i] - value) <= tolerance) {\n\t                return values[i];\n\t            }\n\t        } else {\n\t            values = +values;\n\t            var rem = value % values;\n\t            if (rem < tolerance) {\n\t                return value - rem;\n\t            }\n\t            if (rem > values - tolerance) {\n\t                return value - rem + values;\n\t            }\n\t        }\n\t        return value;\n\t    };\n\n\t    /*\\\n\t     * Raphael.createUUID\n\t     [ method ]\n\t     **\n\t     * Returns RFC4122, version 4 ID\n\t    \\*/\n\t    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {\n\t        return function () {\n\t            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\n\t        };\n\t    })(/[xy]/g, function (c) {\n\t        var r = math.random() * 16 | 0,\n\t            v = c == \"x\" ? r : (r & 3 | 8);\n\t        return v.toString(16);\n\t    });\n\n\t    /*\\\n\t     * Raphael.setWindow\n\t     [ method ]\n\t     **\n\t     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\n\t     > Parameters\n\t     - newwin (window) new window object\n\t    \\*/\n\t    R.setWindow = function (newwin) {\n\t        eve(\"raphael.setWindow\", R, g.win, newwin);\n\t        g.win = newwin;\n\t        g.doc = g.win.document;\n\t        if (R._engine.initWin) {\n\t            R._engine.initWin(g.win);\n\t        }\n\t    };\n\t    var toHex = function (color) {\n\t        if (R.vml) {\n\t            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\n\t            var trim = /^\\s+|\\s+$/g;\n\t            var bod;\n\t            try {\n\t                var docum = new ActiveXObject(\"htmlfile\");\n\t                docum.write(\"<body>\");\n\t                docum.close();\n\t                bod = docum.body;\n\t            } catch(e) {\n\t                bod = createPopup().document.body;\n\t            }\n\t            var range = bod.createTextRange();\n\t            toHex = cacher(function (color) {\n\t                try {\n\t                    bod.style.color = Str(color).replace(trim, E);\n\t                    var value = range.queryCommandValue(\"ForeColor\");\n\t                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\n\t                    return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\n\t                } catch(e) {\n\t                    return \"none\";\n\t                }\n\t            });\n\t        } else {\n\t            var i = g.doc.createElement(\"i\");\n\t            i.title = \"Rapha\\xebl Colour Picker\";\n\t            i.style.display = \"none\";\n\t            g.doc.body.appendChild(i);\n\t            toHex = cacher(function (color) {\n\t                i.style.color = color;\n\t                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n\t            });\n\t        }\n\t        return toHex(color);\n\t    },\n\t    hsbtoString = function () {\n\t        return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n\t    },\n\t    hsltoString = function () {\n\t        return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n\t    },\n\t    rgbtoString = function () {\n\t        return this.hex;\n\t    },\n\t    prepareRGB = function (r, g, b) {\n\t        if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n\t            b = r.b;\n\t            g = r.g;\n\t            r = r.r;\n\t        }\n\t        if (g == null && R.is(r, string)) {\n\t            var clr = R.getRGB(r);\n\t            r = clr.r;\n\t            g = clr.g;\n\t            b = clr.b;\n\t        }\n\t        if (r > 1 || g > 1 || b > 1) {\n\t            r /= 255;\n\t            g /= 255;\n\t            b /= 255;\n\t        }\n\n\t        return [r, g, b];\n\t    },\n\t    packageRGB = function (r, g, b, o) {\n\t        r *= 255;\n\t        g *= 255;\n\t        b *= 255;\n\t        var rgb = {\n\t            r: r,\n\t            g: g,\n\t            b: b,\n\t            hex: R.rgb(r, g, b),\n\t            toString: rgbtoString\n\t        };\n\t        R.is(o, \"finite\") && (rgb.opacity = o);\n\t        return rgb;\n\t    };\n\n\t    /*\\\n\t     * Raphael.color\n\t     [ method ]\n\t     **\n\t     * Parses the color string and returns object with all values for the given color.\n\t     > Parameters\n\t     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\n\t     = (object) Combined RGB & HSB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #,\n\t     o     error (boolean) `true` if string cant be parsed,\n\t     o     h (number) hue,\n\t     o     s (number) saturation,\n\t     o     v (number) value (brightness),\n\t     o     l (number) lightness\n\t     o }\n\t    \\*/\n\t    R.color = function (clr) {\n\t        var rgb;\n\t        if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n\t            rgb = R.hsb2rgb(clr);\n\t            clr.r = rgb.r;\n\t            clr.g = rgb.g;\n\t            clr.b = rgb.b;\n\t            clr.hex = rgb.hex;\n\t        } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n\t            rgb = R.hsl2rgb(clr);\n\t            clr.r = rgb.r;\n\t            clr.g = rgb.g;\n\t            clr.b = rgb.b;\n\t            clr.hex = rgb.hex;\n\t        } else {\n\t            if (R.is(clr, \"string\")) {\n\t                clr = R.getRGB(clr);\n\t            }\n\t            if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\n\t                rgb = R.rgb2hsl(clr);\n\t                clr.h = rgb.h;\n\t                clr.s = rgb.s;\n\t                clr.l = rgb.l;\n\t                rgb = R.rgb2hsb(clr);\n\t                clr.v = rgb.b;\n\t            } else {\n\t                clr = {hex: \"none\"};\n\t                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n\t            }\n\t        }\n\t        clr.toString = rgbtoString;\n\t        return clr;\n\t    };\n\t    /*\\\n\t     * Raphael.hsb2rgb\n\t     [ method ]\n\t     **\n\t     * Converts HSB values to RGB object.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - v (number) value or brightness\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #\n\t     o }\n\t    \\*/\n\t    R.hsb2rgb = function (h, s, v, o) {\n\t        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n\t            v = h.b;\n\t            s = h.s;\n\t            o = h.o;\n\t            h = h.h;\n\t        }\n\t        h *= 360;\n\t        var R, G, B, X, C;\n\t        h = (h % 360) / 60;\n\t        C = v * s;\n\t        X = C * (1 - abs(h % 2 - 1));\n\t        R = G = B = v - C;\n\n\t        h = ~~h;\n\t        R += [C, X, 0, 0, X, C][h];\n\t        G += [X, C, C, X, 0, 0][h];\n\t        B += [0, 0, X, C, C, X][h];\n\t        return packageRGB(R, G, B, o);\n\t    };\n\t    /*\\\n\t     * Raphael.hsl2rgb\n\t     [ method ]\n\t     **\n\t     * Converts HSL values to RGB object.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - l (number) luminosity\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue,\n\t     o     hex (string) color in HTML/CSS format: #\n\t     o }\n\t    \\*/\n\t    R.hsl2rgb = function (h, s, l, o) {\n\t        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n\t            l = h.l;\n\t            s = h.s;\n\t            h = h.h;\n\t        }\n\t        if (h > 1 || s > 1 || l > 1) {\n\t            h /= 360;\n\t            s /= 100;\n\t            l /= 100;\n\t        }\n\t        h *= 360;\n\t        var R, G, B, X, C;\n\t        h = (h % 360) / 60;\n\t        C = 2 * s * (l < .5 ? l : 1 - l);\n\t        X = C * (1 - abs(h % 2 - 1));\n\t        R = G = B = l - C / 2;\n\n\t        h = ~~h;\n\t        R += [C, X, 0, 0, X, C][h];\n\t        G += [X, C, C, X, 0, 0][h];\n\t        B += [0, 0, X, C, C, X][h];\n\t        return packageRGB(R, G, B, o);\n\t    };\n\t    /*\\\n\t     * Raphael.rgb2hsb\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to HSB object.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (object) HSB object in format:\n\t     o {\n\t     o     h (number) hue\n\t     o     s (number) saturation\n\t     o     b (number) brightness\n\t     o }\n\t    \\*/\n\t    R.rgb2hsb = function (r, g, b) {\n\t        b = prepareRGB(r, g, b);\n\t        r = b[0];\n\t        g = b[1];\n\t        b = b[2];\n\n\t        var H, S, V, C;\n\t        V = mmax(r, g, b);\n\t        C = V - mmin(r, g, b);\n\t        H = (C == 0 ? null :\n\t             V == r ? (g - b) / C :\n\t             V == g ? (b - r) / C + 2 :\n\t                      (r - g) / C + 4\n\t            );\n\t        H = ((H + 360) % 6) * 60 / 360;\n\t        S = C == 0 ? 0 : C / V;\n\t        return {h: H, s: S, b: V, toString: hsbtoString};\n\t    };\n\t    /*\\\n\t     * Raphael.rgb2hsl\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to HSL object.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (object) HSL object in format:\n\t     o {\n\t     o     h (number) hue\n\t     o     s (number) saturation\n\t     o     l (number) luminosity\n\t     o }\n\t    \\*/\n\t    R.rgb2hsl = function (r, g, b) {\n\t        b = prepareRGB(r, g, b);\n\t        r = b[0];\n\t        g = b[1];\n\t        b = b[2];\n\n\t        var H, S, L, M, m, C;\n\t        M = mmax(r, g, b);\n\t        m = mmin(r, g, b);\n\t        C = M - m;\n\t        H = (C == 0 ? null :\n\t             M == r ? (g - b) / C :\n\t             M == g ? (b - r) / C + 2 :\n\t                      (r - g) / C + 4);\n\t        H = ((H + 360) % 6) * 60 / 360;\n\t        L = (M + m) / 2;\n\t        S = (C == 0 ? 0 :\n\t             L < .5 ? C / (2 * L) :\n\t                      C / (2 - 2 * L));\n\t        return {h: H, s: S, l: L, toString: hsltoString};\n\t    };\n\t    R._path2string = function () {\n\t        return this.join(\",\").replace(p2s, \"$1\");\n\t    };\n\t    function repush(array, item) {\n\t        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n\t            return array.push(array.splice(i, 1)[0]);\n\t        }\n\t    }\n\t    function cacher(f, scope, postprocessor) {\n\t        function newf() {\n\t            var arg = Array.prototype.slice.call(arguments, 0),\n\t                args = arg.join(\"\\u2400\"),\n\t                cache = newf.cache = newf.cache || {},\n\t                count = newf.count = newf.count || [];\n\t            if (cache[has](args)) {\n\t                repush(count, args);\n\t                return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t            }\n\t            count.length >= 1e3 && delete cache[count.shift()];\n\t            count.push(args);\n\t            cache[args] = f[apply](scope, arg);\n\t            return postprocessor ? postprocessor(cache[args]) : cache[args];\n\t        }\n\t        return newf;\n\t    }\n\n\t    var preload = R._preload = function (src, f) {\n\t        var img = g.doc.createElement(\"img\");\n\t        img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n\t        img.onload = function () {\n\t            f.call(this);\n\t            this.onload = null;\n\t            g.doc.body.removeChild(this);\n\t        };\n\t        img.onerror = function () {\n\t            g.doc.body.removeChild(this);\n\t        };\n\t        g.doc.body.appendChild(img);\n\t        img.src = src;\n\t    };\n\n\t    function clrToString() {\n\t        return this.hex;\n\t    }\n\n\t    /*\\\n\t     * Raphael.getRGB\n\t     [ method ]\n\t     **\n\t     * Parses colour string as RGB object\n\t     > Parameters\n\t     - colour (string) colour string in one of formats:\n\t     # <ul>\n\t     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n\t     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t     #     <li>hsb(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsl(, , )  same as hsb</li>\n\t     #     <li>hsl(%, %, %)  same as hsb</li>\n\t     # </ul>\n\t     = (object) RGB object in format:\n\t     o {\n\t     o     r (number) red,\n\t     o     g (number) green,\n\t     o     b (number) blue\n\t     o     hex (string) color in HTML/CSS format: #,\n\t     o     error (boolean) true if string cant be parsed\n\t     o }\n\t    \\*/\n\t    R.getRGB = cacher(function (colour) {\n\t        if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n\t            return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n\t        }\n\t        if (colour == \"none\") {\n\t            return {r: -1, g: -1, b: -1, hex: \"none\", toString: clrToString};\n\t        }\n\t        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n\t        var res,\n\t            red,\n\t            green,\n\t            blue,\n\t            opacity,\n\t            t,\n\t            values,\n\t            rgb = colour.match(colourRegExp);\n\t        if (rgb) {\n\t            if (rgb[2]) {\n\t                blue = toInt(rgb[2].substring(5), 16);\n\t                green = toInt(rgb[2].substring(3, 5), 16);\n\t                red = toInt(rgb[2].substring(1, 3), 16);\n\t            }\n\t            if (rgb[3]) {\n\t                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n\t                green = toInt((t = rgb[3].charAt(2)) + t, 16);\n\t                red = toInt((t = rgb[3].charAt(1)) + t, 16);\n\t            }\n\t            if (rgb[4]) {\n\t                values = rgb[4][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t            }\n\t            if (rgb[5]) {\n\t                values = rgb[5][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t                return R.hsb2rgb(red, green, blue, opacity);\n\t            }\n\t            if (rgb[6]) {\n\t                values = rgb[6][split](commaSpaces);\n\t                red = toFloat(values[0]);\n\t                values[0].slice(-1) == \"%\" && (red *= 2.55);\n\t                green = toFloat(values[1]);\n\t                values[1].slice(-1) == \"%\" && (green *= 2.55);\n\t                blue = toFloat(values[2]);\n\t                values[2].slice(-1) == \"%\" && (blue *= 2.55);\n\t                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n\t                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n\t                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n\t                return R.hsl2rgb(red, green, blue, opacity);\n\t            }\n\t            rgb = {r: red, g: green, b: blue, toString: clrToString};\n\t            rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\n\t            R.is(opacity, \"finite\") && (rgb.opacity = opacity);\n\t            return rgb;\n\t        }\n\t        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\n\t    }, R);\n\t    /*\\\n\t     * Raphael.hsb\n\t     [ method ]\n\t     **\n\t     * Converts HSB values to hex representation of the colour.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - b (number) value or brightness\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.hsb = cacher(function (h, s, b) {\n\t        return R.hsb2rgb(h, s, b).hex;\n\t    });\n\t    /*\\\n\t     * Raphael.hsl\n\t     [ method ]\n\t     **\n\t     * Converts HSL values to hex representation of the colour.\n\t     > Parameters\n\t     - h (number) hue\n\t     - s (number) saturation\n\t     - l (number) luminosity\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.hsl = cacher(function (h, s, l) {\n\t        return R.hsl2rgb(h, s, l).hex;\n\t    });\n\t    /*\\\n\t     * Raphael.rgb\n\t     [ method ]\n\t     **\n\t     * Converts RGB values to hex representation of the colour.\n\t     > Parameters\n\t     - r (number) red\n\t     - g (number) green\n\t     - b (number) blue\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.rgb = cacher(function (r, g, b) {\n\t        function round(x) { return (x + 0.5) | 0; }\n\t        return \"#\" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);\n\t    });\n\t    /*\\\n\t     * Raphael.getColor\n\t     [ method ]\n\t     **\n\t     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\n\t     > Parameters\n\t     - value (number) #optional brightness, default is `0.75`\n\t     = (string) hex representation of the colour.\n\t    \\*/\n\t    R.getColor = function (value) {\n\t        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},\n\t            rgb = this.hsb2rgb(start.h, start.s, start.b);\n\t        start.h += .075;\n\t        if (start.h > 1) {\n\t            start.h = 0;\n\t            start.s -= .2;\n\t            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});\n\t        }\n\t        return rgb.hex;\n\t    };\n\t    /*\\\n\t     * Raphael.getColor.reset\n\t     [ method ]\n\t     **\n\t     * Resets spectrum position for @Raphael.getColor back to red.\n\t    \\*/\n\t    R.getColor.reset = function () {\n\t        delete this.start;\n\t    };\n\n\t    // http://schepers.cc/getting-to-the-point\n\t    function catmullRom2bezier(crp, z) {\n\t        var d = [];\n\t        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n\t            var p = [\n\t                        {x: +crp[i - 2], y: +crp[i - 1]},\n\t                        {x: +crp[i],     y: +crp[i + 1]},\n\t                        {x: +crp[i + 2], y: +crp[i + 3]},\n\t                        {x: +crp[i + 4], y: +crp[i + 5]}\n\t                    ];\n\t            if (z) {\n\t                if (!i) {\n\t                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n\t                } else if (iLen - 4 == i) {\n\t                    p[3] = {x: +crp[0], y: +crp[1]};\n\t                } else if (iLen - 2 == i) {\n\t                    p[2] = {x: +crp[0], y: +crp[1]};\n\t                    p[3] = {x: +crp[2], y: +crp[3]};\n\t                }\n\t            } else {\n\t                if (iLen - 4 == i) {\n\t                    p[3] = p[2];\n\t                } else if (!i) {\n\t                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n\t                }\n\t            }\n\t            d.push([\"C\",\n\t                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n\t                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n\t                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n\t                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n\t                  p[2].x,\n\t                  p[2].y\n\t            ]);\n\t        }\n\n\t        return d;\n\t    }\n\t    /*\\\n\t     * Raphael.parsePathString\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Parses given path string into an array of arrays of path segments.\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.parsePathString = function (pathString) {\n\t        if (!pathString) {\n\t            return null;\n\t        }\n\t        var pth = paths(pathString);\n\t        if (pth.arr) {\n\t            return pathClone(pth.arr);\n\t        }\n\n\t        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},\n\t            data = [];\n\t        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption\n\t            data = pathClone(pathString);\n\t        }\n\t        if (!data.length) {\n\t            Str(pathString).replace(pathCommand, function (a, b, c) {\n\t                var params = [],\n\t                    name = b.toLowerCase();\n\t                c.replace(pathValues, function (a, b) {\n\t                    b && params.push(+b);\n\t                });\n\t                if (name == \"m\" && params.length > 2) {\n\t                    data.push([b][concat](params.splice(0, 2)));\n\t                    name = \"l\";\n\t                    b = b == \"m\" ? \"l\" : \"L\";\n\t                }\n\t                if (name == \"r\") {\n\t                    data.push([b][concat](params));\n\t                } else while (params.length >= paramCounts[name]) {\n\t                    data.push([b][concat](params.splice(0, paramCounts[name])));\n\t                    if (!paramCounts[name]) {\n\t                        break;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        data.toString = R._path2string;\n\t        pth.arr = pathClone(data);\n\t        return data;\n\t    };\n\t    /*\\\n\t     * Raphael.parseTransformString\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Parses given path string into an array of transformations.\n\t     > Parameters\n\t     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\n\t     = (array) array of transformations.\n\t    \\*/\n\t    R.parseTransformString = cacher(function (TString) {\n\t        if (!TString) {\n\t            return null;\n\t        }\n\t        var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n\t            data = [];\n\t        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption\n\t            data = pathClone(TString);\n\t        }\n\t        if (!data.length) {\n\t            Str(TString).replace(tCommand, function (a, b, c) {\n\t                var params = [],\n\t                    name = lowerCase.call(b);\n\t                c.replace(pathValues, function (a, b) {\n\t                    b && params.push(+b);\n\t                });\n\t                data.push([b][concat](params));\n\t            });\n\t        }\n\t        data.toString = R._path2string;\n\t        return data;\n\t    });\n\t    // PATHS\n\t    var paths = function (ps) {\n\t        var p = paths.ps = paths.ps || {};\n\t        if (p[ps]) {\n\t            p[ps].sleep = 100;\n\t        } else {\n\t            p[ps] = {\n\t                sleep: 100\n\t            };\n\t        }\n\t        setTimeout(function () {\n\t            for (var key in p) if (p[has](key) && key != ps) {\n\t                p[key].sleep--;\n\t                !p[key].sleep && delete p[key];\n\t            }\n\t        });\n\t        return p[ps];\n\t    };\n\t    /*\\\n\t     * Raphael.findDotsAtSegment\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Find dot coordinates on the given cubic bezier curve at the given t.\n\t     > Parameters\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     - t (number) position on the curve (0..1)\n\t     = (object) point information in format:\n\t     o {\n\t     o     x: (number) x coordinate of the point\n\t     o     y: (number) y coordinate of the point\n\t     o     m: {\n\t     o         x: (number) x coordinate of the left anchor\n\t     o         y: (number) y coordinate of the left anchor\n\t     o     }\n\t     o     n: {\n\t     o         x: (number) x coordinate of the right anchor\n\t     o         y: (number) y coordinate of the right anchor\n\t     o     }\n\t     o     start: {\n\t     o         x: (number) x coordinate of the start of the curve\n\t     o         y: (number) y coordinate of the start of the curve\n\t     o     }\n\t     o     end: {\n\t     o         x: (number) x coordinate of the end of the curve\n\t     o         y: (number) y coordinate of the end of the curve\n\t     o     }\n\t     o     alpha: (number) angle of the curve derivative at the point\n\t     o }\n\t    \\*/\n\t    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t        var t1 = 1 - t,\n\t            t13 = pow(t1, 3),\n\t            t12 = pow(t1, 2),\n\t            t2 = t * t,\n\t            t3 = t2 * t,\n\t            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n\t            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n\t            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n\t            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n\t            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n\t            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n\t            ax = t1 * p1x + t * c1x,\n\t            ay = t1 * p1y + t * c1y,\n\t            cx = t1 * c2x + t * p2x,\n\t            cy = t1 * c2y + t * p2y,\n\t            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\n\t        (mx > nx || my < ny) && (alpha += 180);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            m: {x: mx, y: my},\n\t            n: {x: nx, y: ny},\n\t            start: {x: ax, y: ay},\n\t            end: {x: cx, y: cy},\n\t            alpha: alpha\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.bezierBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Return bounding box of a given cubic bezier curve\n\t     > Parameters\n\t     - p1x (number) x of the first point of the curve\n\t     - p1y (number) y of the first point of the curve\n\t     - c1x (number) x of the first anchor of the curve\n\t     - c1y (number) y of the first anchor of the curve\n\t     - c2x (number) x of the second anchor of the curve\n\t     - c2y (number) y of the second anchor of the curve\n\t     - p2x (number) x of the second point of the curve\n\t     - p2y (number) y of the second point of the curve\n\t     * or\n\t     - bez (array) array of six points for bezier curve\n\t     = (object) point information in format:\n\t     o {\n\t     o     min: {\n\t     o         x: (number) x coordinate of the left point\n\t     o         y: (number) y coordinate of the top point\n\t     o     }\n\t     o     max: {\n\t     o         x: (number) x coordinate of the right point\n\t     o         y: (number) y coordinate of the bottom point\n\t     o     }\n\t     o }\n\t    \\*/\n\t    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t        if (!R.is(p1x, \"array\")) {\n\t            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n\t        }\n\t        var bbox = curveDim.apply(null, p1x);\n\t        return {\n\t            x: bbox.min.x,\n\t            y: bbox.min.y,\n\t            x2: bbox.max.x,\n\t            y2: bbox.max.y,\n\t            width: bbox.max.x - bbox.min.x,\n\t            height: bbox.max.y - bbox.min.y\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.isPointInsideBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside bounding boxes.\n\t     > Parameters\n\t     - bbox (string) bounding box\n\t     - x (string) x coordinate of the point\n\t     - y (string) y coordinate of the point\n\t     = (boolean) `true` if point inside\n\t    \\*/\n\t    R.isPointInsideBBox = function (bbox, x, y) {\n\t        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\n\t    };\n\t    /*\\\n\t     * Raphael.isBBoxIntersect\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if two bounding boxes intersect\n\t     > Parameters\n\t     - bbox1 (string) first bounding box\n\t     - bbox2 (string) second bounding box\n\t     = (boolean) `true` if they intersect\n\t    \\*/\n\t    R.isBBoxIntersect = function (bbox1, bbox2) {\n\t        var i = R.isPointInsideBBox;\n\t        return i(bbox2, bbox1.x, bbox1.y)\n\t            || i(bbox2, bbox1.x2, bbox1.y)\n\t            || i(bbox2, bbox1.x, bbox1.y2)\n\t            || i(bbox2, bbox1.x2, bbox1.y2)\n\t            || i(bbox1, bbox2.x, bbox2.y)\n\t            || i(bbox1, bbox2.x2, bbox2.y)\n\t            || i(bbox1, bbox2.x, bbox2.y2)\n\t            || i(bbox1, bbox2.x2, bbox2.y2)\n\t            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n\t            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n\t    };\n\t    function base3(t, p1, p2, p3, p4) {\n\t        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n\t            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n\t        return t * t2 - 3 * p1 + 3 * p2;\n\t    }\n\t    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n\t        if (z == null) {\n\t            z = 1;\n\t        }\n\t        z = z > 1 ? 1 : z < 0 ? 0 : z;\n\t        var z2 = z / 2,\n\t            n = 12,\n\t            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],\n\t            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n\t            sum = 0;\n\t        for (var i = 0; i < n; i++) {\n\t            var ct = z2 * Tvalues[i] + z2,\n\t                xbase = base3(ct, x1, x2, x3, x4),\n\t                ybase = base3(ct, y1, y2, y3, y4),\n\t                comb = xbase * xbase + ybase * ybase;\n\t            sum += Cvalues[i] * math.sqrt(comb);\n\t        }\n\t        return z2 * sum;\n\t    }\n\t    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n\t        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n\t            return;\n\t        }\n\t        var t = 1,\n\t            step = t / 2,\n\t            t2 = t - step,\n\t            l,\n\t            e = .01;\n\t        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        while (abs(l - ll) > e) {\n\t            step /= 2;\n\t            t2 += (l < ll ? 1 : -1) * step;\n\t            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n\t        }\n\t        return t2;\n\t    }\n\t    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\t        if (\n\t            mmax(x1, x2) < mmin(x3, x4) ||\n\t            mmin(x1, x2) > mmax(x3, x4) ||\n\t            mmax(y1, y2) < mmin(y3, y4) ||\n\t            mmin(y1, y2) > mmax(y3, y4)\n\t        ) {\n\t            return;\n\t        }\n\t        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n\t            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n\t            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n\t        if (!denominator) {\n\t            return;\n\t        }\n\t        var px = nx / denominator,\n\t            py = ny / denominator,\n\t            px2 = +px.toFixed(2),\n\t            py2 = +py.toFixed(2);\n\t        if (\n\t            px2 < +mmin(x1, x2).toFixed(2) ||\n\t            px2 > +mmax(x1, x2).toFixed(2) ||\n\t            px2 < +mmin(x3, x4).toFixed(2) ||\n\t            px2 > +mmax(x3, x4).toFixed(2) ||\n\t            py2 < +mmin(y1, y2).toFixed(2) ||\n\t            py2 > +mmax(y1, y2).toFixed(2) ||\n\t            py2 < +mmin(y3, y4).toFixed(2) ||\n\t            py2 > +mmax(y3, y4).toFixed(2)\n\t        ) {\n\t            return;\n\t        }\n\t        return {x: px, y: py};\n\t    }\n\t    function inter(bez1, bez2) {\n\t        return interHelper(bez1, bez2);\n\t    }\n\t    function interCount(bez1, bez2) {\n\t        return interHelper(bez1, bez2, 1);\n\t    }\n\t    function interHelper(bez1, bez2, justCount) {\n\t        var bbox1 = R.bezierBBox(bez1),\n\t            bbox2 = R.bezierBBox(bez2);\n\t        if (!R.isBBoxIntersect(bbox1, bbox2)) {\n\t            return justCount ? 0 : [];\n\t        }\n\t        var l1 = bezlen.apply(0, bez1),\n\t            l2 = bezlen.apply(0, bez2),\n\t            n1 = mmax(~~(l1 / 5), 1),\n\t            n2 = mmax(~~(l2 / 5), 1),\n\t            dots1 = [],\n\t            dots2 = [],\n\t            xy = {},\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0; i < n1 + 1; i++) {\n\t            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\n\t            dots1.push({x: p.x, y: p.y, t: i / n1});\n\t        }\n\t        for (i = 0; i < n2 + 1; i++) {\n\t            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\n\t            dots2.push({x: p.x, y: p.y, t: i / n2});\n\t        }\n\t        for (i = 0; i < n1; i++) {\n\t            for (var j = 0; j < n2; j++) {\n\t                var di = dots1[i],\n\t                    di1 = dots1[i + 1],\n\t                    dj = dots2[j],\n\t                    dj1 = dots2[j + 1],\n\t                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n\t                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n\t                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n\t                if (is) {\n\t                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n\t                        continue;\n\t                    }\n\t                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n\t                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n\t                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n\t                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\n\t                        if (justCount) {\n\t                            res++;\n\t                        } else {\n\t                            res.push({\n\t                                x: is.x,\n\t                                y: is.y,\n\t                                t1: mmin(t1, 1),\n\t                                t2: mmin(t2, 1)\n\t                            });\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    /*\\\n\t     * Raphael.pathIntersection\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Finds intersections of two paths\n\t     > Parameters\n\t     - path1 (string) path string\n\t     - path2 (string) path string\n\t     = (array) dots of intersection\n\t     o [\n\t     o     {\n\t     o         x: (number) x coordinate of the point\n\t     o         y: (number) y coordinate of the point\n\t     o         t1: (number) t value for segment of path1\n\t     o         t2: (number) t value for segment of path2\n\t     o         segment1: (number) order number for segment of path1\n\t     o         segment2: (number) order number for segment of path2\n\t     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1\n\t     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n\t     o     }\n\t     o ]\n\t    \\*/\n\t    R.pathIntersection = function (path1, path2) {\n\t        return interPathHelper(path1, path2);\n\t    };\n\t    R.pathIntersectionNumber = function (path1, path2) {\n\t        return interPathHelper(path1, path2, 1);\n\t    };\n\t    function interPathHelper(path1, path2, justCount) {\n\t        path1 = R._path2curve(path1);\n\t        path2 = R._path2curve(path2);\n\t        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n\t            res = justCount ? 0 : [];\n\t        for (var i = 0, ii = path1.length; i < ii; i++) {\n\t            var pi = path1[i];\n\t            if (pi[0] == \"M\") {\n\t                x1 = x1m = pi[1];\n\t                y1 = y1m = pi[2];\n\t            } else {\n\t                if (pi[0] == \"C\") {\n\t                    bez1 = [x1, y1].concat(pi.slice(1));\n\t                    x1 = bez1[6];\n\t                    y1 = bez1[7];\n\t                } else {\n\t                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n\t                    x1 = x1m;\n\t                    y1 = y1m;\n\t                }\n\t                for (var j = 0, jj = path2.length; j < jj; j++) {\n\t                    var pj = path2[j];\n\t                    if (pj[0] == \"M\") {\n\t                        x2 = x2m = pj[1];\n\t                        y2 = y2m = pj[2];\n\t                    } else {\n\t                        if (pj[0] == \"C\") {\n\t                            bez2 = [x2, y2].concat(pj.slice(1));\n\t                            x2 = bez2[6];\n\t                            y2 = bez2[7];\n\t                        } else {\n\t                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n\t                            x2 = x2m;\n\t                            y2 = y2m;\n\t                        }\n\t                        var intr = interHelper(bez1, bez2, justCount);\n\t                        if (justCount) {\n\t                            res += intr;\n\t                        } else {\n\t                            for (var k = 0, kk = intr.length; k < kk; k++) {\n\t                                intr[k].segment1 = i;\n\t                                intr[k].segment2 = j;\n\t                                intr[k].bez1 = bez1;\n\t                                intr[k].bez2 = bez2;\n\t                            }\n\t                            res = res.concat(intr);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t    /*\\\n\t     * Raphael.isPointInsidePath\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns `true` if given point is inside a given closed path.\n\t     > Parameters\n\t     - path (string) path string\n\t     - x (number) x of the point\n\t     - y (number) y of the point\n\t     = (boolean) true, if point is inside the path\n\t    \\*/\n\t    R.isPointInsidePath = function (path, x, y) {\n\t        var bbox = R.pathBBox(path);\n\t        return R.isPointInsideBBox(bbox, x, y) &&\n\t               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n\t    };\n\t    R._removedFactory = function (methodname) {\n\t        return function () {\n\t            eve(\"raphael.log\", null, \"Rapha\\xebl: you are calling to method \\u201c\" + methodname + \"\\u201d of removed object\", methodname);\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.pathBBox\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Return bounding box of a given path\n\t     > Parameters\n\t     - path (string) path string\n\t     = (object) bounding box\n\t     o {\n\t     o     x: (number) x coordinate of the left top point of the box\n\t     o     y: (number) y coordinate of the left top point of the box\n\t     o     x2: (number) x coordinate of the right bottom point of the box\n\t     o     y2: (number) y coordinate of the right bottom point of the box\n\t     o     width: (number) width of the box\n\t     o     height: (number) height of the box\n\t     o     cx: (number) x coordinate of the center of the box\n\t     o     cy: (number) y coordinate of the center of the box\n\t     o }\n\t    \\*/\n\t    var pathDimensions = R.pathBBox = function (path) {\n\t        var pth = paths(path);\n\t        if (pth.bbox) {\n\t            return clone(pth.bbox);\n\t        }\n\t        if (!path) {\n\t            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};\n\t        }\n\t        path = path2curve(path);\n\t        var x = 0,\n\t            y = 0,\n\t            X = [],\n\t            Y = [],\n\t            p;\n\t        for (var i = 0, ii = path.length; i < ii; i++) {\n\t            p = path[i];\n\t            if (p[0] == \"M\") {\n\t                x = p[1];\n\t                y = p[2];\n\t                X.push(x);\n\t                Y.push(y);\n\t            } else {\n\t                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                X = X[concat](dim.min.x, dim.max.x);\n\t                Y = Y[concat](dim.min.y, dim.max.y);\n\t                x = p[5];\n\t                y = p[6];\n\t            }\n\t        }\n\t        var xmin = mmin[apply](0, X),\n\t            ymin = mmin[apply](0, Y),\n\t            xmax = mmax[apply](0, X),\n\t            ymax = mmax[apply](0, Y),\n\t            width = xmax - xmin,\n\t            height = ymax - ymin,\n\t                bb = {\n\t                x: xmin,\n\t                y: ymin,\n\t                x2: xmax,\n\t                y2: ymax,\n\t                width: width,\n\t                height: height,\n\t                cx: xmin + width / 2,\n\t                cy: ymin + height / 2\n\t            };\n\t        pth.bbox = clone(bb);\n\t        return bb;\n\t    },\n\t        pathClone = function (pathArray) {\n\t            var res = clone(pathArray);\n\t            res.toString = R._path2string;\n\t            return res;\n\t        },\n\t        pathToRelative = R._pathToRelative = function (pathArray) {\n\t            var pth = paths(pathArray);\n\t            if (pth.rel) {\n\t                return pathClone(pth.rel);\n\t            }\n\t            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n\t                pathArray = R.parsePathString(pathArray);\n\t            }\n\t            var res = [],\n\t                x = 0,\n\t                y = 0,\n\t                mx = 0,\n\t                my = 0,\n\t                start = 0;\n\t            if (pathArray[0][0] == \"M\") {\n\t                x = pathArray[0][1];\n\t                y = pathArray[0][2];\n\t                mx = x;\n\t                my = y;\n\t                start++;\n\t                res.push([\"M\", x, y]);\n\t            }\n\t            for (var i = start, ii = pathArray.length; i < ii; i++) {\n\t                var r = res[i] = [],\n\t                    pa = pathArray[i];\n\t                if (pa[0] != lowerCase.call(pa[0])) {\n\t                    r[0] = lowerCase.call(pa[0]);\n\t                    switch (r[0]) {\n\t                        case \"a\":\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +(pa[6] - x).toFixed(3);\n\t                            r[7] = +(pa[7] - y).toFixed(3);\n\t                            break;\n\t                        case \"v\":\n\t                            r[1] = +(pa[1] - y).toFixed(3);\n\t                            break;\n\t                        case \"m\":\n\t                            mx = pa[1];\n\t                            my = pa[2];\n\t                        default:\n\t                            for (var j = 1, jj = pa.length; j < jj; j++) {\n\t                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\n\t                            }\n\t                    }\n\t                } else {\n\t                    r = res[i] = [];\n\t                    if (pa[0] == \"m\") {\n\t                        mx = pa[1] + x;\n\t                        my = pa[2] + y;\n\t                    }\n\t                    for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                        res[i][k] = pa[k];\n\t                    }\n\t                }\n\t                var len = res[i].length;\n\t                switch (res[i][0]) {\n\t                    case \"z\":\n\t                        x = mx;\n\t                        y = my;\n\t                        break;\n\t                    case \"h\":\n\t                        x += +res[i][len - 1];\n\t                        break;\n\t                    case \"v\":\n\t                        y += +res[i][len - 1];\n\t                        break;\n\t                    default:\n\t                        x += +res[i][len - 2];\n\t                        y += +res[i][len - 1];\n\t                }\n\t            }\n\t            res.toString = R._path2string;\n\t            pth.rel = pathClone(res);\n\t            return res;\n\t        },\n\t        pathToAbsolute = R._pathToAbsolute = function (pathArray) {\n\t            var pth = paths(pathArray);\n\t            if (pth.abs) {\n\t                return pathClone(pth.abs);\n\t            }\n\t            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\n\t                pathArray = R.parsePathString(pathArray);\n\t            }\n\t            if (!pathArray || !pathArray.length) {\n\t                return [[\"M\", 0, 0]];\n\t            }\n\t            var res = [],\n\t                x = 0,\n\t                y = 0,\n\t                mx = 0,\n\t                my = 0,\n\t                start = 0;\n\t            if (pathArray[0][0] == \"M\") {\n\t                x = +pathArray[0][1];\n\t                y = +pathArray[0][2];\n\t                mx = x;\n\t                my = y;\n\t                start++;\n\t                res[0] = [\"M\", x, y];\n\t            }\n\t            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\n\t            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n\t                res.push(r = []);\n\t                pa = pathArray[i];\n\t                if (pa[0] != upperCase.call(pa[0])) {\n\t                    r[0] = upperCase.call(pa[0]);\n\t                    switch (r[0]) {\n\t                        case \"A\":\n\t                            r[1] = pa[1];\n\t                            r[2] = pa[2];\n\t                            r[3] = pa[3];\n\t                            r[4] = pa[4];\n\t                            r[5] = pa[5];\n\t                            r[6] = +(pa[6] + x);\n\t                            r[7] = +(pa[7] + y);\n\t                            break;\n\t                        case \"V\":\n\t                            r[1] = +pa[1] + y;\n\t                            break;\n\t                        case \"H\":\n\t                            r[1] = +pa[1] + x;\n\t                            break;\n\t                        case \"R\":\n\t                            var dots = [x, y][concat](pa.slice(1));\n\t                            for (var j = 2, jj = dots.length; j < jj; j++) {\n\t                                dots[j] = +dots[j] + x;\n\t                                dots[++j] = +dots[j] + y;\n\t                            }\n\t                            res.pop();\n\t                            res = res[concat](catmullRom2bezier(dots, crz));\n\t                            break;\n\t                        case \"M\":\n\t                            mx = +pa[1] + x;\n\t                            my = +pa[2] + y;\n\t                        default:\n\t                            for (j = 1, jj = pa.length; j < jj; j++) {\n\t                                r[j] = +pa[j] + ((j % 2) ? x : y);\n\t                            }\n\t                    }\n\t                } else if (pa[0] == \"R\") {\n\t                    dots = [x, y][concat](pa.slice(1));\n\t                    res.pop();\n\t                    res = res[concat](catmullRom2bezier(dots, crz));\n\t                    r = [\"R\"][concat](pa.slice(-2));\n\t                } else {\n\t                    for (var k = 0, kk = pa.length; k < kk; k++) {\n\t                        r[k] = pa[k];\n\t                    }\n\t                }\n\t                switch (r[0]) {\n\t                    case \"Z\":\n\t                        x = mx;\n\t                        y = my;\n\t                        break;\n\t                    case \"H\":\n\t                        x = r[1];\n\t                        break;\n\t                    case \"V\":\n\t                        y = r[1];\n\t                        break;\n\t                    case \"M\":\n\t                        mx = r[r.length - 2];\n\t                        my = r[r.length - 1];\n\t                    default:\n\t                        x = r[r.length - 2];\n\t                        y = r[r.length - 1];\n\t                }\n\t            }\n\t            res.toString = R._path2string;\n\t            pth.abs = pathClone(res);\n\t            return res;\n\t        },\n\t        l2c = function (x1, y1, x2, y2) {\n\t            return [x1, y1, x2, y2, x2, y2];\n\t        },\n\t        q2c = function (x1, y1, ax, ay, x2, y2) {\n\t            var _13 = 1 / 3,\n\t                _23 = 2 / 3;\n\t            return [\n\t                    _13 * x1 + _23 * ax,\n\t                    _13 * y1 + _23 * ay,\n\t                    _13 * x2 + _23 * ax,\n\t                    _13 * y2 + _23 * ay,\n\t                    x2,\n\t                    y2\n\t                ];\n\t        },\n\t        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n\t            // for more information of where this math came from visit:\n\t            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t            var _120 = PI * 120 / 180,\n\t                rad = PI / 180 * (+angle || 0),\n\t                res = [],\n\t                xy,\n\t                rotate = cacher(function (x, y, rad) {\n\t                    var X = x * math.cos(rad) - y * math.sin(rad),\n\t                        Y = x * math.sin(rad) + y * math.cos(rad);\n\t                    return {x: X, y: Y};\n\t                });\n\t            if (!recursive) {\n\t                xy = rotate(x1, y1, -rad);\n\t                x1 = xy.x;\n\t                y1 = xy.y;\n\t                xy = rotate(x2, y2, -rad);\n\t                x2 = xy.x;\n\t                y2 = xy.y;\n\t                var cos = math.cos(PI / 180 * angle),\n\t                    sin = math.sin(PI / 180 * angle),\n\t                    x = (x1 - x2) / 2,\n\t                    y = (y1 - y2) / 2;\n\t                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n\t                if (h > 1) {\n\t                    h = math.sqrt(h);\n\t                    rx = h * rx;\n\t                    ry = h * ry;\n\t                }\n\t                var rx2 = rx * rx,\n\t                    ry2 = ry * ry,\n\t                    k = (large_arc_flag == sweep_flag ? -1 : 1) *\n\t                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n\t                    cx = k * rx * y / ry + (x1 + x2) / 2,\n\t                    cy = k * -ry * x / rx + (y1 + y2) / 2,\n\t                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n\t                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n\t                f1 = x1 < cx ? PI - f1 : f1;\n\t                f2 = x2 < cx ? PI - f2 : f2;\n\t                f1 < 0 && (f1 = PI * 2 + f1);\n\t                f2 < 0 && (f2 = PI * 2 + f2);\n\t                if (sweep_flag && f1 > f2) {\n\t                    f1 = f1 - PI * 2;\n\t                }\n\t                if (!sweep_flag && f2 > f1) {\n\t                    f2 = f2 - PI * 2;\n\t                }\n\t            } else {\n\t                f1 = recursive[0];\n\t                f2 = recursive[1];\n\t                cx = recursive[2];\n\t                cy = recursive[3];\n\t            }\n\t            var df = f2 - f1;\n\t            if (abs(df) > _120) {\n\t                var f2old = f2,\n\t                    x2old = x2,\n\t                    y2old = y2;\n\t                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n\t                x2 = cx + rx * math.cos(f2);\n\t                y2 = cy + ry * math.sin(f2);\n\t                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n\t            }\n\t            df = f2 - f1;\n\t            var c1 = math.cos(f1),\n\t                s1 = math.sin(f1),\n\t                c2 = math.cos(f2),\n\t                s2 = math.sin(f2),\n\t                t = math.tan(df / 4),\n\t                hx = 4 / 3 * rx * t,\n\t                hy = 4 / 3 * ry * t,\n\t                m1 = [x1, y1],\n\t                m2 = [x1 + hx * s1, y1 - hy * c1],\n\t                m3 = [x2 + hx * s2, y2 - hy * c2],\n\t                m4 = [x2, y2];\n\t            m2[0] = 2 * m1[0] - m2[0];\n\t            m2[1] = 2 * m1[1] - m2[1];\n\t            if (recursive) {\n\t                return [m2, m3, m4][concat](res);\n\t            } else {\n\t                res = [m2, m3, m4][concat](res).join()[split](\",\");\n\t                var newres = [];\n\t                for (var i = 0, ii = res.length; i < ii; i++) {\n\t                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n\t                }\n\t                return newres;\n\t            }\n\t        },\n\t        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n\t            var t1 = 1 - t;\n\t            return {\n\t                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n\t                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n\t            };\n\t        },\n\t        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n\t            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),\n\t                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\n\t                c = p1x - c1x,\n\t                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\n\t                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\n\t                y = [p1y, p2y],\n\t                x = [p1x, p2x],\n\t                dot;\n\t            abs(t1) > \"1e12\" && (t1 = .5);\n\t            abs(t2) > \"1e12\" && (t2 = .5);\n\t            if (t1 > 0 && t1 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            if (t2 > 0 && t2 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);\n\t            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\n\t            c = p1y - c1y;\n\t            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\n\t            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\n\t            abs(t1) > \"1e12\" && (t1 = .5);\n\t            abs(t2) > \"1e12\" && (t2 = .5);\n\t            if (t1 > 0 && t1 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            if (t2 > 0 && t2 < 1) {\n\t                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\n\t                x.push(dot.x);\n\t                y.push(dot.y);\n\t            }\n\t            return {\n\t                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},\n\t                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}\n\t            };\n\t        }),\n\t        path2curve = R._path2curve = cacher(function (path, path2) {\n\t            var pth = !path2 && paths(path);\n\t            if (!path2 && pth.curve) {\n\t                return pathClone(pth.curve);\n\t            }\n\t            var p = pathToAbsolute(path),\n\t                p2 = path2 && pathToAbsolute(path2),\n\t                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n\t                processPath = function (path, d, pcom) {\n\t                    var nx, ny, tq = {T:1, Q:1};\n\t                    if (!path) {\n\t                        return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n\t                    }\n\t                    !(path[0] in tq) && (d.qx = d.qy = null);\n\t                    switch (path[0]) {\n\t                        case \"M\":\n\t                            d.X = path[1];\n\t                            d.Y = path[2];\n\t                            break;\n\t                        case \"A\":\n\t                            path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\n\t                            break;\n\t                        case \"S\":\n\t                            if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n\t                                nx = d.x * 2 - d.bx;          // And reflect the previous\n\t                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n\t                            }\n\t                            else {                            // or some else or nothing\n\t                                nx = d.x;\n\t                                ny = d.y;\n\t                            }\n\t                            path = [\"C\", nx, ny][concat](path.slice(1));\n\t                            break;\n\t                        case \"T\":\n\t                            if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n\t                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n\t                                d.qy = d.y * 2 - d.qy;        // to case \"S\".\n\t                            }\n\t                            else {                            // or something else or nothing\n\t                                d.qx = d.x;\n\t                                d.qy = d.y;\n\t                            }\n\t                            path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n\t                            break;\n\t                        case \"Q\":\n\t                            d.qx = path[1];\n\t                            d.qy = path[2];\n\t                            path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n\t                            break;\n\t                        case \"L\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\n\t                            break;\n\t                        case \"H\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\n\t                            break;\n\t                        case \"V\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\n\t                            break;\n\t                        case \"Z\":\n\t                            path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\n\t                            break;\n\t                    }\n\t                    return path;\n\t                },\n\t                fixArc = function (pp, i) {\n\t                    if (pp[i].length > 7) {\n\t                        pp[i].shift();\n\t                        var pi = pp[i];\n\t                        while (pi.length) {\n\t                            pcoms1[i]=\"A\"; // if created multiple C:s, their original seg is saved\n\t                            p2 && (pcoms2[i]=\"A\"); // the same as above\n\t                            pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\n\t                        }\n\t                        pp.splice(i, 1);\n\t                        ii = mmax(p.length, p2 && p2.length || 0);\n\t                    }\n\t                },\n\t                fixM = function (path1, path2, a1, a2, i) {\n\t                    if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n\t                        path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n\t                        a1.bx = 0;\n\t                        a1.by = 0;\n\t                        a1.x = path1[i][1];\n\t                        a1.y = path1[i][2];\n\t                        ii = mmax(p.length, p2 && p2.length || 0);\n\t                    }\n\t                },\n\t                pcoms1 = [], // path commands of original path p\n\t                pcoms2 = [], // path commands of original path p2\n\t                pfirst = \"\", // temporary holder for original path command\n\t                pcom = \"\"; // holder for previous path command of original path\n\t            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n\t                p[i] && (pfirst = p[i][0]); // save current path command\n\n\t                if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n\t                {\n\t                    pcoms1[i] = pfirst; // Save current path command\n\t                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom\n\t                }\n\t                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n\t                if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n\t                // which may produce multiple C:s\n\t                // so we have to make sure that C is also C in original path\n\n\t                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n\t                if (p2) { // the same procedures is done to p2\n\t                    p2[i] && (pfirst = p2[i][0]);\n\t                    if (pfirst != \"C\")\n\t                    {\n\t                        pcoms2[i] = pfirst;\n\t                        i && (pcom = pcoms2[i-1]);\n\t                    }\n\t                    p2[i] = processPath(p2[i], attrs2, pcom);\n\n\t                    if (pcoms2[i]!=\"A\" && pfirst==\"C\") pcoms2[i]=\"C\";\n\n\t                    fixArc(p2, i);\n\t                }\n\t                fixM(p, p2, attrs, attrs2, i);\n\t                fixM(p2, p, attrs2, attrs, i);\n\t                var seg = p[i],\n\t                    seg2 = p2 && p2[i],\n\t                    seglen = seg.length,\n\t                    seg2len = p2 && seg2.length;\n\t                attrs.x = seg[seglen - 2];\n\t                attrs.y = seg[seglen - 1];\n\t                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n\t                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n\t                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n\t                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n\t                attrs2.x = p2 && seg2[seg2len - 2];\n\t                attrs2.y = p2 && seg2[seg2len - 1];\n\t            }\n\t            if (!p2) {\n\t                pth.curve = pathClone(p);\n\t            }\n\t            return p2 ? [p, p2] : p;\n\t        }, null, pathClone),\n\t        parseDots = R._parseDots = cacher(function (gradient) {\n\t            var dots = [];\n\t            for (var i = 0, ii = gradient.length; i < ii; i++) {\n\t                var dot = {},\n\t                    par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\n\t                dot.color = R.getRGB(par[1]);\n\t                if (dot.color.error) {\n\t                    return null;\n\t                }\n\t                dot.opacity = dot.color.opacity;\n\t                dot.color = dot.color.hex;\n\t                par[2] && (dot.offset = par[2] + \"%\");\n\t                dots.push(dot);\n\t            }\n\t            for (i = 1, ii = dots.length - 1; i < ii; i++) {\n\t                if (!dots[i].offset) {\n\t                    var start = toFloat(dots[i - 1].offset || 0),\n\t                        end = 0;\n\t                    for (var j = i + 1; j < ii; j++) {\n\t                        if (dots[j].offset) {\n\t                            end = dots[j].offset;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!end) {\n\t                        end = 100;\n\t                        j = ii;\n\t                    }\n\t                    end = toFloat(end);\n\t                    var d = (end - start) / (j - i + 1);\n\t                    for (; i < j; i++) {\n\t                        start += d;\n\t                        dots[i].offset = start + \"%\";\n\t                    }\n\t                }\n\t            }\n\t            return dots;\n\t        }),\n\t        tear = R._tear = function (el, paper) {\n\t            el == paper.top && (paper.top = el.prev);\n\t            el == paper.bottom && (paper.bottom = el.next);\n\t            el.next && (el.next.prev = el.prev);\n\t            el.prev && (el.prev.next = el.next);\n\t        },\n\t        tofront = R._tofront = function (el, paper) {\n\t            if (paper.top === el) {\n\t                return;\n\t            }\n\t            tear(el, paper);\n\t            el.next = null;\n\t            el.prev = paper.top;\n\t            paper.top.next = el;\n\t            paper.top = el;\n\t        },\n\t        toback = R._toback = function (el, paper) {\n\t            if (paper.bottom === el) {\n\t                return;\n\t            }\n\t            tear(el, paper);\n\t            el.next = paper.bottom;\n\t            el.prev = null;\n\t            paper.bottom.prev = el;\n\t            paper.bottom = el;\n\t        },\n\t        insertafter = R._insertafter = function (el, el2, paper) {\n\t            tear(el, paper);\n\t            el2 == paper.top && (paper.top = el);\n\t            el2.next && (el2.next.prev = el);\n\t            el.next = el2.next;\n\t            el.prev = el2;\n\t            el2.next = el;\n\t        },\n\t        insertbefore = R._insertbefore = function (el, el2, paper) {\n\t            tear(el, paper);\n\t            el2 == paper.bottom && (paper.bottom = el);\n\t            el2.prev && (el2.prev.next = el);\n\t            el.prev = el2.prev;\n\t            el2.prev = el;\n\t            el.next = el2;\n\t        },\n\t        /*\\\n\t         * Raphael.toMatrix\n\t         [ method ]\n\t         **\n\t         * Utility method\n\t         **\n\t         * Returns matrix of transformations applied to a given path\n\t         > Parameters\n\t         - path (string) path string\n\t         - transform (string|array) transformation string\n\t         = (object) @Matrix\n\t        \\*/\n\t        toMatrix = R.toMatrix = function (path, transform) {\n\t            var bb = pathDimensions(path),\n\t                el = {\n\t                    _: {\n\t                        transform: E\n\t                    },\n\t                    getBBox: function () {\n\t                        return bb;\n\t                    }\n\t                };\n\t            extractTransform(el, transform);\n\t            return el.matrix;\n\t        },\n\t        /*\\\n\t         * Raphael.transformPath\n\t         [ method ]\n\t         **\n\t         * Utility method\n\t         **\n\t         * Returns path transformed by a given transformation\n\t         > Parameters\n\t         - path (string) path string\n\t         - transform (string|array) transformation string\n\t         = (string) path\n\t        \\*/\n\t        transformPath = R.transformPath = function (path, transform) {\n\t            return mapPath(path, toMatrix(path, transform));\n\t        },\n\t        extractTransform = R._extractTransform = function (el, tstr) {\n\t            if (tstr == null) {\n\t                return el._.transform;\n\t            }\n\t            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\n\t            var tdata = R.parseTransformString(tstr),\n\t                deg = 0,\n\t                dx = 0,\n\t                dy = 0,\n\t                sx = 1,\n\t                sy = 1,\n\t                _ = el._,\n\t                m = new Matrix;\n\t            _.transform = tdata || [];\n\t            if (tdata) {\n\t                for (var i = 0, ii = tdata.length; i < ii; i++) {\n\t                    var t = tdata[i],\n\t                        tlen = t.length,\n\t                        command = Str(t[0]).toLowerCase(),\n\t                        absolute = t[0] != command,\n\t                        inver = absolute ? m.invert() : 0,\n\t                        x1,\n\t                        y1,\n\t                        x2,\n\t                        y2,\n\t                        bb;\n\t                    if (command == \"t\" && tlen == 3) {\n\t                        if (absolute) {\n\t                            x1 = inver.x(0, 0);\n\t                            y1 = inver.y(0, 0);\n\t                            x2 = inver.x(t[1], t[2]);\n\t                            y2 = inver.y(t[1], t[2]);\n\t                            m.translate(x2 - x1, y2 - y1);\n\t                        } else {\n\t                            m.translate(t[1], t[2]);\n\t                        }\n\t                    } else if (command == \"r\") {\n\t                        if (tlen == 2) {\n\t                            bb = bb || el.getBBox(1);\n\t                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                            deg += t[1];\n\t                        } else if (tlen == 4) {\n\t                            if (absolute) {\n\t                                x2 = inver.x(t[2], t[3]);\n\t                                y2 = inver.y(t[2], t[3]);\n\t                                m.rotate(t[1], x2, y2);\n\t                            } else {\n\t                                m.rotate(t[1], t[2], t[3]);\n\t                            }\n\t                            deg += t[1];\n\t                        }\n\t                    } else if (command == \"s\") {\n\t                        if (tlen == 2 || tlen == 3) {\n\t                            bb = bb || el.getBBox(1);\n\t                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n\t                            sx *= t[1];\n\t                            sy *= t[tlen - 1];\n\t                        } else if (tlen == 5) {\n\t                            if (absolute) {\n\t                                x2 = inver.x(t[3], t[4]);\n\t                                y2 = inver.y(t[3], t[4]);\n\t                                m.scale(t[1], t[2], x2, y2);\n\t                            } else {\n\t                                m.scale(t[1], t[2], t[3], t[4]);\n\t                            }\n\t                            sx *= t[1];\n\t                            sy *= t[2];\n\t                        }\n\t                    } else if (command == \"m\" && tlen == 7) {\n\t                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n\t                    }\n\t                    _.dirtyT = 1;\n\t                    el.matrix = m;\n\t                }\n\t            }\n\n\t            /*\\\n\t             * Element.matrix\n\t             [ property (object) ]\n\t             **\n\t             * Keeps @Matrix object, which represents element transformation\n\t            \\*/\n\t            el.matrix = m;\n\n\t            _.sx = sx;\n\t            _.sy = sy;\n\t            _.deg = deg;\n\t            _.dx = dx = m.e;\n\t            _.dy = dy = m.f;\n\n\t            if (sx == 1 && sy == 1 && !deg && _.bbox) {\n\t                _.bbox.x += +dx;\n\t                _.bbox.y += +dy;\n\t            } else {\n\t                _.dirtyT = 1;\n\t            }\n\t        },\n\t        getEmpty = function (item) {\n\t            var l = item[0];\n\t            switch (l.toLowerCase()) {\n\t                case \"t\": return [l, 0, 0];\n\t                case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n\t                case \"r\": if (item.length == 4) {\n\t                    return [l, 0, item[2], item[3]];\n\t                } else {\n\t                    return [l, 0];\n\t                }\n\t                case \"s\": if (item.length == 5) {\n\t                    return [l, 1, 1, item[3], item[4]];\n\t                } else if (item.length == 3) {\n\t                    return [l, 1, 1];\n\t                } else {\n\t                    return [l, 1];\n\t                }\n\t            }\n\t        },\n\t        equaliseTransform = R._equaliseTransform = function (t1, t2) {\n\t            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\n\t            t1 = R.parseTransformString(t1) || [];\n\t            t2 = R.parseTransformString(t2) || [];\n\t            var maxlength = mmax(t1.length, t2.length),\n\t                from = [],\n\t                to = [],\n\t                i = 0, j, jj,\n\t                tt1, tt2;\n\t            for (; i < maxlength; i++) {\n\t                tt1 = t1[i] || getEmpty(t2[i]);\n\t                tt2 = t2[i] || getEmpty(tt1);\n\t                if ((tt1[0] != tt2[0]) ||\n\t                    (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\n\t                    (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\n\t                    ) {\n\t                    return;\n\t                }\n\t                from[i] = [];\n\t                to[i] = [];\n\t                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\n\t                    j in tt1 && (from[i][j] = tt1[j]);\n\t                    j in tt2 && (to[i][j] = tt2[j]);\n\t                }\n\t            }\n\t            return {\n\t                from: from,\n\t                to: to\n\t            };\n\t        };\n\t    R._getContainer = function (x, y, w, h) {\n\t        var container;\n\t        container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\n\t        if (container == null) {\n\t            return;\n\t        }\n\t        if (container.tagName) {\n\t            if (y == null) {\n\t                return {\n\t                    container: container,\n\t                    width: container.style.pixelWidth || container.offsetWidth,\n\t                    height: container.style.pixelHeight || container.offsetHeight\n\t                };\n\t            } else {\n\t                return {\n\t                    container: container,\n\t                    width: y,\n\t                    height: w\n\t                };\n\t            }\n\t        }\n\t        return {\n\t            container: 1,\n\t            x: x,\n\t            y: y,\n\t            width: w,\n\t            height: h\n\t        };\n\t    };\n\t    /*\\\n\t     * Raphael.pathToRelative\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to relative form\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.pathToRelative = pathToRelative;\n\t    R._engine = {};\n\t    /*\\\n\t     * Raphael.path2curve\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Converts path to a new path where all segments are cubic bezier curves.\n\t     > Parameters\n\t     - pathString (string|array) path string or array of segments\n\t     = (array) array of segments.\n\t    \\*/\n\t    R.path2curve = path2curve;\n\t    /*\\\n\t     * Raphael.matrix\n\t     [ method ]\n\t     **\n\t     * Utility method\n\t     **\n\t     * Returns matrix based on given parameters.\n\t     > Parameters\n\t     - a (number)\n\t     - b (number)\n\t     - c (number)\n\t     - d (number)\n\t     - e (number)\n\t     - f (number)\n\t     = (object) @Matrix\n\t    \\*/\n\t    R.matrix = function (a, b, c, d, e, f) {\n\t        return new Matrix(a, b, c, d, e, f);\n\t    };\n\t    function Matrix(a, b, c, d, e, f) {\n\t        if (a != null) {\n\t            this.a = +a;\n\t            this.b = +b;\n\t            this.c = +c;\n\t            this.d = +d;\n\t            this.e = +e;\n\t            this.f = +f;\n\t        } else {\n\t            this.a = 1;\n\t            this.b = 0;\n\t            this.c = 0;\n\t            this.d = 1;\n\t            this.e = 0;\n\t            this.f = 0;\n\t        }\n\t    }\n\t    (function (matrixproto) {\n\t        /*\\\n\t         * Matrix.add\n\t         [ method ]\n\t         **\n\t         * Adds given matrix to existing one.\n\t         > Parameters\n\t         - a (number)\n\t         - b (number)\n\t         - c (number)\n\t         - d (number)\n\t         - e (number)\n\t         - f (number)\n\t         or\n\t         - matrix (object) @Matrix\n\t        \\*/\n\t        matrixproto.add = function (a, b, c, d, e, f) {\n\t            var out = [[], [], []],\n\t                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\n\t                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\n\t                x, y, z, res;\n\n\t            if (a && a instanceof Matrix) {\n\t                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\n\t            }\n\n\t            for (x = 0; x < 3; x++) {\n\t                for (y = 0; y < 3; y++) {\n\t                    res = 0;\n\t                    for (z = 0; z < 3; z++) {\n\t                        res += m[x][z] * matrix[z][y];\n\t                    }\n\t                    out[x][y] = res;\n\t                }\n\t            }\n\t            this.a = out[0][0];\n\t            this.b = out[1][0];\n\t            this.c = out[0][1];\n\t            this.d = out[1][1];\n\t            this.e = out[0][2];\n\t            this.f = out[1][2];\n\t        };\n\t        /*\\\n\t         * Matrix.invert\n\t         [ method ]\n\t         **\n\t         * Returns inverted version of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.invert = function () {\n\t            var me = this,\n\t                x = me.a * me.d - me.b * me.c;\n\t            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n\t        };\n\t        /*\\\n\t         * Matrix.clone\n\t         [ method ]\n\t         **\n\t         * Returns copy of the matrix\n\t         = (object) @Matrix\n\t        \\*/\n\t        matrixproto.clone = function () {\n\t            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n\t        };\n\t        /*\\\n\t         * Matrix.translate\n\t         [ method ]\n\t         **\n\t         * Translate the matrix\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t        \\*/\n\t        matrixproto.translate = function (x, y) {\n\t            this.add(1, 0, 0, 1, x, y);\n\t        };\n\t        /*\\\n\t         * Matrix.scale\n\t         [ method ]\n\t         **\n\t         * Scales the matrix\n\t         > Parameters\n\t         - x (number)\n\t         - y (number) #optional\n\t         - cx (number) #optional\n\t         - cy (number) #optional\n\t        \\*/\n\t        matrixproto.scale = function (x, y, cx, cy) {\n\t            y == null && (y = x);\n\t            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\n\t            this.add(x, 0, 0, y, 0, 0);\n\t            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\n\t        };\n\t        /*\\\n\t         * Matrix.rotate\n\t         [ method ]\n\t         **\n\t         * Rotates the matrix\n\t         > Parameters\n\t         - a (number)\n\t         - x (number)\n\t         - y (number)\n\t        \\*/\n\t        matrixproto.rotate = function (a, x, y) {\n\t            a = R.rad(a);\n\t            x = x || 0;\n\t            y = y || 0;\n\t            var cos = +math.cos(a).toFixed(9),\n\t                sin = +math.sin(a).toFixed(9);\n\t            this.add(cos, sin, -sin, cos, x, y);\n\t            this.add(1, 0, 0, 1, -x, -y);\n\t        };\n\t        /*\\\n\t         * Matrix.x\n\t         [ method ]\n\t         **\n\t         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t         = (number) x\n\t        \\*/\n\t        matrixproto.x = function (x, y) {\n\t            return x * this.a + y * this.c + this.e;\n\t        };\n\t        /*\\\n\t         * Matrix.y\n\t         [ method ]\n\t         **\n\t         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n\t         > Parameters\n\t         - x (number)\n\t         - y (number)\n\t         = (number) y\n\t        \\*/\n\t        matrixproto.y = function (x, y) {\n\t            return x * this.b + y * this.d + this.f;\n\t        };\n\t        matrixproto.get = function (i) {\n\t            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n\t        };\n\t        matrixproto.toString = function () {\n\t            return R.svg ?\n\t                \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" :\n\t                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\n\t        };\n\t        matrixproto.toFilter = function () {\n\t            return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) +\n\t                \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) +\n\t                \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\n\t        };\n\t        matrixproto.offset = function () {\n\t            return [this.e.toFixed(4), this.f.toFixed(4)];\n\t        };\n\t        function norm(a) {\n\t            return a[0] * a[0] + a[1] * a[1];\n\t        }\n\t        function normalize(a) {\n\t            var mag = math.sqrt(norm(a));\n\t            a[0] && (a[0] /= mag);\n\t            a[1] && (a[1] /= mag);\n\t        }\n\t        /*\\\n\t         * Matrix.split\n\t         [ method ]\n\t         **\n\t         * Splits matrix into primitive transformations\n\t         = (object) in format:\n\t         o dx (number) translation by x\n\t         o dy (number) translation by y\n\t         o scalex (number) scale by x\n\t         o scaley (number) scale by y\n\t         o shear (number) shear\n\t         o rotate (number) rotation in deg\n\t         o isSimple (boolean) could it be represented via simple transformations\n\t        \\*/\n\t        matrixproto.split = function () {\n\t            var out = {};\n\t            // translation\n\t            out.dx = this.e;\n\t            out.dy = this.f;\n\n\t            // scale and shear\n\t            var row = [[this.a, this.c], [this.b, this.d]];\n\t            out.scalex = math.sqrt(norm(row[0]));\n\t            normalize(row[0]);\n\n\t            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n\t            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n\t            out.scaley = math.sqrt(norm(row[1]));\n\t            normalize(row[1]);\n\t            out.shear /= out.scaley;\n\n\t            // rotation\n\t            var sin = -row[0][1],\n\t                cos = row[1][1];\n\t            if (cos < 0) {\n\t                out.rotate = R.deg(math.acos(cos));\n\t                if (sin < 0) {\n\t                    out.rotate = 360 - out.rotate;\n\t                }\n\t            } else {\n\t                out.rotate = R.deg(math.asin(sin));\n\t            }\n\n\t            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n\t            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n\t            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n\t            return out;\n\t        };\n\t        /*\\\n\t         * Matrix.toTransformString\n\t         [ method ]\n\t         **\n\t         * Return transform string that represents given matrix\n\t         = (string) transform string\n\t        \\*/\n\t        matrixproto.toTransformString = function (shorter) {\n\t            var s = shorter || this[split]();\n\t            if (s.isSimple) {\n\t                s.scalex = +s.scalex.toFixed(4);\n\t                s.scaley = +s.scaley.toFixed(4);\n\t                s.rotate = +s.rotate.toFixed(4);\n\t                return  (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) +\n\t                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\n\t                        (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\n\t            } else {\n\t                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n\t            }\n\t        };\n\t    })(Matrix.prototype);\n\n\t    var preventDefault = function () {\n\t        this.returnValue = false;\n\t    },\n\t    preventTouch = function () {\n\t        return this.originalEvent.preventDefault();\n\t    },\n\t    stopPropagation = function () {\n\t        this.cancelBubble = true;\n\t    },\n\t    stopTouch = function () {\n\t        return this.originalEvent.stopPropagation();\n\t    },\n\t    getEventPosition = function (e) {\n\t        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n\n\t        return {\n\t            x: e.clientX + scrollX,\n\t            y: e.clientY + scrollY\n\t        };\n\t    },\n\t    addEvent = (function () {\n\t        if (g.doc.addEventListener) {\n\t            return function (obj, type, fn, element) {\n\t                var f = function (e) {\n\t                    var pos = getEventPosition(e);\n\t                    return fn.call(element, e, pos.x, pos.y);\n\t                };\n\t                obj.addEventListener(type, f, false);\n\n\t                if (supportsTouch && touchMap[type]) {\n\t                    var _f = function (e) {\n\t                        var pos = getEventPosition(e),\n\t                            olde = e;\n\n\t                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n\t                            if (e.targetTouches[i].target == obj) {\n\t                                e = e.targetTouches[i];\n\t                                e.originalEvent = olde;\n\t                                e.preventDefault = preventTouch;\n\t                                e.stopPropagation = stopTouch;\n\t                                break;\n\t                            }\n\t                        }\n\n\t                        return fn.call(element, e, pos.x, pos.y);\n\t                    };\n\t                    obj.addEventListener(touchMap[type], _f, false);\n\t                }\n\n\t                return function () {\n\t                    obj.removeEventListener(type, f, false);\n\n\t                    if (supportsTouch && touchMap[type])\n\t                        obj.removeEventListener(touchMap[type], _f, false);\n\n\t                    return true;\n\t                };\n\t            };\n\t        } else if (g.doc.attachEvent) {\n\t            return function (obj, type, fn, element) {\n\t                var f = function (e) {\n\t                    e = e || g.win.event;\n\t                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n\t                        x = e.clientX + scrollX,\n\t                        y = e.clientY + scrollY;\n\t                    e.preventDefault = e.preventDefault || preventDefault;\n\t                    e.stopPropagation = e.stopPropagation || stopPropagation;\n\t                    return fn.call(element, e, x, y);\n\t                };\n\t                obj.attachEvent(\"on\" + type, f);\n\t                var detacher = function () {\n\t                    obj.detachEvent(\"on\" + type, f);\n\t                    return true;\n\t                };\n\t                return detacher;\n\t            };\n\t        }\n\t    })(),\n\t    drag = [],\n\t    dragMove = function (e) {\n\t        var x = e.clientX,\n\t            y = e.clientY,\n\t            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\n\t            dragi,\n\t            j = drag.length;\n\t        while (j--) {\n\t            dragi = drag[j];\n\t            if (supportsTouch && e.touches) {\n\t                var i = e.touches.length,\n\t                    touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    if (touch.identifier == dragi.el._drag.id) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                e.preventDefault();\n\t            }\n\t            var node = dragi.el.node,\n\t                o,\n\t                next = node.nextSibling,\n\t                parent = node.parentNode,\n\t                display = node.style.display;\n\t            g.win.opera && parent.removeChild(node);\n\t            node.style.display = \"none\";\n\t            o = dragi.el.paper.getElementByPoint(x, y);\n\t            node.style.display = display;\n\t            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n\t            o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\n\t            x += scrollX;\n\t            y += scrollY;\n\t            eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n\t        }\n\t    },\n\t    dragUp = function (e) {\n\t        R.unmousemove(dragMove).unmouseup(dragUp);\n\t        var i = drag.length,\n\t            dragi;\n\t        while (i--) {\n\t            dragi = drag[i];\n\t            dragi.el._drag = {};\n\t            eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n\t        }\n\t        drag = [];\n\t    },\n\t    /*\\\n\t     * Raphael.el\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to elements. This is useful when you want to hack default functionality or\n\t     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\n\t     * you can redefine element method at any time. Expending element methods wouldnt affect set.\n\t     > Usage\n\t     | Raphael.el.red = function () {\n\t     |     this.attr({fill: \"#f00\"});\n\t     | };\n\t     | // then use it\n\t     | paper.circle(100, 100, 20).red();\n\t    \\*/\n\t    elproto = R.el = {};\n\t    /*\\\n\t     * Element.click\n\t     [ method ]\n\t     **\n\t     * Adds event handler for click for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unclick\n\t     [ method ]\n\t     **\n\t     * Removes event handler for click for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.dblclick\n\t     [ method ]\n\t     **\n\t     * Adds event handler for double click for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.undblclick\n\t     [ method ]\n\t     **\n\t     * Removes event handler for double click for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mousedown\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mousedown for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousedown\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mousedown for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mousemove\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mousemove for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmousemove\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mousemove for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseout\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseout for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseout\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseout for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseover\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseover for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseover\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseover for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.mouseup\n\t     [ method ]\n\t     **\n\t     * Adds event handler for mouseup for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.unmouseup\n\t     [ method ]\n\t     **\n\t     * Removes event handler for mouseup for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchstart\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchstart for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchstart\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchstart for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchmove\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchmove for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchmove\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchmove for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchend\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchend for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchend\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchend for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\n\t    /*\\\n\t     * Element.touchcancel\n\t     [ method ]\n\t     **\n\t     * Adds event handler for touchcancel for the element.\n\t     > Parameters\n\t     - handler (function) handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    /*\\\n\t     * Element.untouchcancel\n\t     [ method ]\n\t     **\n\t     * Removes event handler for touchcancel for the element.\n\t     > Parameters\n\t     - handler (function) #optional handler for the event\n\t     = (object) @Element\n\t    \\*/\n\t    for (var i = events.length; i--;) {\n\t        (function (eventName) {\n\t            R[eventName] = elproto[eventName] = function (fn, scope) {\n\t                if (R.is(fn, \"function\")) {\n\t                    this.events = this.events || [];\n\t                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});\n\t                }\n\t                return this;\n\t            };\n\t            R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\n\t                var events = this.events || [],\n\t                    l = events.length;\n\t                while (l--){\n\t                    if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\n\t                        events[l].unbind();\n\t                        events.splice(l, 1);\n\t                        !events.length && delete this.events;\n\t                    }\n\t                }\n\t                return this;\n\t            };\n\t        })(events[i]);\n\t    }\n\n\t    /*\\\n\t     * Element.data\n\t     [ method ]\n\t     **\n\t     * Adds or retrieves given value associated with given key.\n\t     **\n\t     * See also @Element.removeData\n\t     > Parameters\n\t     - key (string) key to store data\n\t     - value (any) #optional value to store\n\t     = (object) @Element\n\t     * or, if value is not specified:\n\t     = (any) value\n\t     * or, if key and value are not specified:\n\t     = (object) Key/value pairs for all the data associated with the element.\n\t     > Usage\n\t     | for (var i = 0, i < 5, i++) {\n\t     |     paper.circle(10 + 15 * i, 10, 10)\n\t     |          .attr({fill: \"#000\"})\n\t     |          .data(\"i\", i)\n\t     |          .click(function () {\n\t     |             alert(this.data(\"i\"));\n\t     |          });\n\t     | }\n\t    \\*/\n\t    elproto.data = function (key, value) {\n\t        var data = eldata[this.id] = eldata[this.id] || {};\n\t        if (arguments.length == 0) {\n\t            return data;\n\t        }\n\t        if (arguments.length == 1) {\n\t            if (R.is(key, \"object\")) {\n\t                for (var i in key) if (key[has](i)) {\n\t                    this.data(i, key[i]);\n\t                }\n\t                return this;\n\t            }\n\t            eve(\"raphael.data.get.\" + this.id, this, data[key], key);\n\t            return data[key];\n\t        }\n\t        data[key] = value;\n\t        eve(\"raphael.data.set.\" + this.id, this, value, key);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.removeData\n\t     [ method ]\n\t     **\n\t     * Removes value associated with an element by given key.\n\t     * If key is not provided, removes all the data of the element.\n\t     > Parameters\n\t     - key (string) #optional key\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.removeData = function (key) {\n\t        if (key == null) {\n\t            eldata[this.id] = {};\n\t        } else {\n\t            eldata[this.id] && delete eldata[this.id][key];\n\t        }\n\t        return this;\n\t    };\n\t     /*\\\n\t     * Element.getData\n\t     [ method ]\n\t     **\n\t     * Retrieves the element data\n\t     = (object) data\n\t    \\*/\n\t    elproto.getData = function () {\n\t        return clone(eldata[this.id] || {});\n\t    };\n\t    /*\\\n\t     * Element.hover\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for hover for the element.\n\t     > Parameters\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     - icontext (object) #optional context for hover in handler\n\t     - ocontext (object) #optional context for hover out handler\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n\t        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n\t    };\n\t    /*\\\n\t     * Element.unhover\n\t     [ method ]\n\t     **\n\t     * Removes event handlers for hover for the element.\n\t     > Parameters\n\t     - f_in (function) handler for hover in\n\t     - f_out (function) handler for hover out\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.unhover = function (f_in, f_out) {\n\t        return this.unmouseover(f_in).unmouseout(f_out);\n\t    };\n\t    var draggable = [];\n\t    /*\\\n\t     * Element.drag\n\t     [ method ]\n\t     **\n\t     * Adds event handlers for drag of the element.\n\t     > Parameters\n\t     - onmove (function) handler for moving\n\t     - onstart (function) handler for drag start\n\t     - onend (function) handler for drag end\n\t     - mcontext (object) #optional context for moving handler\n\t     - scontext (object) #optional context for drag start handler\n\t     - econtext (object) #optional context for drag end handler\n\t     * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,\n\t     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\n\t     * `drag.over.<id>` will be fired as well.\n\t     *\n\t     * Start event and start handler will be called in specified context or in context of the element with following parameters:\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * Move event and move handler will be called in specified context or in context of the element with following parameters:\n\t     o dx (number) shift by x from the start point\n\t     o dy (number) shift by y from the start point\n\t     o x (number) x position of the mouse\n\t     o y (number) y position of the mouse\n\t     o event (object) DOM event object\n\t     * End event and end handler will be called in specified context or in context of the element with following parameters:\n\t     o event (object) DOM event object\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n\t        function start(e) {\n\t            (e.originalEvent || e).preventDefault();\n\t            var x = e.clientX,\n\t                y = e.clientY,\n\t                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\n\t                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\n\t            this._drag.id = e.identifier;\n\t            if (supportsTouch && e.touches) {\n\t                var i = e.touches.length, touch;\n\t                while (i--) {\n\t                    touch = e.touches[i];\n\t                    this._drag.id = touch.identifier;\n\t                    if (touch.identifier == this._drag.id) {\n\t                        x = touch.clientX;\n\t                        y = touch.clientY;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            this._drag.x = x + scrollX;\n\t            this._drag.y = y + scrollY;\n\t            !drag.length && R.mousemove(dragMove).mouseup(dragUp);\n\t            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n\t            onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\n\t            onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\n\t            onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\n\t            eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);\n\t        }\n\t        this._drag = {};\n\t        draggable.push({el: this, start: start});\n\t        this.mousedown(start);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.onDragOver\n\t     [ method ]\n\t     **\n\t     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\n\t     > Parameters\n\t     - f (function) handler for event, first argument would be the element you are dragging over\n\t    \\*/\n\t    elproto.onDragOver = function (f) {\n\t        f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\n\t    };\n\t    /*\\\n\t     * Element.undrag\n\t     [ method ]\n\t     **\n\t     * Removes all drag event handlers from given element.\n\t    \\*/\n\t    elproto.undrag = function () {\n\t        var i = draggable.length;\n\t        while (i--) if (draggable[i].el == this) {\n\t            this.unmousedown(draggable[i].start);\n\t            draggable.splice(i, 1);\n\t            eve.unbind(\"raphael.drag.*.\" + this.id);\n\t        }\n\t        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\n\t        drag = [];\n\t    };\n\t    /*\\\n\t     * Paper.circle\n\t     [ method ]\n\t     **\n\t     * Draws a circle.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - r (number) radius\n\t     = (object) Raphal element object with type circle\n\t     **\n\t     > Usage\n\t     | var c = paper.circle(50, 50, 40);\n\t    \\*/\n\t    paperproto.circle = function (x, y, r) {\n\t        var out = R._engine.circle(this, x || 0, y || 0, r || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.rect\n\t     [ method ]\n\t     *\n\t     * Draws a rectangle.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the top left corner\n\t     - y (number) y coordinate of the top left corner\n\t     - width (number) width\n\t     - height (number) height\n\t     - r (number) #optional radius for rounded corners, default is 0\n\t     = (object) Raphal element object with type rect\n\t     **\n\t     > Usage\n\t     | // regular rectangle\n\t     | var c = paper.rect(10, 10, 50, 50);\n\t     | // rectangle with rounded corners\n\t     | var c = paper.rect(40, 40, 50, 50, 10);\n\t    \\*/\n\t    paperproto.rect = function (x, y, w, h, r) {\n\t        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.ellipse\n\t     [ method ]\n\t     **\n\t     * Draws an ellipse.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the centre\n\t     - y (number) y coordinate of the centre\n\t     - rx (number) horizontal radius\n\t     - ry (number) vertical radius\n\t     = (object) Raphal element object with type ellipse\n\t     **\n\t     > Usage\n\t     | var c = paper.ellipse(50, 50, 40, 20);\n\t    \\*/\n\t    paperproto.ellipse = function (x, y, rx, ry) {\n\t        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.path\n\t     [ method ]\n\t     **\n\t     * Creates a path element by given path data string.\n\t     > Parameters\n\t     - pathString (string) #optional path string in SVG format.\n\t     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\n\t     | \"M10,20L30,40\"\n\t     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.\n\t     *\n\t     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\n\t     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n\t     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n\t     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n\t     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n\t     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n\t     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n\t     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n\t     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n\t     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n\t     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n\t     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n\t     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.\n\t     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.\n\t     > Usage\n\t     | var c = paper.path(\"M10 10L90 90\");\n\t     | // draw a diagonal line:\n\t     | // move to 10,10, line to 90,90\n\t     * For example of path strings, check out these icons: http://raphaeljs.com/icons/\n\t    \\*/\n\t    paperproto.path = function (pathString) {\n\t        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\n\t        var out = R._engine.path(R.format[apply](R, arguments), this);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.image\n\t     [ method ]\n\t     **\n\t     * Embeds an image into the surface.\n\t     **\n\t     > Parameters\n\t     **\n\t     - src (string) URI of the source image\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - width (number) width of the image\n\t     - height (number) height of the image\n\t     = (object) Raphal element object with type image\n\t     **\n\t     > Usage\n\t     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n\t    \\*/\n\t    paperproto.image = function (src, x, y, w, h) {\n\t        var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.text\n\t     [ method ]\n\t     **\n\t     * Draws a text string. If you need line breaks, put \\n in the string.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate position\n\t     - y (number) y coordinate position\n\t     - text (string) The text string to draw\n\t     = (object) Raphal element object with type text\n\t     **\n\t     > Usage\n\t     | var t = paper.text(50, 50, \"Raphal\\nkicks\\nbutt!\");\n\t    \\*/\n\t    paperproto.text = function (x, y, text) {\n\t        var out = R._engine.text(this, x || 0, y || 0, Str(text));\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.set\n\t     [ method ]\n\t     **\n\t     * Creates array-like object to keep and operate several elements at once.\n\t     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.\n\t     * Sets act as pseudo elements  all methods available to an element can be used on a set.\n\t     = (object) array-like object that represents set of elements\n\t     **\n\t     > Usage\n\t     | var st = paper.set();\n\t     | st.push(\n\t     |     paper.circle(10, 10, 5),\n\t     |     paper.circle(30, 10, 5)\n\t     | );\n\t     | st.attr({fill: \"red\"}); // changes the fill of both circles\n\t    \\*/\n\t    paperproto.set = function (itemsArray) {\n\t        !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\n\t        var out = new Set(itemsArray);\n\t        this.__set__ && this.__set__.push(out);\n\t        out[\"paper\"] = this;\n\t        out[\"type\"] = \"set\";\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.setStart\n\t     [ method ]\n\t     **\n\t     * Creates @Paper.set. All elements that will be created after calling this method and before calling\n\t     * @Paper.setFinish will be added to the set.\n\t     **\n\t     > Usage\n\t     | paper.setStart();\n\t     | paper.circle(10, 10, 5),\n\t     | paper.circle(30, 10, 5)\n\t     | var st = paper.setFinish();\n\t     | st.attr({fill: \"red\"}); // changes the fill of both circles\n\t    \\*/\n\t    paperproto.setStart = function (set) {\n\t        this.__set__ = set || this.set();\n\t    };\n\t    /*\\\n\t     * Paper.setFinish\n\t     [ method ]\n\t     **\n\t     * See @Paper.setStart. This method finishes catching and returns resulting set.\n\t     **\n\t     = (object) set\n\t    \\*/\n\t    paperproto.setFinish = function (set) {\n\t        var out = this.__set__;\n\t        delete this.__set__;\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Paper.getSize\n\t     [ method ]\n\t     **\n\t     * Obtains current paper actual size.\n\t     **\n\t     = (object)\n\t     \\*/\n\t    paperproto.getSize = function () {\n\t        var container = this.canvas.parentNode;\n\t        return {\n\t            width: container.offsetWidth,\n\t            height: container.offsetHeight\n\t                };\n\t        };\n\t    /*\\\n\t     * Paper.setSize\n\t     [ method ]\n\t     **\n\t     * If you need to change dimensions of the canvas call this method\n\t     **\n\t     > Parameters\n\t     **\n\t     - width (number) new width of the canvas\n\t     - height (number) new height of the canvas\n\t    \\*/\n\t    paperproto.setSize = function (width, height) {\n\t        return R._engine.setSize.call(this, width, height);\n\t    };\n\t    /*\\\n\t     * Paper.setViewBox\n\t     [ method ]\n\t     **\n\t     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\n\t     * specifying new boundaries.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) new x position, default is `0`\n\t     - y (number) new y position, default is `0`\n\t     - w (number) new width of the canvas\n\t     - h (number) new height of the canvas\n\t     - fit (boolean) `true` if you want graphics to fit into new boundary box\n\t    \\*/\n\t    paperproto.setViewBox = function (x, y, w, h, fit) {\n\t        return R._engine.setViewBox.call(this, x, y, w, h, fit);\n\t    };\n\t    /*\\\n\t     * Paper.top\n\t     [ property ]\n\t     **\n\t     * Points to the topmost element on the paper\n\t    \\*/\n\t    /*\\\n\t     * Paper.bottom\n\t     [ property ]\n\t     **\n\t     * Points to the bottom element on the paper\n\t    \\*/\n\t    paperproto.top = paperproto.bottom = null;\n\t    /*\\\n\t     * Paper.raphael\n\t     [ property ]\n\t     **\n\t     * Points to the @Raphael object/function\n\t    \\*/\n\t    paperproto.raphael = R;\n\t    var getOffset = function (elem) {\n\t        var box = elem.getBoundingClientRect(),\n\t            doc = elem.ownerDocument,\n\t            body = doc.body,\n\t            docElem = doc.documentElement,\n\t            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n\t            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n\t            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n\t        return {\n\t            y: top,\n\t            x: left\n\t        };\n\t    };\n\t    /*\\\n\t     * Paper.getElementByPoint\n\t     [ method ]\n\t     **\n\t     * Returns you topmost element under given point.\n\t     **\n\t     = (object) Raphal element object\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate from the top left corner of the window\n\t     - y (number) y coordinate from the top left corner of the window\n\t     > Usage\n\t     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\t    \\*/\n\t    paperproto.getElementByPoint = function (x, y) {\n\t        var paper = this,\n\t            svg = paper.canvas,\n\t            target = g.doc.elementFromPoint(x, y);\n\t        if (g.win.opera && target.tagName == \"svg\") {\n\t            var so = getOffset(svg),\n\t                sr = svg.createSVGRect();\n\t            sr.x = x - so.x;\n\t            sr.y = y - so.y;\n\t            sr.width = sr.height = 1;\n\t            var hits = svg.getIntersectionList(sr, null);\n\t            if (hits.length) {\n\t                target = hits[hits.length - 1];\n\t            }\n\t        }\n\t        if (!target) {\n\t            return null;\n\t        }\n\t        while (target.parentNode && target != svg.parentNode && !target.raphael) {\n\t            target = target.parentNode;\n\t        }\n\t        target == paper.canvas.parentNode && (target = svg);\n\t        target = target && target.raphael ? paper.getById(target.raphaelid) : null;\n\t        return target;\n\t    };\n\n\t    /*\\\n\t     * Paper.getElementsByBBox\n\t     [ method ]\n\t     **\n\t     * Returns set of elements that have an intersecting bounding box\n\t     **\n\t     > Parameters\n\t     **\n\t     - bbox (object) bbox to check with\n\t     = (object) @Set\n\t     \\*/\n\t    paperproto.getElementsByBBox = function (bbox) {\n\t        var set = this.set();\n\t        this.forEach(function (el) {\n\t            if (R.isBBoxIntersect(el.getBBox(), bbox)) {\n\t                set.push(el);\n\t            }\n\t        });\n\t        return set;\n\t    };\n\n\t    /*\\\n\t     * Paper.getById\n\t     [ method ]\n\t     **\n\t     * Returns you element by its internal ID.\n\t     **\n\t     > Parameters\n\t     **\n\t     - id (number) id\n\t     = (object) Raphal element object\n\t    \\*/\n\t    paperproto.getById = function (id) {\n\t        var bot = this.bottom;\n\t        while (bot) {\n\t            if (bot.id == id) {\n\t                return bot;\n\t            }\n\t            bot = bot.next;\n\t        }\n\t        return null;\n\t    };\n\t    /*\\\n\t     * Paper.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element on the paper\n\t     *\n\t     * If callback function returns `false` it will stop loop running.\n\t     **\n\t     > Parameters\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Paper object\n\t     > Usage\n\t     | paper.forEach(function (el) {\n\t     |     el.attr({ stroke: \"blue\" });\n\t     | });\n\t    \\*/\n\t    paperproto.forEach = function (callback, thisArg) {\n\t        var bot = this.bottom;\n\t        while (bot) {\n\t            if (callback.call(thisArg, bot) === false) {\n\t                return this;\n\t            }\n\t            bot = bot.next;\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Paper.getElementsByPoint\n\t     [ method ]\n\t     **\n\t     * Returns set of elements that have common point inside\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (object) @Set\n\t    \\*/\n\t    paperproto.getElementsByPoint = function (x, y) {\n\t        var set = this.set();\n\t        this.forEach(function (el) {\n\t            if (el.isPointInside(x, y)) {\n\t                set.push(el);\n\t            }\n\t        });\n\t        return set;\n\t    };\n\t    function x_y() {\n\t        return this.x + S + this.y;\n\t    }\n\t    function x_y_w_h() {\n\t        return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n\t    }\n\t    /*\\\n\t     * Element.isPointInside\n\t     [ method ]\n\t     **\n\t     * Determine if given point is inside this elements shape\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (boolean) `true` if point inside the shape\n\t    \\*/\n\t    elproto.isPointInside = function (x, y) {\n\t        var rp = this.realPath = getPath[this.type](this);\n\t        if (this.attr('transform') && this.attr('transform').length) {\n\t            rp = R.transformPath(rp, this.attr('transform'));\n\t        }\n\t        return R.isPointInsidePath(rp, x, y);\n\t    };\n\t    /*\\\n\t     * Element.getBBox\n\t     [ method ]\n\t     **\n\t     * Return bounding box for a given element\n\t     **\n\t     > Parameters\n\t     **\n\t     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\n\t     = (object) Bounding box object:\n\t     o {\n\t     o     x: (number) top left corner x\n\t     o     y: (number) top left corner y\n\t     o     x2: (number) bottom right corner x\n\t     o     y2: (number) bottom right corner y\n\t     o     width: (number) width\n\t     o     height: (number) height\n\t     o }\n\t    \\*/\n\t    elproto.getBBox = function (isWithoutTransform) {\n\t        if (this.removed) {\n\t            return {};\n\t        }\n\t        var _ = this._;\n\t        if (isWithoutTransform) {\n\t            if (_.dirty || !_.bboxwt) {\n\t                this.realPath = getPath[this.type](this);\n\t                _.bboxwt = pathDimensions(this.realPath);\n\t                _.bboxwt.toString = x_y_w_h;\n\t                _.dirty = 0;\n\t            }\n\t            return _.bboxwt;\n\t        }\n\t        if (_.dirty || _.dirtyT || !_.bbox) {\n\t            if (_.dirty || !this.realPath) {\n\t                _.bboxwt = 0;\n\t                this.realPath = getPath[this.type](this);\n\t            }\n\t            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\n\t            _.bbox.toString = x_y_w_h;\n\t            _.dirty = _.dirtyT = 0;\n\t        }\n\t        return _.bbox;\n\t    };\n\t    /*\\\n\t     * Element.clone\n\t     [ method ]\n\t     **\n\t     = (object) clone of a given element\n\t     **\n\t    \\*/\n\t    elproto.clone = function () {\n\t        if (this.removed) {\n\t            return null;\n\t        }\n\t        var out = this.paper[this.type]().attr(this.attr());\n\t        this.__set__ && this.__set__.push(out);\n\t        return out;\n\t    };\n\t    /*\\\n\t     * Element.glow\n\t     [ method ]\n\t     **\n\t     * Return set of elements that create glow-like effect around given element. See @Paper.set.\n\t     *\n\t     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.\n\t     **\n\t     > Parameters\n\t     **\n\t     - glow (object) #optional parameters object with all properties optional:\n\t     o {\n\t     o     width (number) size of the glow, default is `10`\n\t     o     fill (boolean) will it be filled, default is `false`\n\t     o     opacity (number) opacity, default is `0.5`\n\t     o     offsetx (number) horizontal offset, default is `0`\n\t     o     offsety (number) vertical offset, default is `0`\n\t     o     color (string) glow colour, default is `black`\n\t     o }\n\t     = (object) @Paper.set of elements that represents glow\n\t    \\*/\n\t    elproto.glow = function (glow) {\n\t        if (this.type == \"text\") {\n\t            return null;\n\t        }\n\t        glow = glow || {};\n\t        var s = {\n\t            width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\n\t            fill: glow.fill || false,\n\t            opacity: glow.opacity == null ? .5 : glow.opacity,\n\t            offsetx: glow.offsetx || 0,\n\t            offsety: glow.offsety || 0,\n\t            color: glow.color || \"#000\"\n\t        },\n\t            c = s.width / 2,\n\t            r = this.paper,\n\t            out = r.set(),\n\t            path = this.realPath || getPath[this.type](this);\n\t        path = this.matrix ? mapPath(path, this.matrix) : path;\n\t        for (var i = 1; i < c + 1; i++) {\n\t            out.push(r.path(path).attr({\n\t                stroke: s.color,\n\t                fill: s.fill ? s.color : \"none\",\n\t                \"stroke-linejoin\": \"round\",\n\t                \"stroke-linecap\": \"round\",\n\t                \"stroke-width\": +(s.width / c * i).toFixed(3),\n\t                opacity: +(s.opacity / c).toFixed(3)\n\t            }));\n\t        }\n\t        return out.insertBefore(this).translate(s.offsetx, s.offsety);\n\t    };\n\t    var curveslengths = {},\n\t    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n\t        if (length == null) {\n\t            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\t        } else {\n\t            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n\t        }\n\t    },\n\t    getLengthFactory = function (istotal, subpath) {\n\t        return function (path, length, onlystart) {\n\t            path = path2curve(path);\n\t            var x, y, p, l, sp = \"\", subpaths = {}, point,\n\t                len = 0;\n\t            for (var i = 0, ii = path.length; i < ii; i++) {\n\t                p = path[i];\n\t                if (p[0] == \"M\") {\n\t                    x = +p[1];\n\t                    y = +p[2];\n\t                } else {\n\t                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n\t                    if (len + l > length) {\n\t                        if (subpath && !subpaths.start) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\n\t                            if (onlystart) {return sp;}\n\t                            subpaths.start = sp;\n\t                            sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\n\t                            len += l;\n\t                            x = +p[5];\n\t                            y = +p[6];\n\t                            continue;\n\t                        }\n\t                        if (!istotal && !subpath) {\n\t                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n\t                            return {x: point.x, y: point.y, alpha: point.alpha};\n\t                        }\n\t                    }\n\t                    len += l;\n\t                    x = +p[5];\n\t                    y = +p[6];\n\t                }\n\t                sp += p.shift() + p;\n\t            }\n\t            subpaths.end = sp;\n\t            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n\t            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});\n\t            return point;\n\t        };\n\t    };\n\t    var getTotalLength = getLengthFactory(1),\n\t        getPointAtLength = getLengthFactory(),\n\t        getSubpathsAtLength = getLengthFactory(0, 1);\n\t    /*\\\n\t     * Raphael.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns length of the given path in pixels.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string.\n\t     **\n\t     = (number) length.\n\t    \\*/\n\t    R.getTotalLength = getTotalLength;\n\t    /*\\\n\t     * Raphael.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Return coordinates of the point located at the given length on the given path.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string\n\t     - length (number)\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate\n\t     o     y: (number) y coordinate\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    R.getPointAtLength = getPointAtLength;\n\t    /*\\\n\t     * Raphael.getSubpath\n\t     [ method ]\n\t     **\n\t     * Return subpath of a given path from given length to given length.\n\t     **\n\t     > Parameters\n\t     **\n\t     - path (string) SVG path string\n\t     - from (number) position of the start of the segment\n\t     - to (number) position of the end of the segment\n\t     **\n\t     = (string) pathstring for the segment\n\t    \\*/\n\t    R.getSubpath = function (path, from, to) {\n\t        if (this.getTotalLength(path) - to < 1e-6) {\n\t            return getSubpathsAtLength(path, from).end;\n\t        }\n\t        var a = getSubpathsAtLength(path, to, 1);\n\t        return from ? getSubpathsAtLength(a, from).end : a;\n\t    };\n\t    /*\\\n\t     * Element.getTotalLength\n\t     [ method ]\n\t     **\n\t     * Returns length of the path in pixels. Only works for element of path type.\n\t     = (number) length.\n\t    \\*/\n\t    elproto.getTotalLength = function () {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        if (this.node.getTotalLength) {\n\t            return this.node.getTotalLength();\n\t        }\n\n\t        return getTotalLength(path);\n\t    };\n\t    /*\\\n\t     * Element.getPointAtLength\n\t     [ method ]\n\t     **\n\t     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.\n\t     **\n\t     > Parameters\n\t     **\n\t     - length (number)\n\t     **\n\t     = (object) representation of the point:\n\t     o {\n\t     o     x: (number) x coordinate\n\t     o     y: (number) y coordinate\n\t     o     alpha: (number) angle of derivative\n\t     o }\n\t    \\*/\n\t    elproto.getPointAtLength = function (length) {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        return getPointAtLength(path, length);\n\t    };\n\t    /*\\\n\t     * Element.getPath\n\t     [ method ]\n\t     **\n\t     * Returns path of the element. Only works for elements of path type and simple elements like circle.\n\t     = (object) path\n\t     **\n\t    \\*/\n\t    elproto.getPath = function () {\n\t        var path,\n\t            getPath = R._getPath[this.type];\n\n\t        if (this.type == \"text\" || this.type == \"set\") {\n\t            return;\n\t        }\n\n\t        if (getPath) {\n\t            path = getPath(this);\n\t        }\n\n\t        return path;\n\t    };\n\t    /*\\\n\t     * Element.getSubpath\n\t     [ method ]\n\t     **\n\t     * Return subpath of a given element from given length to given length. Only works for element of path type.\n\t     **\n\t     > Parameters\n\t     **\n\t     - from (number) position of the start of the segment\n\t     - to (number) position of the end of the segment\n\t     **\n\t     = (string) pathstring for the segment\n\t    \\*/\n\t    elproto.getSubpath = function (from, to) {\n\t        var path = this.getPath();\n\t        if (!path) {\n\t            return;\n\t        }\n\n\t        return R.getSubpath(path, from, to);\n\t    };\n\t    /*\\\n\t     * Raphael.easing_formulas\n\t     [ property ]\n\t     **\n\t     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\n\t     # <ul>\n\t     #     <li>linear</li>\n\t     #     <li>&lt; or easeIn or ease-in</li>\n\t     #     <li>> or easeOut or ease-out</li>\n\t     #     <li>&lt;> or easeInOut or ease-in-out</li>\n\t     #     <li>backIn or back-in</li>\n\t     #     <li>backOut or back-out</li>\n\t     #     <li>elastic</li>\n\t     #     <li>bounce</li>\n\t     # </ul>\n\t     # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\n\t    \\*/\n\t    var ef = R.easing_formulas = {\n\t        linear: function (n) {\n\t            return n;\n\t        },\n\t        \"<\": function (n) {\n\t            return pow(n, 1.7);\n\t        },\n\t        \">\": function (n) {\n\t            return pow(n, .48);\n\t        },\n\t        \"<>\": function (n) {\n\t            var q = .48 - n / 1.04,\n\t                Q = math.sqrt(.1734 + q * q),\n\t                x = Q - q,\n\t                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n\t                y = -Q - q,\n\t                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n\t                t = X + Y + .5;\n\t            return (1 - t) * 3 * t * t + t * t * t;\n\t        },\n\t        backIn: function (n) {\n\t            var s = 1.70158;\n\t            return n * n * ((s + 1) * n - s);\n\t        },\n\t        backOut: function (n) {\n\t            n = n - 1;\n\t            var s = 1.70158;\n\t            return n * n * ((s + 1) * n + s) + 1;\n\t        },\n\t        elastic: function (n) {\n\t            if (n == !!n) {\n\t                return n;\n\t            }\n\t            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\n\t        },\n\t        bounce: function (n) {\n\t            var s = 7.5625,\n\t                p = 2.75,\n\t                l;\n\t            if (n < (1 / p)) {\n\t                l = s * n * n;\n\t            } else {\n\t                if (n < (2 / p)) {\n\t                    n -= (1.5 / p);\n\t                    l = s * n * n + .75;\n\t                } else {\n\t                    if (n < (2.5 / p)) {\n\t                        n -= (2.25 / p);\n\t                        l = s * n * n + .9375;\n\t                    } else {\n\t                        n -= (2.625 / p);\n\t                        l = s * n * n + .984375;\n\t                    }\n\t                }\n\t            }\n\t            return l;\n\t        }\n\t    };\n\t    ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\n\t    ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\n\t    ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\n\t    ef[\"back-in\"] = ef.backIn;\n\t    ef[\"back-out\"] = ef.backOut;\n\n\t    var animationElements = [],\n\t        requestAnimFrame = window.requestAnimationFrame       ||\n\t                           window.webkitRequestAnimationFrame ||\n\t                           window.mozRequestAnimationFrame    ||\n\t                           window.oRequestAnimationFrame      ||\n\t                           window.msRequestAnimationFrame     ||\n\t                           function (callback) {\n\t                               setTimeout(callback, 16);\n\t                           },\n\t        animation = function () {\n\t            var Now = +new Date,\n\t                l = 0;\n\t            for (; l < animationElements.length; l++) {\n\t                var e = animationElements[l];\n\t                if (e.el.removed || e.paused) {\n\t                    continue;\n\t                }\n\t                var time = Now - e.start,\n\t                    ms = e.ms,\n\t                    easing = e.easing,\n\t                    from = e.from,\n\t                    diff = e.diff,\n\t                    to = e.to,\n\t                    t = e.t,\n\t                    that = e.el,\n\t                    set = {},\n\t                    now,\n\t                    init = {},\n\t                    key;\n\t                if (e.initstatus) {\n\t                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\n\t                    e.status = e.initstatus;\n\t                    delete e.initstatus;\n\t                    e.stop && animationElements.splice(l--, 1);\n\t                } else {\n\t                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\n\t                }\n\t                if (time < 0) {\n\t                    continue;\n\t                }\n\t                if (time < ms) {\n\t                    var pos = easing(time / ms);\n\t                    for (var attr in from) if (from[has](attr)) {\n\t                        switch (availableAnimAttrs[attr]) {\n\t                            case nu:\n\t                                now = +from[attr] + pos * ms * diff[attr];\n\t                                break;\n\t                            case \"colour\":\n\t                                now = \"rgb(\" + [\n\t                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),\n\t                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),\n\t                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))\n\t                                ].join(\",\") + \")\";\n\t                                break;\n\t                            case \"path\":\n\t                                now = [];\n\t                                for (var i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                    now[i] = [from[attr][i][0]];\n\t                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\n\t                                    }\n\t                                    now[i] = now[i].join(S);\n\t                                }\n\t                                now = now.join(S);\n\t                                break;\n\t                            case \"transform\":\n\t                                if (diff[attr].real) {\n\t                                    now = [];\n\t                                    for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                        now[i] = [from[attr][i][0]];\n\t                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    var get = function (i) {\n\t                                        return +from[attr][i] + pos * ms * diff[attr][i];\n\t                                    };\n\t                                    // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\n\t                                    now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\n\t                                }\n\t                                break;\n\t                            case \"csv\":\n\t                                if (attr == \"clip-rect\") {\n\t                                    now = [];\n\t                                    i = 4;\n\t                                    while (i--) {\n\t                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];\n\t                                    }\n\t                                }\n\t                                break;\n\t                            default:\n\t                                var from2 = [][concat](from[attr]);\n\t                                now = [];\n\t                                i = that.paper.customAttributes[attr].length;\n\t                                while (i--) {\n\t                                    now[i] = +from2[i] + pos * ms * diff[attr][i];\n\t                                }\n\t                                break;\n\t                        }\n\t                        set[attr] = now;\n\t                    }\n\t                    that.attr(set);\n\t                    (function (id, that, anim) {\n\t                        setTimeout(function () {\n\t                            eve(\"raphael.anim.frame.\" + id, that, anim);\n\t                        });\n\t                    })(that.id, that, e.anim);\n\t                } else {\n\t                    (function(f, el, a) {\n\t                        setTimeout(function() {\n\t                            eve(\"raphael.anim.frame.\" + el.id, el, a);\n\t                            eve(\"raphael.anim.finish.\" + el.id, el, a);\n\t                            R.is(f, \"function\") && f.call(el);\n\t                        });\n\t                    })(e.callback, that, e.anim);\n\t                    that.attr(to);\n\t                    animationElements.splice(l--, 1);\n\t                    if (e.repeat > 1 && !e.next) {\n\t                        for (key in to) if (to[has](key)) {\n\t                            init[key] = e.totalOrigin[key];\n\t                        }\n\t                        e.el.attr(init);\n\t                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\n\t                    }\n\t                    if (e.next && !e.stop) {\n\t                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\n\t                    }\n\t                }\n\t            }\n\t            animationElements.length && requestAnimFrame(animation);\n\t        },\n\t        upto255 = function (color) {\n\t            return color > 255 ? 255 : color < 0 ? 0 : color;\n\t        };\n\t    /*\\\n\t     * Element.animateWith\n\t     [ method ]\n\t     **\n\t     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - el (object) element to sync with\n\t     - anim (object) animation to sync with\n\t     - params (object) #optional final attributes for the element, see also @Element.attr\n\t     - ms (number) #optional number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     * or\n\t     - element (object) element to sync with\n\t     - anim (object) animation to sync with\n\t     - animation (object) #optional animation object, see @Raphael.animation\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.animateWith = function (el, anim, params, ms, easing, callback) {\n\t        var element = this;\n\t        if (element.removed) {\n\t            callback && callback.call(element);\n\t            return element;\n\t        }\n\t        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\n\t            x, y;\n\t        runAnimation(a, element, a.percents[0], null, element.attr());\n\t        for (var i = 0, ii = animationElements.length; i < ii; i++) {\n\t            if (animationElements[i].anim == anim && animationElements[i].el == el) {\n\t                animationElements[ii - 1].start = animationElements[i].start;\n\t                break;\n\t            }\n\t        }\n\t        return element;\n\t        //\n\t        //\n\t        // var a = params ? R.animation(params, ms, easing, callback) : anim,\n\t        //     status = element.status(anim);\n\t        // return this.animate(a).status(a, status * anim.ms / a.ms);\n\t    };\n\t    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\n\t        var cx = 3 * p1x,\n\t            bx = 3 * (p2x - p1x) - cx,\n\t            ax = 1 - cx - bx,\n\t            cy = 3 * p1y,\n\t            by = 3 * (p2y - p1y) - cy,\n\t            ay = 1 - cy - by;\n\t        function sampleCurveX(t) {\n\t            return ((ax * t + bx) * t + cx) * t;\n\t        }\n\t        function solve(x, epsilon) {\n\t            var t = solveCurveX(x, epsilon);\n\t            return ((ay * t + by) * t + cy) * t;\n\t        }\n\t        function solveCurveX(x, epsilon) {\n\t            var t0, t1, t2, x2, d2, i;\n\t            for(t2 = x, i = 0; i < 8; i++) {\n\t                x2 = sampleCurveX(t2) - x;\n\t                if (abs(x2) < epsilon) {\n\t                    return t2;\n\t                }\n\t                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\n\t                if (abs(d2) < 1e-6) {\n\t                    break;\n\t                }\n\t                t2 = t2 - x2 / d2;\n\t            }\n\t            t0 = 0;\n\t            t1 = 1;\n\t            t2 = x;\n\t            if (t2 < t0) {\n\t                return t0;\n\t            }\n\t            if (t2 > t1) {\n\t                return t1;\n\t            }\n\t            while (t0 < t1) {\n\t                x2 = sampleCurveX(t2);\n\t                if (abs(x2 - x) < epsilon) {\n\t                    return t2;\n\t                }\n\t                if (x > x2) {\n\t                    t0 = t2;\n\t                } else {\n\t                    t1 = t2;\n\t                }\n\t                t2 = (t1 - t0) / 2 + t0;\n\t            }\n\t            return t2;\n\t        }\n\t        return solve(t, 1 / (200 * duration));\n\t    }\n\t    elproto.onAnimation = function (f) {\n\t        f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\n\t        return this;\n\t    };\n\t    function Animation(anim, ms) {\n\t        var percents = [],\n\t            newAnim = {};\n\t        this.ms = ms;\n\t        this.times = 1;\n\t        if (anim) {\n\t            for (var attr in anim) if (anim[has](attr)) {\n\t                newAnim[toFloat(attr)] = anim[attr];\n\t                percents.push(toFloat(attr));\n\t            }\n\t            percents.sort(sortByNumber);\n\t        }\n\t        this.anim = newAnim;\n\t        this.top = percents[percents.length - 1];\n\t        this.percents = percents;\n\t    }\n\t    /*\\\n\t     * Animation.delay\n\t     [ method ]\n\t     **\n\t     * Creates a copy of existing animation object with given delay.\n\t     **\n\t     > Parameters\n\t     **\n\t     - delay (number) number of ms to pass between animation start and actual animation\n\t     **\n\t     = (object) new altered Animation object\n\t     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\n\t     | circle1.animate(anim); // run the given animation immediately\n\t     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\n\t    \\*/\n\t    Animation.prototype.delay = function (delay) {\n\t        var a = new Animation(this.anim, this.ms);\n\t        a.times = this.times;\n\t        a.del = +delay || 0;\n\t        return a;\n\t    };\n\t    /*\\\n\t     * Animation.repeat\n\t     [ method ]\n\t     **\n\t     * Creates a copy of existing animation object with given repetition.\n\t     **\n\t     > Parameters\n\t     **\n\t     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\n\t     **\n\t     = (object) new altered Animation object\n\t    \\*/\n\t    Animation.prototype.repeat = function (times) {\n\t        var a = new Animation(this.anim, this.ms);\n\t        a.del = this.del;\n\t        a.times = math.floor(mmax(times, 0)) || 1;\n\t        return a;\n\t    };\n\t    function runAnimation(anim, element, percent, status, totalOrigin, times) {\n\t        percent = toFloat(percent);\n\t        var params,\n\t            isInAnim,\n\t            isInAnimSet,\n\t            percents = [],\n\t            next,\n\t            prev,\n\t            timestamp,\n\t            ms = anim.ms,\n\t            from = {},\n\t            to = {},\n\t            diff = {};\n\t        if (status) {\n\t            for (i = 0, ii = animationElements.length; i < ii; i++) {\n\t                var e = animationElements[i];\n\t                if (e.el.id == element.id && e.anim == anim) {\n\t                    if (e.percent != percent) {\n\t                        animationElements.splice(i, 1);\n\t                        isInAnimSet = 1;\n\t                    } else {\n\t                        isInAnim = e;\n\t                    }\n\t                    element.attr(e.totalOrigin);\n\t                    break;\n\t                }\n\t            }\n\t        } else {\n\t            status = +to; // NaN\n\t        }\n\t        for (var i = 0, ii = anim.percents.length; i < ii; i++) {\n\t            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\n\t                percent = anim.percents[i];\n\t                prev = anim.percents[i - 1] || 0;\n\t                ms = ms / anim.top * (percent - prev);\n\t                next = anim.percents[i + 1];\n\t                params = anim.anim[percent];\n\t                break;\n\t            } else if (status) {\n\t                element.attr(anim.anim[anim.percents[i]]);\n\t            }\n\t        }\n\t        if (!params) {\n\t            return;\n\t        }\n\t        if (!isInAnim) {\n\t            for (var attr in params) if (params[has](attr)) {\n\t                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\n\t                    from[attr] = element.attr(attr);\n\t                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);\n\t                    to[attr] = params[attr];\n\t                    switch (availableAnimAttrs[attr]) {\n\t                        case nu:\n\t                            diff[attr] = (to[attr] - from[attr]) / ms;\n\t                            break;\n\t                        case \"colour\":\n\t                            from[attr] = R.getRGB(from[attr]);\n\t                            var toColour = R.getRGB(to[attr]);\n\t                            diff[attr] = {\n\t                                r: (toColour.r - from[attr].r) / ms,\n\t                                g: (toColour.g - from[attr].g) / ms,\n\t                                b: (toColour.b - from[attr].b) / ms\n\t                            };\n\t                            break;\n\t                        case \"path\":\n\t                            var pathes = path2curve(from[attr], to[attr]),\n\t                                toPath = pathes[1];\n\t                            from[attr] = pathes[0];\n\t                            diff[attr] = [];\n\t                            for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                diff[attr][i] = [0];\n\t                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\n\t                                }\n\t                            }\n\t                            break;\n\t                        case \"transform\":\n\t                            var _ = element._,\n\t                                eq = equaliseTransform(_[attr], to[attr]);\n\t                            if (eq) {\n\t                                from[attr] = eq.from;\n\t                                to[attr] = eq.to;\n\t                                diff[attr] = [];\n\t                                diff[attr].real = true;\n\t                                for (i = 0, ii = from[attr].length; i < ii; i++) {\n\t                                    diff[attr][i] = [from[attr][i][0]];\n\t                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {\n\t                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\n\t                                    }\n\t                                }\n\t                            } else {\n\t                                var m = (element.matrix || new Matrix),\n\t                                    to2 = {\n\t                                        _: {transform: _.transform},\n\t                                        getBBox: function () {\n\t                                            return element.getBBox(1);\n\t                                        }\n\t                                    };\n\t                                from[attr] = [\n\t                                    m.a,\n\t                                    m.b,\n\t                                    m.c,\n\t                                    m.d,\n\t                                    m.e,\n\t                                    m.f\n\t                                ];\n\t                                extractTransform(to2, to[attr]);\n\t                                to[attr] = to2._.transform;\n\t                                diff[attr] = [\n\t                                    (to2.matrix.a - m.a) / ms,\n\t                                    (to2.matrix.b - m.b) / ms,\n\t                                    (to2.matrix.c - m.c) / ms,\n\t                                    (to2.matrix.d - m.d) / ms,\n\t                                    (to2.matrix.e - m.e) / ms,\n\t                                    (to2.matrix.f - m.f) / ms\n\t                                ];\n\t                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\n\t                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\n\t                                // extractTransform(to2, to[attr]);\n\t                                // diff[attr] = [\n\t                                //     (to2._.sx - _.sx) / ms,\n\t                                //     (to2._.sy - _.sy) / ms,\n\t                                //     (to2._.deg - _.deg) / ms,\n\t                                //     (to2._.dx - _.dx) / ms,\n\t                                //     (to2._.dy - _.dy) / ms\n\t                                // ];\n\t                            }\n\t                            break;\n\t                        case \"csv\":\n\t                            var values = Str(params[attr])[split](separator),\n\t                                from2 = Str(from[attr])[split](separator);\n\t                            if (attr == \"clip-rect\") {\n\t                                from[attr] = from2;\n\t                                diff[attr] = [];\n\t                                i = from2.length;\n\t                                while (i--) {\n\t                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;\n\t                                }\n\t                            }\n\t                            to[attr] = values;\n\t                            break;\n\t                        default:\n\t                            values = [][concat](params[attr]);\n\t                            from2 = [][concat](from[attr]);\n\t                            diff[attr] = [];\n\t                            i = element.paper.customAttributes[attr].length;\n\t                            while (i--) {\n\t                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\n\t                            }\n\t                            break;\n\t                    }\n\t                }\n\t            }\n\t            var easing = params.easing,\n\t                easyeasy = R.easing_formulas[easing];\n\t            if (!easyeasy) {\n\t                easyeasy = Str(easing).match(bezierrg);\n\t                if (easyeasy && easyeasy.length == 5) {\n\t                    var curve = easyeasy;\n\t                    easyeasy = function (t) {\n\t                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\n\t                    };\n\t                } else {\n\t                    easyeasy = pipe;\n\t                }\n\t            }\n\t            timestamp = params.start || anim.start || +new Date;\n\t            e = {\n\t                anim: anim,\n\t                percent: percent,\n\t                timestamp: timestamp,\n\t                start: timestamp + (anim.del || 0),\n\t                status: 0,\n\t                initstatus: status || 0,\n\t                stop: false,\n\t                ms: ms,\n\t                easing: easyeasy,\n\t                from: from,\n\t                diff: diff,\n\t                to: to,\n\t                el: element,\n\t                callback: params.callback,\n\t                prev: prev,\n\t                next: next,\n\t                repeat: times || anim.times,\n\t                origin: element.attr(),\n\t                totalOrigin: totalOrigin\n\t            };\n\t            animationElements.push(e);\n\t            if (status && !isInAnim && !isInAnimSet) {\n\t                e.stop = true;\n\t                e.start = new Date - ms * status;\n\t                if (animationElements.length == 1) {\n\t                    return animation();\n\t                }\n\t            }\n\t            if (isInAnimSet) {\n\t                e.start = new Date - e.ms * status;\n\t            }\n\t            animationElements.length == 1 && requestAnimFrame(animation);\n\t        } else {\n\t            isInAnim.initstatus = status;\n\t            isInAnim.start = new Date - isInAnim.ms * status;\n\t        }\n\t        eve(\"raphael.anim.start.\" + element.id, element, anim);\n\t    }\n\t    /*\\\n\t     * Raphael.animation\n\t     [ method ]\n\t     **\n\t     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\n\t     * See also @Animation.delay and @Animation.repeat methods.\n\t     **\n\t     > Parameters\n\t     **\n\t     - params (object) final attributes for the element, see also @Element.attr\n\t     - ms (number) number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     **\n\t     = (object) @Animation\n\t    \\*/\n\t    R.animation = function (params, ms, easing, callback) {\n\t        if (params instanceof Animation) {\n\t            return params;\n\t        }\n\t        if (R.is(easing, \"function\") || !easing) {\n\t            callback = callback || easing || null;\n\t            easing = null;\n\t        }\n\t        params = Object(params);\n\t        ms = +ms || 0;\n\t        var p = {},\n\t            json,\n\t            attr;\n\t        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\n\t            json = true;\n\t            p[attr] = params[attr];\n\t        }\n\t        if (!json) {\n\t            // if percent-like syntax is used and end-of-all animation callback used\n\t            if(callback){\n\t                // find the last one\n\t                var lastKey = 0;\n\t                for(var i in params){\n\t                    var percent = toInt(i);\n\t                    if(params[has](i) && percent > lastKey){\n\t                        lastKey = percent;\n\t                    }\n\t                }\n\t                lastKey += '%';\n\t                // if already defined callback in the last keyframe, skip\n\t                !params[lastKey].callback && (params[lastKey].callback = callback);\n\t            }\n\t          return new Animation(params, ms);\n\t        } else {\n\t            easing && (p.easing = easing);\n\t            callback && (p.callback = callback);\n\t            return new Animation({100: p}, ms);\n\t        }\n\t    };\n\t    /*\\\n\t     * Element.animate\n\t     [ method ]\n\t     **\n\t     * Creates and starts animation for given element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - params (object) final attributes for the element, see also @Element.attr\n\t     - ms (number) number of milliseconds for animation to run\n\t     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\n\t     - callback (function) #optional callback function. Will be called at the end of animation.\n\t     * or\n\t     - animation (object) animation object, see @Raphael.animation\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.animate = function (params, ms, easing, callback) {\n\t        var element = this;\n\t        if (element.removed) {\n\t            callback && callback.call(element);\n\t            return element;\n\t        }\n\t        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\n\t        runAnimation(anim, element, anim.percents[0], null, element.attr());\n\t        return element;\n\t    };\n\t    /*\\\n\t     * Element.setTime\n\t     [ method ]\n\t     **\n\t     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) animation object\n\t     - value (number) number of milliseconds from the beginning of the animation\n\t     **\n\t     = (object) original element if `value` is specified\n\t     * Note, that during animation following events are triggered:\n\t     *\n\t     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\n\t    \\*/\n\t    elproto.setTime = function (anim, value) {\n\t        if (anim && value != null) {\n\t            this.status(anim, mmin(value, anim.ms) / anim.ms);\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.status\n\t     [ method ]\n\t     **\n\t     * Gets or sets the status of animation of the element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\n\t     **\n\t     = (number) status\n\t     * or\n\t     = (array) status if `anim` is not specified. Array of objects in format:\n\t     o {\n\t     o     anim: (object) animation object\n\t     o     status: (number) status\n\t     o }\n\t     * or\n\t     = (object) original element if `value` is specified\n\t    \\*/\n\t    elproto.status = function (anim, value) {\n\t        var out = [],\n\t            i = 0,\n\t            len,\n\t            e;\n\t        if (value != null) {\n\t            runAnimation(anim, this, -1, mmin(value, 1));\n\t            return this;\n\t        } else {\n\t            len = animationElements.length;\n\t            for (; i < len; i++) {\n\t                e = animationElements[i];\n\t                if (e.el.id == this.id && (!anim || e.anim == anim)) {\n\t                    if (anim) {\n\t                        return e.status;\n\t                    }\n\t                    out.push({\n\t                        anim: e.anim,\n\t                        status: e.status\n\t                    });\n\t                }\n\t            }\n\t            if (anim) {\n\t                return 0;\n\t            }\n\t            return out;\n\t        }\n\t    };\n\t    /*\\\n\t     * Element.pause\n\t     [ method ]\n\t     **\n\t     * Stops animation of the element with ability to resume it later on.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.pause = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\n\t                animationElements[i].paused = true;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.resume\n\t     [ method ]\n\t     **\n\t     * Resumes animation if it was paused with @Element.pause method.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.resume = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            var e = animationElements[i];\n\t            if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\n\t                delete e.paused;\n\t                this.status(e.anim, e.status);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.stop\n\t     [ method ]\n\t     **\n\t     * Stops animation of the element.\n\t     **\n\t     > Parameters\n\t     **\n\t     - anim (object) #optional animation object\n\t     **\n\t     = (object) original element\n\t    \\*/\n\t    elproto.stop = function (anim) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\n\t            if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\n\t                animationElements.splice(i--, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    function stopAnimation(paper) {\n\t        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {\n\t            animationElements.splice(i--, 1);\n\t        }\n\t    }\n\t    eve.on(\"raphael.remove\", stopAnimation);\n\t    eve.on(\"raphael.clear\", stopAnimation);\n\t    elproto.toString = function () {\n\t        return \"Rapha\\xebl\\u2019s object\";\n\t    };\n\n\t    // Set\n\t    var Set = function (items) {\n\t        this.items = [];\n\t        this.length = 0;\n\t        this.type = \"set\";\n\t        if (items) {\n\t            for (var i = 0, ii = items.length; i < ii; i++) {\n\t                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\n\t                    this[this.items.length] = this.items[this.items.length] = items[i];\n\t                    this.length++;\n\t                }\n\t            }\n\t        }\n\t    },\n\t    setproto = Set.prototype;\n\t    /*\\\n\t     * Set.push\n\t     [ method ]\n\t     **\n\t     * Adds each argument to the current set.\n\t     = (object) original element\n\t    \\*/\n\t    setproto.push = function () {\n\t        var item,\n\t            len;\n\t        for (var i = 0, ii = arguments.length; i < ii; i++) {\n\t            item = arguments[i];\n\t            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\n\t                len = this.items.length;\n\t                this[len] = this.items[len] = item;\n\t                this.length++;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.pop\n\t     [ method ]\n\t     **\n\t     * Removes last element and returns it.\n\t     = (object) element\n\t    \\*/\n\t    setproto.pop = function () {\n\t        this.length && delete this[this.length--];\n\t        return this.items.pop();\n\t    };\n\t    /*\\\n\t     * Set.forEach\n\t     [ method ]\n\t     **\n\t     * Executes given function for each element in the set.\n\t     *\n\t     * If function returns `false` it will stop loop running.\n\t     **\n\t     > Parameters\n\t     **\n\t     - callback (function) function to run\n\t     - thisArg (object) context object for the callback\n\t     = (object) Set object\n\t    \\*/\n\t    setproto.forEach = function (callback, thisArg) {\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            if (callback.call(thisArg, this.items[i], i) === false) {\n\t                return this;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    for (var method in elproto) if (elproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname][apply](el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t    setproto.attr = function (name, value) {\n\t        if (name && R.is(name, array) && R.is(name[0], \"object\")) {\n\t            for (var j = 0, jj = name.length; j < jj; j++) {\n\t                this.items[j].attr(name[j]);\n\t            }\n\t        } else {\n\t            for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t                this.items[i].attr(name, value);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Set.clear\n\t     [ method ]\n\t     **\n\t     * Removes all elements from the set\n\t    \\*/\n\t    setproto.clear = function () {\n\t        while (this.length) {\n\t            this.pop();\n\t        }\n\t    };\n\t    /*\\\n\t     * Set.splice\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     > Parameters\n\t     **\n\t     - index (number) position of the deletion\n\t     - count (number) number of element to remove\n\t     - insertion (object) #optional elements to insert\n\t     = (object) set elements that were deleted\n\t    \\*/\n\t    setproto.splice = function (index, count, insertion) {\n\t        index = index < 0 ? mmax(this.length + index, 0) : index;\n\t        count = mmax(0, mmin(this.length - index, count));\n\t        var tail = [],\n\t            todel = [],\n\t            args = [],\n\t            i;\n\t        for (i = 2; i < arguments.length; i++) {\n\t            args.push(arguments[i]);\n\t        }\n\t        for (i = 0; i < count; i++) {\n\t            todel.push(this[index + i]);\n\t        }\n\t        for (; i < this.length - index; i++) {\n\t            tail.push(this[index + i]);\n\t        }\n\t        var arglen = args.length;\n\t        for (i = 0; i < arglen + tail.length; i++) {\n\t            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n\t        }\n\t        i = this.items.length = this.length -= count - arglen;\n\t        while (this[i]) {\n\t            delete this[i++];\n\t        }\n\t        return new Set(todel);\n\t    };\n\t    /*\\\n\t     * Set.exclude\n\t     [ method ]\n\t     **\n\t     * Removes given element from the set\n\t     **\n\t     > Parameters\n\t     **\n\t     - element (object) element to remove\n\t     = (boolean) `true` if object was found & removed from the set\n\t    \\*/\n\t    setproto.exclude = function (el) {\n\t        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n\t            this.splice(i, 1);\n\t            return true;\n\t        }\n\t    };\n\t    setproto.animate = function (params, ms, easing, callback) {\n\t        (R.is(easing, \"function\") || !easing) && (callback = easing || null);\n\t        var len = this.items.length,\n\t            i = len,\n\t            item,\n\t            set = this,\n\t            collector;\n\t        if (!len) {\n\t            return this;\n\t        }\n\t        callback && (collector = function () {\n\t            !--len && callback.call(set);\n\t        });\n\t        easing = R.is(easing, string) ? easing : collector;\n\t        var anim = R.animation(params, ms, easing, collector);\n\t        item = this.items[--i].animate(anim);\n\t        while (i--) {\n\t            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\n\t            (this.items[i] && !this.items[i].removed) || len--;\n\t        }\n\t        return this;\n\t    };\n\t    setproto.insertAfter = function (el) {\n\t        var i = this.items.length;\n\t        while (i--) {\n\t            this.items[i].insertAfter(el);\n\t        }\n\t        return this;\n\t    };\n\t    setproto.getBBox = function () {\n\t        var x = [],\n\t            y = [],\n\t            x2 = [],\n\t            y2 = [];\n\t        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n\t            var box = this.items[i].getBBox();\n\t            x.push(box.x);\n\t            y.push(box.y);\n\t            x2.push(box.x + box.width);\n\t            y2.push(box.y + box.height);\n\t        }\n\t        x = mmin[apply](0, x);\n\t        y = mmin[apply](0, y);\n\t        x2 = mmax[apply](0, x2);\n\t        y2 = mmax[apply](0, y2);\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            x2: x2,\n\t            y2: y2,\n\t            width: x2 - x,\n\t            height: y2 - y\n\t        };\n\t    };\n\t    setproto.clone = function (s) {\n\t        s = this.paper.set();\n\t        for (var i = 0, ii = this.items.length; i < ii; i++) {\n\t            s.push(this.items[i].clone());\n\t        }\n\t        return s;\n\t    };\n\t    setproto.toString = function () {\n\t        return \"Rapha\\xebl\\u2018s set\";\n\t    };\n\n\t    setproto.glow = function(glowConfig) {\n\t        var ret = this.paper.set();\n\t        this.forEach(function(shape, index){\n\t            var g = shape.glow(glowConfig);\n\t            if(g != null){\n\t                g.forEach(function(shape2, index2){\n\t                    ret.push(shape2);\n\t                });\n\t            }\n\t        });\n\t        return ret;\n\t    };\n\n\n\t    /*\\\n\t     * Set.isPointInside\n\t     [ method ]\n\t     **\n\t     * Determine if given point is inside this sets elements\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x coordinate of the point\n\t     - y (number) y coordinate of the point\n\t     = (boolean) `true` if point is inside any of the set's elements\n\t     \\*/\n\t    setproto.isPointInside = function (x, y) {\n\t        var isPointInside = false;\n\t        this.forEach(function (el) {\n\t            if (el.isPointInside(x, y)) {\n\t                isPointInside = true;\n\t                return false; // stop loop\n\t            }\n\t        });\n\t        return isPointInside;\n\t    };\n\n\t    /*\\\n\t     * Raphael.registerFont\n\t     [ method ]\n\t     **\n\t     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.\n\t     * Returns original parameter, so it could be used with chaining.\n\t     # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\n\t     **\n\t     > Parameters\n\t     **\n\t     - font (object) the font to register\n\t     = (object) the font you passed in\n\t     > Usage\n\t     | Cufon.registerFont(Raphael.registerFont({}));\n\t    \\*/\n\t    R.registerFont = function (font) {\n\t        if (!font.face) {\n\t            return font;\n\t        }\n\t        this.fonts = this.fonts || {};\n\t        var fontcopy = {\n\t                w: font.w,\n\t                face: {},\n\t                glyphs: {}\n\t            },\n\t            family = font.face[\"font-family\"];\n\t        for (var prop in font.face) if (font.face[has](prop)) {\n\t            fontcopy.face[prop] = font.face[prop];\n\t        }\n\t        if (this.fonts[family]) {\n\t            this.fonts[family].push(fontcopy);\n\t        } else {\n\t            this.fonts[family] = [fontcopy];\n\t        }\n\t        if (!font.svg) {\n\t            fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\n\t            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {\n\t                var path = font.glyphs[glyph];\n\t                fontcopy.glyphs[glyph] = {\n\t                    w: path.w,\n\t                    k: {},\n\t                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\n\t                            return {l: \"L\", c: \"C\", x: \"z\", t: \"m\", r: \"l\", v: \"c\"}[command] || \"M\";\n\t                        }) + \"z\"\n\t                };\n\t                if (path.k) {\n\t                    for (var k in path.k) if (path[has](k)) {\n\t                        fontcopy.glyphs[glyph].k[k] = path.k[k];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return font;\n\t    };\n\t    /*\\\n\t     * Paper.getFont\n\t     [ method ]\n\t     **\n\t     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.\n\t     **\n\t     > Parameters\n\t     **\n\t     - family (string) font family name or any word from it\n\t     - weight (string) #optional font weight\n\t     - style (string) #optional font style\n\t     - stretch (string) #optional font stretch\n\t     = (object) the font object\n\t     > Usage\n\t     | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\n\t    \\*/\n\t    paperproto.getFont = function (family, weight, style, stretch) {\n\t        stretch = stretch || \"normal\";\n\t        style = style || \"normal\";\n\t        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;\n\t        if (!R.fonts) {\n\t            return;\n\t        }\n\t        var font = R.fonts[family];\n\t        if (!font) {\n\t            var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\n\t            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {\n\t                if (name.test(fontName)) {\n\t                    font = R.fonts[fontName];\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        var thefont;\n\t        if (font) {\n\t            for (var i = 0, ii = font.length; i < ii; i++) {\n\t                thefont = font[i];\n\t                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return thefont;\n\t    };\n\t    /*\\\n\t     * Paper.print\n\t     [ method ]\n\t     **\n\t     * Creates path that represent given text written using given font at given position with given size.\n\t     * Result of the method is path element that contains whole text as a separate path.\n\t     **\n\t     > Parameters\n\t     **\n\t     - x (number) x position of the text\n\t     - y (number) y position of the text\n\t     - string (string) text to print\n\t     - font (object) font object, see @Paper.getFont\n\t     - size (number) #optional size of the font, default is `16`\n\t     - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\n\t     - letter_spacing (number) #optional number in range `-1..1`, default is `0`\n\t     - line_spacing (number) #optional number in range `1..3`, default is `1`\n\t     = (object) resulting path element, which consist of all letters\n\t     > Usage\n\t     | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\n\t    \\*/\n\t    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\n\t        origin = origin || \"middle\"; // baseline|middle\n\t        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\n\t        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\n\t        var letters = Str(string)[split](E),\n\t            shift = 0,\n\t            notfirst = 0,\n\t            path = E,\n\t            scale;\n\t        R.is(font, \"string\") && (font = this.getFont(font));\n\t        if (font) {\n\t            scale = (size || 16) / font.face[\"units-per-em\"];\n\t            var bb = font.face.bbox[split](separator),\n\t                top = +bb[0],\n\t                lineHeight = bb[3] - bb[1],\n\t                shifty = 0,\n\t                height = +bb[1] + (origin == \"baseline\" ? lineHeight + (+font.face.descent) : lineHeight / 2);\n\t            for (var i = 0, ii = letters.length; i < ii; i++) {\n\t                if (letters[i] == \"\\n\") {\n\t                    shift = 0;\n\t                    curr = 0;\n\t                    notfirst = 0;\n\t                    shifty += lineHeight * line_spacing;\n\t                } else {\n\t                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},\n\t                        curr = font.glyphs[letters[i]];\n\t                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;\n\t                    notfirst = 1;\n\t                }\n\t                if (curr && curr.d) {\n\t                    path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\n\t                }\n\t            }\n\t        }\n\t        return this.path(path).attr({\n\t            fill: \"#000\",\n\t            stroke: \"none\"\n\t        });\n\t    };\n\n\t    /*\\\n\t     * Paper.add\n\t     [ method ]\n\t     **\n\t     * Imports elements in JSON array in format `{type: type, <attributes>}`\n\t     **\n\t     > Parameters\n\t     **\n\t     - json (array)\n\t     = (object) resulting set of imported elements\n\t     > Usage\n\t     | paper.add([\n\t     |     {\n\t     |         type: \"circle\",\n\t     |         cx: 10,\n\t     |         cy: 10,\n\t     |         r: 5\n\t     |     },\n\t     |     {\n\t     |         type: \"rect\",\n\t     |         x: 10,\n\t     |         y: 10,\n\t     |         width: 10,\n\t     |         height: 10,\n\t     |         fill: \"#fc0\"\n\t     |     }\n\t     | ]);\n\t    \\*/\n\t    paperproto.add = function (json) {\n\t        if (R.is(json, \"array\")) {\n\t            var res = this.set(),\n\t                i = 0,\n\t                ii = json.length,\n\t                j;\n\t            for (; i < ii; i++) {\n\t                j = json[i] || {};\n\t                elements[has](j.type) && res.push(this[j.type]().attr(j));\n\t            }\n\t        }\n\t        return res;\n\t    };\n\n\t    /*\\\n\t     * Raphael.format\n\t     [ method ]\n\t     **\n\t     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.\n\t     **\n\t     > Parameters\n\t     **\n\t     - token (string) string to format\n\t     -  (string) rest of arguments will be treated as parameters for replacement\n\t     = (string) formated string\n\t     > Usage\n\t     | var x = 10,\n\t     |     y = 20,\n\t     |     width = 40,\n\t     |     height = 50;\n\t     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t     | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\n\t    \\*/\n\t    R.format = function (token, params) {\n\t        var args = R.is(params, array) ? [0][concat](params) : arguments;\n\t        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\n\t            return args[++i] == null ? E : args[i];\n\t        }));\n\t        return token || E;\n\t    };\n\t    /*\\\n\t     * Raphael.fullfill\n\t     [ method ]\n\t     **\n\t     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.\n\t     **\n\t     > Parameters\n\t     **\n\t     - token (string) string to format\n\t     - json (object) object which properties will be used as a replacement\n\t     = (string) formated string\n\t     > Usage\n\t     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n\t     | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n\t     |     x: 10,\n\t     |     y: 20,\n\t     |     dim: {\n\t     |         width: 40,\n\t     |         height: 50,\n\t     |         \"negative width\": -40\n\t     |     }\n\t     | }));\n\t    \\*/\n\t    R.fullfill = (function () {\n\t        var tokenRegex = /\\{([^\\}]+)\\}/g,\n\t            objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n\t            replacer = function (all, key, obj) {\n\t                var res = obj;\n\t                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n\t                    name = name || quotedName;\n\t                    if (res) {\n\t                        if (name in res) {\n\t                            res = res[name];\n\t                        }\n\t                        typeof res == \"function\" && isFunc && (res = res());\n\t                    }\n\t                });\n\t                res = (res == null || res == obj ? all : res) + \"\";\n\t                return res;\n\t            };\n\t        return function (str, obj) {\n\t            return String(str).replace(tokenRegex, function (all, key) {\n\t                return replacer(all, key, obj);\n\t            });\n\t        };\n\t    })();\n\t    /*\\\n\t     * Raphael.ninja\n\t     [ method ]\n\t     **\n\t     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\n\t     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\n\t     **\n\t     = (object) Raphael object\n\t     > Usage\n\t     | (function (local_raphael) {\n\t     |     var paper = local_raphael(10, 10, 320, 200);\n\t     |     \n\t     | })(Raphael.ninja());\n\t    \\*/\n\t    R.ninja = function () {\n\t        if (oldRaphael.was) {\n\t            g.win.Raphael = oldRaphael.is;\n\t        } else {\n\t            // IE8 raises an error when deleting window property\n\t            window.Raphael = undefined;\n\t            try {\n\t                delete window.Raphael;\n\t            } catch(e) {}\n\t        }\n\t        return R;\n\t    };\n\t    /*\\\n\t     * Raphael.st\n\t     [ property (object) ]\n\t     **\n\t     * You can add your own method to elements and sets. It is wise to add a set method for each element method\n\t     * you added, so you will be able to call the same method on sets too.\n\t     **\n\t     * See also @Raphael.el.\n\t     > Usage\n\t     | Raphael.el.red = function () {\n\t     |     this.attr({fill: \"#f00\"});\n\t     | };\n\t     | Raphael.st.red = function () {\n\t     |     this.forEach(function (el) {\n\t     |         el.red();\n\t     |     });\n\t     | };\n\t     | // then use it\n\t     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\n\t    \\*/\n\t    R.st = setproto;\n\n\t    eve.on(\"raphael.DOMload\", function () {\n\t        loaded = true;\n\t    });\n\n\t    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\t    (function (doc, loaded, f) {\n\t        if (doc.readyState == null && doc.addEventListener){\n\t            doc.addEventListener(loaded, f = function () {\n\t                doc.removeEventListener(loaded, f, false);\n\t                doc.readyState = \"complete\";\n\t            }, false);\n\t            doc.readyState = \"loading\";\n\t        }\n\t        function isLoaded() {\n\t            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\n\t        }\n\t        isLoaded();\n\t    })(document, \"DOMContentLoaded\");\n\n\t    return R;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n\t// \n\t// Licensed under the Apache License, Version 2.0 (the \"License\");\n\t// you may not use this file except in compliance with the License.\n\t// You may obtain a copy of the License at\n\t// \n\t// http://www.apache.org/licenses/LICENSE-2.0\n\t// \n\t// Unless required by applicable law or agreed to in writing, software\n\t// distributed under the License is distributed on an \"AS IS\" BASIS,\n\t// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t// See the License for the specific language governing permissions and\n\t// limitations under the License.\n\t//  \\\\\n\t//  Eve 0.5.0 - JavaScript Events Library                       \\\\\n\t//  \\\\\n\t//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n\t//  \\\\\n\n\t(function (glob) {\n\t    var version = \"0.5.0\",\n\t        has = \"hasOwnProperty\",\n\t        separator = /[\\.\\/]/,\n\t        comaseparator = /\\s*,\\s*/,\n\t        wildcard = \"*\",\n\t        fun = function () {},\n\t        numsort = function (a, b) {\n\t            return a - b;\n\t        },\n\t        current_event,\n\t        stop,\n\t        events = {n: {}},\n\t        firstDefined = function () {\n\t            for (var i = 0, ii = this.length; i < ii; i++) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        lastDefined = function () {\n\t            var i = this.length;\n\t            while (--i) {\n\t                if (typeof this[i] != \"undefined\") {\n\t                    return this[i];\n\t                }\n\t            }\n\t        },\n\t        objtos = Object.prototype.toString,\n\t        Str = String,\n\t        isArray = Array.isArray || function (ar) {\n\t            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n\t        };\n\t    /*\\\n\t     * eve\n\t     [ method ]\n\n\t     * Fires event with given `name`, given scope and other parameters.\n\n\t     > Arguments\n\n\t     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n\t     - scope (object) context for the event handlers\n\t     - varargs (...) the rest of arguments will be sent to event handlers\n\n\t     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n\t    \\*/\n\t        eve = function (name, scope) {\n\t            var e = events,\n\t                oldstop = stop,\n\t                args = Array.prototype.slice.call(arguments, 2),\n\t                listeners = eve.listeners(name),\n\t                z = 0,\n\t                f = false,\n\t                l,\n\t                indexed = [],\n\t                queue = {},\n\t                out = [],\n\t                ce = current_event,\n\t                errors = [];\n\t            out.firstDefined = firstDefined;\n\t            out.lastDefined = lastDefined;\n\t            current_event = name;\n\t            stop = 0;\n\t            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n\t                indexed.push(listeners[i].zIndex);\n\t                if (listeners[i].zIndex < 0) {\n\t                    queue[listeners[i].zIndex] = listeners[i];\n\t                }\n\t            }\n\t            indexed.sort(numsort);\n\t            while (indexed[z] < 0) {\n\t                l = queue[indexed[z++]];\n\t                out.push(l.apply(scope, args));\n\t                if (stop) {\n\t                    stop = oldstop;\n\t                    return out;\n\t                }\n\t            }\n\t            for (i = 0; i < ii; i++) {\n\t                l = listeners[i];\n\t                if (\"zIndex\" in l) {\n\t                    if (l.zIndex == indexed[z]) {\n\t                        out.push(l.apply(scope, args));\n\t                        if (stop) {\n\t                            break;\n\t                        }\n\t                        do {\n\t                            z++;\n\t                            l = queue[indexed[z]];\n\t                            l && out.push(l.apply(scope, args));\n\t                            if (stop) {\n\t                                break;\n\t                            }\n\t                        } while (l)\n\t                    } else {\n\t                        queue[l.zIndex] = l;\n\t                    }\n\t                } else {\n\t                    out.push(l.apply(scope, args));\n\t                    if (stop) {\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            stop = oldstop;\n\t            current_event = ce;\n\t            return out;\n\t        };\n\t        // Undocumented. Debug only.\n\t        eve._events = events;\n\t    /*\\\n\t     * eve.listeners\n\t     [ method ]\n\n\t     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n\t     > Arguments\n\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n\t     = (array) array of event handlers\n\t    \\*/\n\t    eve.listeners = function (name) {\n\t        var names = isArray(name) ? name : name.split(separator),\n\t            e = events,\n\t            item,\n\t            items,\n\t            k,\n\t            i,\n\t            ii,\n\t            j,\n\t            jj,\n\t            nes,\n\t            es = [e],\n\t            out = [];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            nes = [];\n\t            for (j = 0, jj = es.length; j < jj; j++) {\n\t                e = es[j].n;\n\t                items = [e[names[i]], e[wildcard]];\n\t                k = 2;\n\t                while (k--) {\n\t                    item = items[k];\n\t                    if (item) {\n\t                        nes.push(item);\n\t                        out = out.concat(item.f || []);\n\t                    }\n\t                }\n\t            }\n\t            es = nes;\n\t        }\n\t        return out;\n\t    };\n\t    /*\\\n\t     * eve.separator\n\t     [ method ]\n\n\t     * If for some reasons you dont like default separators (`.` or `/`) you can specify yours\n\t     * here. Be aware that if you pass a string longer than one character it will be treated as\n\t     * a list of characters.\n\n\t     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n\t    \\*/\n\t    eve.separator = function (sep) {\n\t        if (sep) {\n\t            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n\t            sep = \"[\" + sep + \"]\";\n\t            separator = new RegExp(sep);\n\t        } else {\n\t            separator = /[\\.\\/]/;\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.on\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n\t     | eve.on(\"*.under.*\", f);\n\t     | eve(\"mouse.under.floor\"); // triggers f\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     - name (array) if you dont want to use separators, you can use array of strings\n\t     - f (function) event handler function\n\t     **\n\t     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n\t     > Example:\n\t     | eve.on(\"mouse\", eatIt)(2);\n\t     | eve.on(\"mouse\", scream);\n\t     | eve.on(\"mouse\", catchIt)(1);\n\t     * This will ensure that `catchIt` function will be called before `eatIt`.\n\t     *\n\t     * If you want to put your handler before non-indexed handlers, specify a negative value.\n\t     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n\t    \\*/\n\t    eve.on = function (name, f) {\n\t        if (typeof f != \"function\") {\n\t            return function () {};\n\t        }\n\t        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n\t        for (var i = 0, ii = names.length; i < ii; i++) {\n\t            (function (name) {\n\t                var names = isArray(name) ? name : Str(name).split(separator),\n\t                    e = events,\n\t                    exist;\n\t                for (var i = 0, ii = names.length; i < ii; i++) {\n\t                    e = e.n;\n\t                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n\t                }\n\t                e.f = e.f || [];\n\t                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n\t                    exist = true;\n\t                    break;\n\t                }\n\t                !exist && e.f.push(f);\n\t            }(names[i]));\n\t        }\n\t        return function (zIndex) {\n\t            if (+zIndex == +zIndex) {\n\t                f.zIndex = +zIndex;\n\t            }\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.f\n\t     [ method ]\n\t     **\n\t     * Returns function that will fire given event with optional arguments.\n\t     * Arguments that will be passed to the result function will be also\n\t     * concated to the list of final arguments.\n\t     | el.onclick = eve.f(\"click\", 1, 2);\n\t     | eve.on(\"click\", function (a, b, c) {\n\t     |     console.log(a, b, c); // 1, 2, [event object]\n\t     | });\n\t     > Arguments\n\t     - event (string) event name\n\t     - varargs () and any other arguments\n\t     = (function) possible event handler function\n\t    \\*/\n\t    eve.f = function (event) {\n\t        var attrs = [].slice.call(arguments, 1);\n\t        return function () {\n\t            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n\t        };\n\t    };\n\t    /*\\\n\t     * eve.stop\n\t     [ method ]\n\t     **\n\t     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n\t    \\*/\n\t    eve.stop = function () {\n\t        stop = 1;\n\t    };\n\t    /*\\\n\t     * eve.nt\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     > Arguments\n\t     **\n\t     - subname (string) #optional subname of the event\n\t     **\n\t     = (string) name of the event, if `subname` is not specified\n\t     * or\n\t     = (boolean) `true`, if current events name contains `subname`\n\t    \\*/\n\t    eve.nt = function (subname) {\n\t        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n\t        if (subname) {\n\t            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n\t        }\n\t        return cur;\n\t    };\n\t    /*\\\n\t     * eve.nts\n\t     [ method ]\n\t     **\n\t     * Could be used inside event handler to figure out actual name of the event.\n\t     **\n\t     **\n\t     = (array) names of the event\n\t    \\*/\n\t    eve.nts = function () {\n\t        return isArray(current_event) ? current_event : current_event.split(separator);\n\t    };\n\t    /*\\\n\t     * eve.off\n\t     [ method ]\n\t     **\n\t     * Removes given function from the list of event listeners assigned to given name.\n\t     * If no arguments specified all the events will be cleared.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t    \\*/\n\t    /*\\\n\t     * eve.unbind\n\t     [ method ]\n\t     **\n\t     * See @eve.off\n\t    \\*/\n\t    eve.off = eve.unbind = function (name, f) {\n\t        if (!name) {\n\t            eve._events = events = {n: {}};\n\t            return;\n\t        }\n\t        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n\t        if (names.length > 1) {\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                eve.off(names[i], f);\n\t            }\n\t            return;\n\t        }\n\t        names = isArray(name) ? name : Str(name).split(separator);\n\t        var e,\n\t            key,\n\t            splice,\n\t            i, ii, j, jj,\n\t            cur = [events];\n\t        for (i = 0, ii = names.length; i < ii; i++) {\n\t            for (j = 0; j < cur.length; j += splice.length - 2) {\n\t                splice = [j, 1];\n\t                e = cur[j].n;\n\t                if (names[i] != wildcard) {\n\t                    if (e[names[i]]) {\n\t                        splice.push(e[names[i]]);\n\t                    }\n\t                } else {\n\t                    for (key in e) if (e[has](key)) {\n\t                        splice.push(e[key]);\n\t                    }\n\t                }\n\t                cur.splice.apply(cur, splice);\n\t            }\n\t        }\n\t        for (i = 0, ii = cur.length; i < ii; i++) {\n\t            e = cur[i];\n\t            while (e.n) {\n\t                if (f) {\n\t                    if (e.f) {\n\t                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n\t                            e.f.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !e.f.length && delete e.f;\n\t                    }\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        var funcs = e.n[key].f;\n\t                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n\t                            funcs.splice(j, 1);\n\t                            break;\n\t                        }\n\t                        !funcs.length && delete e.n[key].f;\n\t                    }\n\t                } else {\n\t                    delete e.f;\n\t                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n\t                        delete e.n[key].f;\n\t                    }\n\t                }\n\t                e = e.n;\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * eve.once\n\t     [ method ]\n\t     **\n\t     * Binds given event handler with a given name to only run once then unbind itself.\n\t     | eve.once(\"login\", f);\n\t     | eve(\"login\"); // triggers f\n\t     | eve(\"login\"); // no listeners\n\t     * Use @eve to trigger the listener.\n\t     **\n\t     > Arguments\n\t     **\n\t     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n\t     - f (function) event handler function\n\t     **\n\t     = (function) same return function as @eve.on\n\t    \\*/\n\t    eve.once = function (name, f) {\n\t        var f2 = function () {\n\t            eve.off(name, f2);\n\t            return f.apply(this, arguments);\n\t        };\n\t        return eve.on(name, f2);\n\t    };\n\t    /*\\\n\t     * eve.version\n\t     [ property (string) ]\n\t     **\n\t     * Current version of the library.\n\t    \\*/\n\t    eve.version = version;\n\t    eve.toString = function () {\n\t        return \"You are running Eve \" + version;\n\t    };\n\t    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));\n\t})(this);\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\t    if (R && !R.svg) {\n\t        return;\n\t    }\n\n\t    var has = \"hasOwnProperty\",\n\t        Str = String,\n\t        toFloat = parseFloat,\n\t        toInt = parseInt,\n\t        math = Math,\n\t        mmax = math.max,\n\t        abs = math.abs,\n\t        pow = math.pow,\n\t        separator = /[, ]+/,\n\t        eve = R.eve,\n\t        E = \"\",\n\t        S = \" \";\n\t    var xlink = \"http://www.w3.org/1999/xlink\",\n\t        markers = {\n\t            block: \"M5,0 0,2.5 5,5z\",\n\t            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\n\t            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\n\t            open: \"M6,1 1,3.5 6,6\",\n\t            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\n\t        },\n\t        markerCounter = {};\n\t    R.toString = function () {\n\t        return  \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\n\t    };\n\t    var $ = function (el, attr) {\n\t        if (attr) {\n\t            if (typeof el == \"string\") {\n\t                el = $(el);\n\t            }\n\t            for (var key in attr) if (attr[has](key)) {\n\t                if (key.substring(0, 6) == \"xlink:\") {\n\t                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\n\t                } else {\n\t                    el.setAttribute(key, Str(attr[key]));\n\t                }\n\t            }\n\t        } else {\n\t            el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\n\t            el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\n\t        }\n\t        return el;\n\t    },\n\t    addGradientFill = function (element, gradient) {\n\t        var type = \"linear\",\n\t            id = element.id + gradient,\n\t            fx = .5, fy = .5,\n\t            o = element.node,\n\t            SVG = element.paper,\n\t            s = o.style,\n\t            el = R._g.doc.getElementById(id);\n\t        if (!el) {\n\t            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\n\t                type = \"radial\";\n\t                if (_fx && _fy) {\n\t                    fx = toFloat(_fx);\n\t                    fy = toFloat(_fy);\n\t                    var dir = ((fy > .5) * 2 - 1);\n\t                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&\n\t                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&\n\t                        fy != .5 &&\n\t                        (fy = fy.toFixed(5) - 1e-5 * dir);\n\t                }\n\t                return E;\n\t            });\n\t            gradient = gradient.split(/\\s*\\-\\s*/);\n\t            if (type == \"linear\") {\n\t                var angle = gradient.shift();\n\t                angle = -toFloat(angle);\n\t                if (isNaN(angle)) {\n\t                    return null;\n\t                }\n\t                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\n\t                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\n\t                vector[2] *= max;\n\t                vector[3] *= max;\n\t                if (vector[2] < 0) {\n\t                    vector[0] = -vector[2];\n\t                    vector[2] = 0;\n\t                }\n\t                if (vector[3] < 0) {\n\t                    vector[1] = -vector[3];\n\t                    vector[3] = 0;\n\t                }\n\t            }\n\t            var dots = R._parseDots(gradient);\n\t            if (!dots) {\n\t                return null;\n\t            }\n\t            id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\n\n\t            if (element.gradient && id != element.gradient.id) {\n\t                SVG.defs.removeChild(element.gradient);\n\t                delete element.gradient;\n\t            }\n\n\t            if (!element.gradient) {\n\t                el = $(type + \"Gradient\", {id: id});\n\t                element.gradient = el;\n\t                $(el, type == \"radial\" ? {\n\t                    fx: fx,\n\t                    fy: fy\n\t                } : {\n\t                    x1: vector[0],\n\t                    y1: vector[1],\n\t                    x2: vector[2],\n\t                    y2: vector[3],\n\t                    gradientTransform: element.matrix.invert()\n\t                });\n\t                SVG.defs.appendChild(el);\n\t                for (var i = 0, ii = dots.length; i < ii; i++) {\n\t                    el.appendChild($(\"stop\", {\n\t                        offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\n\t                        \"stop-color\": dots[i].color || \"#fff\",\n\t                        \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\n\t                    }));\n\t                }\n\t            }\n\t        }\n\t        $(o, {\n\t            fill: fillurl(id),\n\t            opacity: 1,\n\t            \"fill-opacity\": 1\n\t        });\n\t        s.fill = E;\n\t        s.opacity = 1;\n\t        s.fillOpacity = 1;\n\t        return 1;\n\t    },\n\t    isIE9or10 = function () {\n\t      var mode = document.documentMode;\n\t      return mode && (mode === 9 || mode === 10);\n\t    },\n\t    fillurl = function (id) {\n\t      if (isIE9or10()) {\n\t          return \"url('#\" + id + \"')\";\n\t      }\n\t      var location = document.location;\n\t      var locationString = (\n\t          location.protocol + '//' +\n\t          location.host +\n\t          location.pathname +\n\t          location.search\n\t      );\n\t      return \"url('\" + locationString + \"#\" + id + \"')\";\n\t    },\n\t    updatePosition = function (o) {\n\t        var bbox = o.getBBox(1);\n\t        $(o.pattern, {patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"});\n\t    },\n\t    addArrow = function (o, value, isEnd) {\n\t        if (o.type == \"path\") {\n\t            var values = Str(value).toLowerCase().split(\"-\"),\n\t                p = o.paper,\n\t                se = isEnd ? \"end\" : \"start\",\n\t                node = o.node,\n\t                attrs = o.attrs,\n\t                stroke = attrs[\"stroke-width\"],\n\t                i = values.length,\n\t                type = \"classic\",\n\t                from,\n\t                to,\n\t                dx,\n\t                refX,\n\t                attr,\n\t                w = 3,\n\t                h = 3,\n\t                t = 5;\n\t            while (i--) {\n\t                switch (values[i]) {\n\t                    case \"block\":\n\t                    case \"classic\":\n\t                    case \"oval\":\n\t                    case \"diamond\":\n\t                    case \"open\":\n\t                    case \"none\":\n\t                        type = values[i];\n\t                        break;\n\t                    case \"wide\": h = 5; break;\n\t                    case \"narrow\": h = 2; break;\n\t                    case \"long\": w = 5; break;\n\t                    case \"short\": w = 2; break;\n\t                }\n\t            }\n\t            if (type == \"open\") {\n\t                w += 2;\n\t                h += 2;\n\t                t += 2;\n\t                dx = 1;\n\t                refX = isEnd ? 4 : 1;\n\t                attr = {\n\t                    fill: \"none\",\n\t                    stroke: attrs.stroke\n\t                };\n\t            } else {\n\t                refX = dx = w / 2;\n\t                attr = {\n\t                    fill: attrs.stroke,\n\t                    stroke: \"none\"\n\t                };\n\t            }\n\t            if (o._.arrows) {\n\t                if (isEnd) {\n\t                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\n\t                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\n\t                } else {\n\t                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\n\t                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\n\t                }\n\t            } else {\n\t                o._.arrows = {};\n\t            }\n\t            if (type != \"none\") {\n\t                var pathId = \"raphael-marker-\" + type,\n\t                    markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\n\t                if (!R._g.doc.getElementById(pathId)) {\n\t                    p.defs.appendChild($($(\"path\"), {\n\t                        \"stroke-linecap\": \"round\",\n\t                        d: markers[type],\n\t                        id: pathId\n\t                    }));\n\t                    markerCounter[pathId] = 1;\n\t                } else {\n\t                    markerCounter[pathId]++;\n\t                }\n\t                var marker = R._g.doc.getElementById(markerId),\n\t                    use;\n\t                if (!marker) {\n\t                    marker = $($(\"marker\"), {\n\t                        id: markerId,\n\t                        markerHeight: h,\n\t                        markerWidth: w,\n\t                        orient: \"auto\",\n\t                        refX: refX,\n\t                        refY: h / 2\n\t                    });\n\t                    use = $($(\"use\"), {\n\t                        \"xlink:href\": \"#\" + pathId,\n\t                        transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\n\t                        \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\n\t                    });\n\t                    marker.appendChild(use);\n\t                    p.defs.appendChild(marker);\n\t                    markerCounter[markerId] = 1;\n\t                } else {\n\t                    markerCounter[markerId]++;\n\t                    use = marker.getElementsByTagName(\"use\")[0];\n\t                }\n\t                $(use, attr);\n\t                var delta = dx * (type != \"diamond\" && type != \"oval\");\n\t                if (isEnd) {\n\t                    from = o._.arrows.startdx * stroke || 0;\n\t                    to = R.getTotalLength(attrs.path) - delta * stroke;\n\t                } else {\n\t                    from = delta * stroke;\n\t                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n\t                }\n\t                attr = {};\n\t                attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\n\t                if (to || from) {\n\t                    attr.d = R.getSubpath(attrs.path, from, to);\n\t                }\n\t                $(node, attr);\n\t                o._.arrows[se + \"Path\"] = pathId;\n\t                o._.arrows[se + \"Marker\"] = markerId;\n\t                o._.arrows[se + \"dx\"] = delta;\n\t                o._.arrows[se + \"Type\"] = type;\n\t                o._.arrows[se + \"String\"] = value;\n\t            } else {\n\t                if (isEnd) {\n\t                    from = o._.arrows.startdx * stroke || 0;\n\t                    to = R.getTotalLength(attrs.path) - from;\n\t                } else {\n\t                    from = 0;\n\t                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\n\t                }\n\t                o._.arrows[se + \"Path\"] && $(node, {d: R.getSubpath(attrs.path, from, to)});\n\t                delete o._.arrows[se + \"Path\"];\n\t                delete o._.arrows[se + \"Marker\"];\n\t                delete o._.arrows[se + \"dx\"];\n\t                delete o._.arrows[se + \"Type\"];\n\t                delete o._.arrows[se + \"String\"];\n\t            }\n\t            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {\n\t                var item = R._g.doc.getElementById(attr);\n\t                item && item.parentNode.removeChild(item);\n\t            }\n\t        }\n\t    },\n\t    dasharray = {\n\t        \"-\": [3, 1],\n\t        \".\": [1, 1],\n\t        \"-.\": [3, 1, 1, 1],\n\t        \"-..\": [3, 1, 1, 1, 1, 1],\n\t        \". \": [1, 3],\n\t        \"- \": [4, 3],\n\t        \"--\": [8, 3],\n\t        \"- .\": [4, 3, 1, 3],\n\t        \"--.\": [8, 3, 1, 3],\n\t        \"--..\": [8, 3, 1, 3, 1, 3]\n\t    },\n\t    addDashes = function (o, value, params) {\n\t        value = dasharray[Str(value).toLowerCase()];\n\t        if (value) {\n\t            var width = o.attrs[\"stroke-width\"] || \"1\",\n\t                butt = {round: width, square: width, butt: 0}[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\n\t                dashes = [],\n\t                i = value.length;\n\t            while (i--) {\n\t                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;\n\t            }\n\t            $(o.node, {\"stroke-dasharray\": dashes.join(\",\")});\n\t        }\n\t        else {\n\t          $(o.node, {\"stroke-dasharray\": \"none\"});\n\t        }\n\t    },\n\t    setFillAndStroke = function (o, params) {\n\t        var node = o.node,\n\t            attrs = o.attrs,\n\t            vis = node.style.visibility;\n\t        node.style.visibility = \"hidden\";\n\t        for (var att in params) {\n\t            if (params[has](att)) {\n\t                if (!R._availableAttrs[has](att)) {\n\t                    continue;\n\t                }\n\t                var value = params[att];\n\t                attrs[att] = value;\n\t                switch (att) {\n\t                    case \"blur\":\n\t                        o.blur(value);\n\t                        break;\n\t                    case \"title\":\n\t                        var title = node.getElementsByTagName(\"title\");\n\n\t                        // Use the existing <title>.\n\t                        if (title.length && (title = title[0])) {\n\t                          title.firstChild.nodeValue = value;\n\t                        } else {\n\t                          title = $(\"title\");\n\t                          var val = R._g.doc.createTextNode(value);\n\t                          title.appendChild(val);\n\t                          node.appendChild(title);\n\t                        }\n\t                        break;\n\t                    case \"href\":\n\t                    case \"target\":\n\t                        var pn = node.parentNode;\n\t                        if (pn.tagName.toLowerCase() != \"a\") {\n\t                            var hl = $(\"a\");\n\t                            pn.insertBefore(hl, node);\n\t                            hl.appendChild(node);\n\t                            pn = hl;\n\t                        }\n\t                        if (att == \"target\") {\n\t                            pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\n\t                        } else {\n\t                            pn.setAttributeNS(xlink, att, value);\n\t                        }\n\t                        break;\n\t                    case \"cursor\":\n\t                        node.style.cursor = value;\n\t                        break;\n\t                    case \"transform\":\n\t                        o.transform(value);\n\t                        break;\n\t                    case \"arrow-start\":\n\t                        addArrow(o, value);\n\t                        break;\n\t                    case \"arrow-end\":\n\t                        addArrow(o, value, 1);\n\t                        break;\n\t                    case \"clip-rect\":\n\t                        var rect = Str(value).split(separator);\n\t                        if (rect.length == 4) {\n\t                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\n\t                            var el = $(\"clipPath\"),\n\t                                rc = $(\"rect\");\n\t                            el.id = R.createUUID();\n\t                            $(rc, {\n\t                                x: rect[0],\n\t                                y: rect[1],\n\t                                width: rect[2],\n\t                                height: rect[3]\n\t                            });\n\t                            el.appendChild(rc);\n\t                            o.paper.defs.appendChild(el);\n\t                            $(node, {\"clip-path\": \"url(#\" + el.id + \")\"});\n\t                            o.clip = rc;\n\t                        }\n\t                        if (!value) {\n\t                            var path = node.getAttribute(\"clip-path\");\n\t                            if (path) {\n\t                                var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\n\t                                clip && clip.parentNode.removeChild(clip);\n\t                                $(node, {\"clip-path\": E});\n\t                                delete o.clip;\n\t                            }\n\t                        }\n\t                    break;\n\t                    case \"path\":\n\t                        if (o.type == \"path\") {\n\t                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"});\n\t                            o._.dirty = 1;\n\t                            if (o._.arrows) {\n\t                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                            }\n\t                        }\n\t                        break;\n\t                    case \"width\":\n\t                        node.setAttribute(att, value);\n\t                        o._.dirty = 1;\n\t                        if (attrs.fx) {\n\t                            att = \"x\";\n\t                            value = attrs.x;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    case \"x\":\n\t                        if (attrs.fx) {\n\t                            value = -attrs.x - (attrs.width || 0);\n\t                        }\n\t                    case \"rx\":\n\t                        if (att == \"rx\" && o.type == \"rect\") {\n\t                            break;\n\t                        }\n\t                    case \"cx\":\n\t                        node.setAttribute(att, value);\n\t                        o.pattern && updatePosition(o);\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"height\":\n\t                        node.setAttribute(att, value);\n\t                        o._.dirty = 1;\n\t                        if (attrs.fy) {\n\t                            att = \"y\";\n\t                            value = attrs.y;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    case \"y\":\n\t                        if (attrs.fy) {\n\t                            value = -attrs.y - (attrs.height || 0);\n\t                        }\n\t                    case \"ry\":\n\t                        if (att == \"ry\" && o.type == \"rect\") {\n\t                            break;\n\t                        }\n\t                    case \"cy\":\n\t                        node.setAttribute(att, value);\n\t                        o.pattern && updatePosition(o);\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"r\":\n\t                        if (o.type == \"rect\") {\n\t                            $(node, {rx: value, ry: value});\n\t                        } else {\n\t                            node.setAttribute(att, value);\n\t                        }\n\t                        o._.dirty = 1;\n\t                        break;\n\t                    case \"src\":\n\t                        if (o.type == \"image\") {\n\t                            node.setAttributeNS(xlink, \"href\", value);\n\t                        }\n\t                        break;\n\t                    case \"stroke-width\":\n\t                        if (o._.sx != 1 || o._.sy != 1) {\n\t                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\n\t                        }\n\t                        node.setAttribute(att, value);\n\t                        if (attrs[\"stroke-dasharray\"]) {\n\t                            addDashes(o, attrs[\"stroke-dasharray\"], params);\n\t                        }\n\t                        if (o._.arrows) {\n\t                            \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                            \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                        }\n\t                        break;\n\t                    case \"stroke-dasharray\":\n\t                        addDashes(o, value, params);\n\t                        break;\n\t                    case \"fill\":\n\t                        var isURL = Str(value).match(R._ISURL);\n\t                        if (isURL) {\n\t                            el = $(\"pattern\");\n\t                            var ig = $(\"image\");\n\t                            el.id = R.createUUID();\n\t                            $(el, {x: 0, y: 0, patternUnits: \"userSpaceOnUse\", height: 1, width: 1});\n\t                            $(ig, {x: 0, y: 0, \"xlink:href\": isURL[1]});\n\t                            el.appendChild(ig);\n\n\t                            (function (el) {\n\t                                R._preload(isURL[1], function () {\n\t                                    var w = this.offsetWidth,\n\t                                        h = this.offsetHeight;\n\t                                    $(el, {width: w, height: h});\n\t                                    $(ig, {width: w, height: h});\n\t                                });\n\t                            })(el);\n\t                            o.paper.defs.appendChild(el);\n\t                            $(node, {fill: \"url(#\" + el.id + \")\"});\n\t                            o.pattern = el;\n\t                            o.pattern && updatePosition(o);\n\t                            break;\n\t                        }\n\t                        var clr = R.getRGB(value);\n\t                        if (!clr.error) {\n\t                            delete params.gradient;\n\t                            delete attrs.gradient;\n\t                            !R.is(attrs.opacity, \"undefined\") &&\n\t                                R.is(params.opacity, \"undefined\") &&\n\t                                $(node, {opacity: attrs.opacity});\n\t                            !R.is(attrs[\"fill-opacity\"], \"undefined\") &&\n\t                                R.is(params[\"fill-opacity\"], \"undefined\") &&\n\t                                $(node, {\"fill-opacity\": attrs[\"fill-opacity\"]});\n\t                        } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\n\t                            if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\n\t                                var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\t                                if (gradient) {\n\t                                    var stops = gradient.getElementsByTagName(\"stop\");\n\t                                    $(stops[stops.length - 1], {\"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)});\n\t                                }\n\t                            }\n\t                            attrs.gradient = value;\n\t                            attrs.fill = \"none\";\n\t                            break;\n\t                        }\n\t                        clr[has](\"opacity\") && $(node, {\"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n\t                    case \"stroke\":\n\t                        clr = R.getRGB(value);\n\t                        node.setAttribute(att, clr.hex);\n\t                        att == \"stroke\" && clr[has](\"opacity\") && $(node, {\"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\n\t                        if (att == \"stroke\" && o._.arrows) {\n\t                            \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\n\t                            \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\n\t                        }\n\t                        break;\n\t                    case \"gradient\":\n\t                        (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\n\t                        break;\n\t                    case \"opacity\":\n\t                        if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\n\t                            $(node, {\"stroke-opacity\": value > 1 ? value / 100 : value});\n\t                        }\n\t                        // fall\n\t                    case \"fill-opacity\":\n\t                        if (attrs.gradient) {\n\t                            gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\n\t                            if (gradient) {\n\t                                stops = gradient.getElementsByTagName(\"stop\");\n\t                                $(stops[stops.length - 1], {\"stop-opacity\": value});\n\t                            }\n\t                            break;\n\t                        }\n\t                    default:\n\t                        att == \"font-size\" && (value = toInt(value, 10) + \"px\");\n\t                        var cssrule = att.replace(/(\\-.)/g, function (w) {\n\t                            return w.substring(1).toUpperCase();\n\t                        });\n\t                        node.style[cssrule] = value;\n\t                        o._.dirty = 1;\n\t                        node.setAttribute(att, value);\n\t                        break;\n\t                }\n\t            }\n\t        }\n\n\t        tuneText(o, params);\n\t        node.style.visibility = vis;\n\t    },\n\t    leading = 1.2,\n\t    tuneText = function (el, params) {\n\t        if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\n\t            return;\n\t        }\n\t        var a = el.attrs,\n\t            node = el.node,\n\t            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\n\n\t        if (params[has](\"text\")) {\n\t            a.text = params.text;\n\t            while (node.firstChild) {\n\t                node.removeChild(node.firstChild);\n\t            }\n\t            var texts = Str(params.text).split(\"\\n\"),\n\t                tspans = [],\n\t                tspan;\n\t            for (var i = 0, ii = texts.length; i < ii; i++) {\n\t                tspan = $(\"tspan\");\n\t                i && $(tspan, {dy: fontSize * leading, x: a.x});\n\t                tspan.appendChild(R._g.doc.createTextNode(texts[i]));\n\t                node.appendChild(tspan);\n\t                tspans[i] = tspan;\n\t            }\n\t        } else {\n\t            tspans = node.getElementsByTagName(\"tspan\");\n\t            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {\n\t                $(tspans[i], {dy: fontSize * leading, x: a.x});\n\t            } else {\n\t                $(tspans[0], {dy: 0});\n\t            }\n\t        }\n\t        $(node, {x: a.x, y: a.y});\n\t        el._.dirty = 1;\n\t        var bb = el._getBBox(),\n\t            dif = a.y - (bb.y + bb.height / 2);\n\t        dif && R.is(dif, \"finite\") && $(tspans[0], {dy: dif});\n\t    },\n\t    getRealNode = function (node) {\n\t        if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\n\t            return node.parentNode;\n\t        } else {\n\t            return node;\n\t        }\n\t    },\n\t    Element = function (node, svg) {\n\t        var X = 0,\n\t            Y = 0;\n\t        /*\\\n\t         * Element.node\n\t         [ property (object) ]\n\t         **\n\t         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n\t         **\n\t         * Note: Dont mess with it.\n\t         > Usage\n\t         | // draw a circle at coordinate 10,10 with radius of 10\n\t         | var c = paper.circle(10, 10, 10);\n\t         | c.node.onclick = function () {\n\t         |     c.attr(\"fill\", \"red\");\n\t         | };\n\t        \\*/\n\t        this[0] = this.node = node;\n\t        /*\\\n\t         * Element.raphael\n\t         [ property (object) ]\n\t         **\n\t         * Internal reference to @Raphael object. In case it is not available.\n\t         > Usage\n\t         | Raphael.el.red = function () {\n\t         |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\n\t         |     hsb.h = 1;\n\t         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\n\t         | }\n\t        \\*/\n\t        node.raphael = true;\n\t        /*\\\n\t         * Element.id\n\t         [ property (number) ]\n\t         **\n\t         * Unique id of the element. Especially useful when you want to listen to events of the element,\n\t         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\n\t        \\*/\n\t        this.id = guid();\n\t        node.raphaelid = this.id;\n\n\t        /**\n\t        * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements\n\t        * @returns {string} id\n\t        */\n\t        function guid() {\n\t            return (\"0000\" + (Math.random()*Math.pow(36,5) << 0).toString(36)).slice(-5);\n\t        }\n\n\t        this.matrix = R.matrix();\n\t        this.realPath = null;\n\t        /*\\\n\t         * Element.paper\n\t         [ property (object) ]\n\t         **\n\t         * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.\n\t         > Usage\n\t         | Raphael.el.cross = function () {\n\t         |     this.attr({fill: \"red\"});\n\t         |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\n\t         |         .attr({stroke: \"red\"});\n\t         | }\n\t        \\*/\n\t        this.paper = svg;\n\t        this.attrs = this.attrs || {};\n\t        this._ = {\n\t            transform: [],\n\t            sx: 1,\n\t            sy: 1,\n\t            deg: 0,\n\t            dx: 0,\n\t            dy: 0,\n\t            dirty: 1\n\t        };\n\t        !svg.bottom && (svg.bottom = this);\n\t        /*\\\n\t         * Element.prev\n\t         [ property (object) ]\n\t         **\n\t         * Reference to the previous element in the hierarchy.\n\t        \\*/\n\t        this.prev = svg.top;\n\t        svg.top && (svg.top.next = this);\n\t        svg.top = this;\n\t        /*\\\n\t         * Element.next\n\t         [ property (object) ]\n\t         **\n\t         * Reference to the next element in the hierarchy.\n\t        \\*/\n\t        this.next = null;\n\t    },\n\t    elproto = R.el;\n\n\t    Element.prototype = elproto;\n\t    elproto.constructor = Element;\n\n\t    R._engine.path = function (pathString, SVG) {\n\t        var el = $(\"path\");\n\t        SVG.canvas && SVG.canvas.appendChild(el);\n\t        var p = new Element(el, SVG);\n\t        p.type = \"path\";\n\t        setFillAndStroke(p, {\n\t            fill: \"none\",\n\t            stroke: \"#000\",\n\t            path: pathString\n\t        });\n\t        return p;\n\t    };\n\t    /*\\\n\t     * Element.rotate\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds rotation by given angle around given point to the list of\n\t     * transformations of the element.\n\t     > Parameters\n\t     - deg (number) angle in degrees\n\t     - cx (number) #optional x coordinate of the centre of rotation\n\t     - cy (number) #optional y coordinate of the centre of rotation\n\t     * If cx & cy arent specified centre of the shape is used as a point of rotation.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.rotate = function (deg, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        deg = Str(deg).split(separator);\n\t        if (deg.length - 1) {\n\t            cx = toFloat(deg[1]);\n\t            cy = toFloat(deg[2]);\n\t        }\n\t        deg = toFloat(deg[0]);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t            cx = bbox.x + bbox.width / 2;\n\t            cy = bbox.y + bbox.height / 2;\n\t        }\n\t        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.scale\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds scale by given amount relative to given point to the list of\n\t     * transformations of the element.\n\t     > Parameters\n\t     - sx (number) horisontal scale amount\n\t     - sy (number) vertical scale amount\n\t     - cx (number) #optional x coordinate of the centre of scale\n\t     - cy (number) #optional y coordinate of the centre of scale\n\t     * If cx & cy arent specified centre of the shape is used instead.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.scale = function (sx, sy, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        sx = Str(sx).split(separator);\n\t        if (sx.length - 1) {\n\t            sy = toFloat(sx[1]);\n\t            cx = toFloat(sx[2]);\n\t            cy = toFloat(sx[3]);\n\t        }\n\t        sx = toFloat(sx[0]);\n\t        (sy == null) && (sy = sx);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t        }\n\t        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n\t        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n\t        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.translate\n\t     [ method ]\n\t     **\n\t     * Deprecated! Use @Element.transform instead.\n\t     * Adds translation by given amount to the list of transformations of the element.\n\t     > Parameters\n\t     - dx (number) horisontal shift\n\t     - dy (number) vertical shift\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.translate = function (dx, dy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        dx = Str(dx).split(separator);\n\t        if (dx.length - 1) {\n\t            dy = toFloat(dx[1]);\n\t        }\n\t        dx = toFloat(dx[0]) || 0;\n\t        dy = +dy || 0;\n\t        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.transform\n\t     [ method ]\n\t     **\n\t     * Adds transformation to the element which is separate to other attributes,\n\t     * i.e. translation doesnt change `x` or `y` of the rectange. The format\n\t     * of transformation string is similar to the path string syntax:\n\t     | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\n\t     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\n\t     * scale and `m` is for matrix.\n\t     *\n\t     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\n\t     *\n\t     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;\n\t     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin\n\t     * coordinates as optional parameters, the default is the centre point of the element.\n\t     * Matrix accepts six parameters.\n\t     > Usage\n\t     | var el = paper.rect(10, 20, 300, 200);\n\t     | // translate 100, 100, rotate 45, translate -100, 0\n\t     | el.transform(\"t100,100r45t-100,0\");\n\t     | // if you want you can append or prepend transformations\n\t     | el.transform(\"...t50,50\");\n\t     | el.transform(\"s2...\");\n\t     | // or even wrap\n\t     | el.transform(\"t50,50...t-50-50\");\n\t     | // to reset transformation call method with empty string\n\t     | el.transform(\"\");\n\t     | // to get current value call it without parameters\n\t     | console.log(el.transform());\n\t     > Parameters\n\t     - tstr (string) #optional transformation string\n\t     * If tstr isnt specified\n\t     = (string) current transformation string\n\t     * else\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.transform = function (tstr) {\n\t        var _ = this._;\n\t        if (tstr == null) {\n\t            return _.transform;\n\t        }\n\t        R._extractTransform(this, tstr);\n\n\t        this.clip && $(this.clip, {transform: this.matrix.invert()});\n\t        this.pattern && updatePosition(this);\n\t        this.node && $(this.node, {transform: this.matrix});\n\n\t        if (_.sx != 1 || _.sy != 1) {\n\t            var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\n\t            this.attr({\"stroke-width\": sw});\n\t        }\n\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.hide\n\t     [ method ]\n\t     **\n\t     * Makes element invisible. See @Element.show.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.hide = function () {\n\t        if(!this.removed) this.node.style.display = \"none\";\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.show\n\t     [ method ]\n\t     **\n\t     * Makes element visible. See @Element.hide.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.show = function () {\n\t        if(!this.removed) this.node.style.display = \"\";\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.remove\n\t     [ method ]\n\t     **\n\t     * Removes element from the paper.\n\t    \\*/\n\t    elproto.remove = function () {\n\t        var node = getRealNode(this.node);\n\t        if (this.removed || !node.parentNode) {\n\t            return;\n\t        }\n\t        var paper = this.paper;\n\t        paper.__set__ && paper.__set__.exclude(this);\n\t        eve.unbind(\"raphael.*.*.\" + this.id);\n\t        if (this.gradient) {\n\t            paper.defs.removeChild(this.gradient);\n\t        }\n\t        R._tear(this, paper);\n\n\t        node.parentNode.removeChild(node);\n\n\t        // Remove custom data for element\n\t        this.removeData();\n\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        this.removed = true;\n\t    };\n\t    elproto._getBBox = function () {\n\t        if (this.node.style.display == \"none\") {\n\t            this.show();\n\t            var hide = true;\n\t        }\n\t        var canvasHidden = false,\n\t            containerStyle;\n\t        if (this.paper.canvas.parentElement) {\n\t          containerStyle = this.paper.canvas.parentElement.style;\n\t        } //IE10+ can't find parentElement\n\t        else if (this.paper.canvas.parentNode) {\n\t          containerStyle = this.paper.canvas.parentNode.style;\n\t        }\n\n\t        if(containerStyle && containerStyle.display == \"none\") {\n\t          canvasHidden = true;\n\t          containerStyle.display = \"\";\n\t        }\n\t        var bbox = {};\n\t        try {\n\t            bbox = this.node.getBBox();\n\t        } catch(e) {\n\t            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\n\t            bbox = {\n\t                x: this.node.clientLeft,\n\t                y: this.node.clientTop,\n\t                width: this.node.clientWidth,\n\t                height: this.node.clientHeight\n\t            }\n\t        } finally {\n\t            bbox = bbox || {};\n\t            if(canvasHidden){\n\t              containerStyle.display = \"none\";\n\t            }\n\t        }\n\t        hide && this.hide();\n\t        return bbox;\n\t    };\n\t    /*\\\n\t     * Element.attr\n\t     [ method ]\n\t     **\n\t     * Sets the attributes of the element.\n\t     > Parameters\n\t     - attrName (string) attributes name\n\t     - value (string) value\n\t     * or\n\t     - params (object) object of name/value pairs\n\t     * or\n\t     - attrName (string) attributes name\n\t     * or\n\t     - attrNames (array) in this case method returns array of current values for given attribute names\n\t     = (object) @Element if attrsName & value or params are passed in.\n\t     = (...) value of the attribute if only attrsName is passed in.\n\t     = (array) array of values of the attribute if attrsNames is passed in.\n\t     = (object) object of attributes if nothing is passed in.\n\t     > Possible parameters\n\t     # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\n\t     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\n\t     o clip-rect (string) comma or space separated values: x, y, width and height\n\t     o cursor (string) CSS type of the cursor\n\t     o cx (number) the x-axis coordinate of the center of the circle, or ellipse\n\t     o cy (number) the y-axis coordinate of the center of the circle, or ellipse\n\t     o fill (string) colour, gradient or image\n\t     o fill-opacity (number)\n\t     o font (string)\n\t     o font-family (string)\n\t     o font-size (number) font size in pixels\n\t     o font-weight (string)\n\t     o height (number)\n\t     o href (string) URL, if specified element behaves as hyperlink\n\t     o opacity (number)\n\t     o path (string) SVG path string format\n\t     o r (number) radius of the circle, ellipse or rounded corner on the rect\n\t     o rx (number) horisontal radius of the ellipse\n\t     o ry (number) vertical radius of the ellipse\n\t     o src (string) image URL, only works for @Element.image element\n\t     o stroke (string) stroke colour\n\t     o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]\n\t     o stroke-linecap (string) [`butt`, `square`, `round`]\n\t     o stroke-linejoin (string) [`bevel`, `round`, `miter`]\n\t     o stroke-miterlimit (number)\n\t     o stroke-opacity (number)\n\t     o stroke-width (number) stroke width in pixels, default is '1'\n\t     o target (string) used with href\n\t     o text (string) contents of the text element. Use `\\n` for multiline text\n\t     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`\n\t     o title (string) will create tooltip with a given text\n\t     o transform (string) see @Element.transform\n\t     o width (number)\n\t     o x (number)\n\t     o y (number)\n\t     > Gradients\n\t     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90\n\t     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.\n\t     *\n\t     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` \n\t     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point\n\t     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\n\t     > Path String\n\t     # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a paths data attributes format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphal fully supports it.</p>\n\t     > Colour Parsing\n\t     # <ul>\n\t     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n\t     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>\n\t     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>\n\t     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n\t     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n\t     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>\n\t     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>\n\t     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n\t     #     <li>hsb(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsba(, , , )  same as above, but with opacity</li>\n\t     #     <li>hsl(, , )  almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\n\t     #     <li>hsl(%, %, %)  same as above, but in %</li>\n\t     #     <li>hsla(, , , )  same as above, but with opacity</li>\n\t     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>\n\t     # </ul>\n\t    \\*/\n\t    elproto.attr = function (name, value) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (name == null) {\n\t            var res = {};\n\t            for (var a in this.attrs) if (this.attrs[has](a)) {\n\t                res[a] = this.attrs[a];\n\t            }\n\t            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n\t            res.transform = this._.transform;\n\t            return res;\n\t        }\n\t        if (value == null && R.is(name, \"string\")) {\n\t            if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\n\t                return this.attrs.gradient;\n\t            }\n\t            if (name == \"transform\") {\n\t                return this._.transform;\n\t            }\n\t            var names = name.split(separator),\n\t                out = {};\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                name = names[i];\n\t                if (name in this.attrs) {\n\t                    out[name] = this.attrs[name];\n\t                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n\t                    out[name] = this.paper.customAttributes[name].def;\n\t                } else {\n\t                    out[name] = R._availableAttrs[name];\n\t                }\n\t            }\n\t            return ii - 1 ? out : out[names[0]];\n\t        }\n\t        if (value == null && R.is(name, \"array\")) {\n\t            out = {};\n\t            for (i = 0, ii = name.length; i < ii; i++) {\n\t                out[name[i]] = this.attr(name[i]);\n\t            }\n\t            return out;\n\t        }\n\t        if (value != null) {\n\t            var params = {};\n\t            params[name] = value;\n\t        } else if (name != null && R.is(name, \"object\")) {\n\t            params = name;\n\t        }\n\t        for (var key in params) {\n\t            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n\t        }\n\t        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n\t            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n\t            this.attrs[key] = params[key];\n\t            for (var subkey in par) if (par[has](subkey)) {\n\t                params[subkey] = par[subkey];\n\t            }\n\t        }\n\t        setFillAndStroke(this, params);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toFront\n\t     [ method ]\n\t     **\n\t     * Moves the element so it is the closest to the viewers eyes, on top of other elements.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.toFront = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        var node = getRealNode(this.node);\n\t        node.parentNode.appendChild(node);\n\t        var svg = this.paper;\n\t        svg.top != this && R._tofront(this, svg);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.toBack\n\t     [ method ]\n\t     **\n\t     * Moves the element so it is the furthest from the viewers eyes, behind other elements.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.toBack = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        var node = getRealNode(this.node);\n\t        var parentNode = node.parentNode;\n\t        parentNode.insertBefore(node, parentNode.firstChild);\n\t        R._toback(this, this.paper);\n\t        var svg = this.paper;\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertAfter\n\t     [ method ]\n\t     **\n\t     * Inserts current object after the given one.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.insertAfter = function (element) {\n\t        if (this.removed || !element) {\n\t            return this;\n\t        }\n\n\t        var node = getRealNode(this.node);\n\t        var afterNode = getRealNode(element.node || element[element.length - 1].node);\n\t        if (afterNode.nextSibling) {\n\t            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\n\t        } else {\n\t            afterNode.parentNode.appendChild(node);\n\t        }\n\t        R._insertafter(this, element, this.paper);\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Element.insertBefore\n\t     [ method ]\n\t     **\n\t     * Inserts current object before the given one.\n\t     = (object) @Element\n\t    \\*/\n\t    elproto.insertBefore = function (element) {\n\t        if (this.removed || !element) {\n\t            return this;\n\t        }\n\n\t        var node = getRealNode(this.node);\n\t        var beforeNode = getRealNode(element.node || element[0].node);\n\t        beforeNode.parentNode.insertBefore(node, beforeNode);\n\t        R._insertbefore(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.blur = function (size) {\n\t        // Experimental. No Safari support. Use it on your own risk.\n\t        var t = this;\n\t        if (+size !== 0) {\n\t            var fltr = $(\"filter\"),\n\t                blur = $(\"feGaussianBlur\");\n\t            t.attrs.blur = size;\n\t            fltr.id = R.createUUID();\n\t            $(blur, {stdDeviation: +size || 1.5});\n\t            fltr.appendChild(blur);\n\t            t.paper.defs.appendChild(fltr);\n\t            t._blur = fltr;\n\t            $(t.node, {filter: \"url(#\" + fltr.id + \")\"});\n\t        } else {\n\t            if (t._blur) {\n\t                t._blur.parentNode.removeChild(t._blur);\n\t                delete t._blur;\n\t                delete t.attrs.blur;\n\t            }\n\t            t.node.removeAttribute(\"filter\");\n\t        }\n\t        return t;\n\t    };\n\t    R._engine.circle = function (svg, x, y, r) {\n\t        var el = $(\"circle\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {cx: x, cy: y, r: r, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"circle\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.rect = function (svg, x, y, w, h, r) {\n\t        var el = $(\"rect\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"rect\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.ellipse = function (svg, x, y, rx, ry) {\n\t        var el = $(\"ellipse\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: \"none\", stroke: \"#000\"};\n\t        res.type = \"ellipse\";\n\t        $(el, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.image = function (svg, src, x, y, w, h) {\n\t        var el = $(\"image\");\n\t        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: \"none\"});\n\t        el.setAttributeNS(xlink, \"href\", src);\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {x: x, y: y, width: w, height: h, src: src};\n\t        res.type = \"image\";\n\t        return res;\n\t    };\n\t    R._engine.text = function (svg, x, y, text) {\n\t        var el = $(\"text\");\n\t        svg.canvas && svg.canvas.appendChild(el);\n\t        var res = new Element(el, svg);\n\t        res.attrs = {\n\t            x: x,\n\t            y: y,\n\t            \"text-anchor\": \"middle\",\n\t            text: text,\n\t            \"font-family\": R._availableAttrs[\"font-family\"],\n\t            \"font-size\": R._availableAttrs[\"font-size\"],\n\t            stroke: \"none\",\n\t            fill: \"#000\"\n\t        };\n\t        res.type = \"text\";\n\t        setFillAndStroke(res, res.attrs);\n\t        return res;\n\t    };\n\t    R._engine.setSize = function (width, height) {\n\t        this.width = width || this.width;\n\t        this.height = height || this.height;\n\t        this.canvas.setAttribute(\"width\", this.width);\n\t        this.canvas.setAttribute(\"height\", this.height);\n\t        if (this._viewBox) {\n\t            this.setViewBox.apply(this, this._viewBox);\n\t        }\n\t        return this;\n\t    };\n\t    R._engine.create = function () {\n\t        var con = R._getContainer.apply(0, arguments),\n\t            container = con && con.container,\n\t            x = con.x,\n\t            y = con.y,\n\t            width = con.width,\n\t            height = con.height;\n\t        if (!container) {\n\t            throw new Error(\"SVG container not found.\");\n\t        }\n\t        var cnvs = $(\"svg\"),\n\t            css = \"overflow:hidden;\",\n\t            isFloating;\n\t        x = x || 0;\n\t        y = y || 0;\n\t        width = width || 512;\n\t        height = height || 342;\n\t        $(cnvs, {\n\t            height: height,\n\t            version: 1.1,\n\t            width: width,\n\t            xmlns: \"http://www.w3.org/2000/svg\",\n\t            \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n\t        });\n\t        if (container == 1) {\n\t            cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\n\t            R._g.doc.body.appendChild(cnvs);\n\t            isFloating = 1;\n\t        } else {\n\t            cnvs.style.cssText = css + \"position:relative\";\n\t            if (container.firstChild) {\n\t                container.insertBefore(cnvs, container.firstChild);\n\t            } else {\n\t                container.appendChild(cnvs);\n\t            }\n\t        }\n\t        container = new R._Paper;\n\t        container.width = width;\n\t        container.height = height;\n\t        container.canvas = cnvs;\n\t        container.clear();\n\t        container._left = container._top = 0;\n\t        isFloating && (container.renderfix = function () {});\n\t        container.renderfix();\n\t        return container;\n\t    };\n\t    R._engine.setViewBox = function (x, y, w, h, fit) {\n\t        eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n\t        var paperSize = this.getSize(),\n\t            size = mmax(w / paperSize.width, h / paperSize.height),\n\t            top = this.top,\n\t            aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\n\t            vb,\n\t            sw;\n\t        if (x == null) {\n\t            if (this._vbSize) {\n\t                size = 1;\n\t            }\n\t            delete this._vbSize;\n\t            vb = \"0 0 \" + this.width + S + this.height;\n\t        } else {\n\t            this._vbSize = size;\n\t            vb = x + S + y + S + w + S + h;\n\t        }\n\t        $(this.canvas, {\n\t            viewBox: vb,\n\t            preserveAspectRatio: aspectRatio\n\t        });\n\t        while (size && top) {\n\t            sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\n\t            top.attr({\"stroke-width\": sw});\n\t            top._.dirty = 1;\n\t            top._.dirtyT = 1;\n\t            top = top.prev;\n\t        }\n\t        this._viewBox = [x, y, w, h, !!fit];\n\t        return this;\n\t    };\n\t    /*\\\n\t     * Paper.renderfix\n\t     [ method ]\n\t     **\n\t     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent\n\t     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\n\t     * This method fixes the issue.\n\t     **\n\t       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\n\t    \\*/\n\t    R.prototype.renderfix = function () {\n\t        var cnvs = this.canvas,\n\t            s = cnvs.style,\n\t            pos;\n\t        try {\n\t            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\n\t        } catch (e) {\n\t            pos = cnvs.createSVGMatrix();\n\t        }\n\t        var left = -pos.e % 1,\n\t            top = -pos.f % 1;\n\t        if (left || top) {\n\t            if (left) {\n\t                this._left = (this._left + left) % 1;\n\t                s.left = this._left + \"px\";\n\t            }\n\t            if (top) {\n\t                this._top = (this._top + top) % 1;\n\t                s.top = this._top + \"px\";\n\t            }\n\t        }\n\t    };\n\t    /*\\\n\t     * Paper.clear\n\t     [ method ]\n\t     **\n\t     * Clears the paper, i.e. removes all the elements.\n\t    \\*/\n\t    R.prototype.clear = function () {\n\t        R.eve(\"raphael.clear\", this);\n\t        var c = this.canvas;\n\t        while (c.firstChild) {\n\t            c.removeChild(c.firstChild);\n\t        }\n\t        this.bottom = this.top = null;\n\t        (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\n\t        c.appendChild(this.desc);\n\t        c.appendChild(this.defs = $(\"defs\"));\n\t    };\n\t    /*\\\n\t     * Paper.remove\n\t     [ method ]\n\t     **\n\t     * Removes the paper from the DOM.\n\t    \\*/\n\t    R.prototype.remove = function () {\n\t        eve(\"raphael.remove\", this);\n\t        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t    };\n\t    var setproto = R.st;\n\t    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname].apply(el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {\n\t    if (R && !R.vml) {\n\t        return;\n\t    }\n\n\t    var has = \"hasOwnProperty\",\n\t        Str = String,\n\t        toFloat = parseFloat,\n\t        math = Math,\n\t        round = math.round,\n\t        mmax = math.max,\n\t        mmin = math.min,\n\t        abs = math.abs,\n\t        fillString = \"fill\",\n\t        separator = /[, ]+/,\n\t        eve = R.eve,\n\t        ms = \" progid:DXImageTransform.Microsoft\",\n\t        S = \" \",\n\t        E = \"\",\n\t        map = {M: \"m\", L: \"l\", C: \"c\", Z: \"x\", m: \"t\", l: \"r\", c: \"v\", z: \"x\"},\n\t        bites = /([clmz]),?([^clmz]*)/gi,\n\t        blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\n\t        val = /-?[^,\\s-]+/g,\n\t        cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\n\t        zoom = 21600,\n\t        pathTypes = {path: 1, rect: 1, image: 1},\n\t        ovalTypes = {circle: 1, ellipse: 1},\n\t        path2vml = function (path) {\n\t            var total =  /[ahqstv]/ig,\n\t                command = R._pathToAbsolute;\n\t            Str(path).match(total) && (command = R._path2curve);\n\t            total = /[clmz]/g;\n\t            if (command == R._pathToAbsolute && !Str(path).match(total)) {\n\t                var res = Str(path).replace(bites, function (all, command, args) {\n\t                    var vals = [],\n\t                        isMove = command.toLowerCase() == \"m\",\n\t                        res = map[command];\n\t                    args.replace(val, function (value) {\n\t                        if (isMove && vals.length == 2) {\n\t                            res += vals + map[command == \"m\" ? \"l\" : \"L\"];\n\t                            vals = [];\n\t                        }\n\t                        vals.push(round(value * zoom));\n\t                    });\n\t                    return res + vals;\n\t                });\n\t                return res;\n\t            }\n\t            var pa = command(path), p, r;\n\t            res = [];\n\t            for (var i = 0, ii = pa.length; i < ii; i++) {\n\t                p = pa[i];\n\t                r = pa[i][0].toLowerCase();\n\t                r == \"z\" && (r = \"x\");\n\t                for (var j = 1, jj = p.length; j < jj; j++) {\n\t                    r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\n\t                }\n\t                res.push(r);\n\t            }\n\t            return res.join(S);\n\t        },\n\t        compensation = function (deg, dx, dy) {\n\t            var m = R.matrix();\n\t            m.rotate(-deg, .5, .5);\n\t            return {\n\t                dx: m.x(dx, dy),\n\t                dy: m.y(dx, dy)\n\t            };\n\t        },\n\t        setCoords = function (p, sx, sy, dx, dy, deg) {\n\t            var _ = p._,\n\t                m = p.matrix,\n\t                fillpos = _.fillpos,\n\t                o = p.node,\n\t                s = o.style,\n\t                y = 1,\n\t                flip = \"\",\n\t                dxdy,\n\t                kx = zoom / sx,\n\t                ky = zoom / sy;\n\t            s.visibility = \"hidden\";\n\t            if (!sx || !sy) {\n\t                return;\n\t            }\n\t            o.coordsize = abs(kx) + S + abs(ky);\n\t            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\n\t            if (deg) {\n\t                var c = compensation(deg, dx, dy);\n\t                dx = c.dx;\n\t                dy = c.dy;\n\t            }\n\t            sx < 0 && (flip += \"x\");\n\t            sy < 0 && (flip += \" y\") && (y = -1);\n\t            s.flip = flip;\n\t            o.coordorigin = (dx * -kx) + S + (dy * -ky);\n\t            if (fillpos || _.fillsize) {\n\t                var fill = o.getElementsByTagName(fillString);\n\t                fill = fill && fill[0];\n\t                o.removeChild(fill);\n\t                if (fillpos) {\n\t                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\n\t                    fill.position = c.dx * y + S + c.dy * y;\n\t                }\n\t                if (_.fillsize) {\n\t                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\n\t                }\n\t                o.appendChild(fill);\n\t            }\n\t            s.visibility = \"visible\";\n\t        };\n\t    R.toString = function () {\n\t        return  \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xebl \" + this.version;\n\t    };\n\t    var addArrow = function (o, value, isEnd) {\n\t        var values = Str(value).toLowerCase().split(\"-\"),\n\t            se = isEnd ? \"end\" : \"start\",\n\t            i = values.length,\n\t            type = \"classic\",\n\t            w = \"medium\",\n\t            h = \"medium\";\n\t        while (i--) {\n\t            switch (values[i]) {\n\t                case \"block\":\n\t                case \"classic\":\n\t                case \"oval\":\n\t                case \"diamond\":\n\t                case \"open\":\n\t                case \"none\":\n\t                    type = values[i];\n\t                    break;\n\t                case \"wide\":\n\t                case \"narrow\": h = values[i]; break;\n\t                case \"long\":\n\t                case \"short\": w = values[i]; break;\n\t            }\n\t        }\n\t        var stroke = o.node.getElementsByTagName(\"stroke\")[0];\n\t        stroke[se + \"arrow\"] = type;\n\t        stroke[se + \"arrowlength\"] = w;\n\t        stroke[se + \"arrowwidth\"] = h;\n\t    },\n\t    setFillAndStroke = function (o, params) {\n\t        // o.paper.canvas.style.display = \"none\";\n\t        o.attrs = o.attrs || {};\n\t        var node = o.node,\n\t            a = o.attrs,\n\t            s = node.style,\n\t            xy,\n\t            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\n\t            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\n\t            res = o;\n\n\n\t        for (var par in params) if (params[has](par)) {\n\t            a[par] = params[par];\n\t        }\n\t        if (newpath) {\n\t            a.path = R._getPath[o.type](o);\n\t            o._.dirty = 1;\n\t        }\n\t        params.href && (node.href = params.href);\n\t        params.title && (node.title = params.title);\n\t        params.target && (node.target = params.target);\n\t        params.cursor && (s.cursor = params.cursor);\n\t        \"blur\" in params && o.blur(params.blur);\n\t        if (params.path && o.type == \"path\" || newpath) {\n\t            node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\n\t            o._.dirty = 1;\n\t            if (o.type == \"image\") {\n\t                o._.fillpos = [a.x, a.y];\n\t                o._.fillsize = [a.width, a.height];\n\t                setCoords(o, 1, 1, 0, 0, 0);\n\t            }\n\t        }\n\t        \"transform\" in params && o.transform(params.transform);\n\t        if (isOval) {\n\t            var cx = +a.cx,\n\t                cy = +a.cy,\n\t                rx = +a.rx || +a.r || 0,\n\t                ry = +a.ry || +a.r || 0;\n\t            node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\n\t            o._.dirty = 1;\n\t        }\n\t        if (\"clip-rect\" in params) {\n\t            var rect = Str(params[\"clip-rect\"]).split(separator);\n\t            if (rect.length == 4) {\n\t                rect[2] = +rect[2] + (+rect[0]);\n\t                rect[3] = +rect[3] + (+rect[1]);\n\t                var div = node.clipRect || R._g.doc.createElement(\"div\"),\n\t                    dstyle = div.style;\n\t                dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\n\t                if (!node.clipRect) {\n\t                    dstyle.position = \"absolute\";\n\t                    dstyle.top = 0;\n\t                    dstyle.left = 0;\n\t                    dstyle.width = o.paper.width + \"px\";\n\t                    dstyle.height = o.paper.height + \"px\";\n\t                    node.parentNode.insertBefore(div, node);\n\t                    div.appendChild(node);\n\t                    node.clipRect = div;\n\t                }\n\t            }\n\t            if (!params[\"clip-rect\"]) {\n\t                node.clipRect && (node.clipRect.style.clip = \"auto\");\n\t            }\n\t        }\n\t        if (o.textpath) {\n\t            var textpathStyle = o.textpath.style;\n\t            params.font && (textpathStyle.font = params.font);\n\t            params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\n\t            params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\n\t            params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\n\t            params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\n\t        }\n\t        if (\"arrow-start\" in params) {\n\t            addArrow(res, params[\"arrow-start\"]);\n\t        }\n\t        if (\"arrow-end\" in params) {\n\t            addArrow(res, params[\"arrow-end\"], 1);\n\t        }\n\t        if (params.opacity != null ||\n\t            params.fill != null ||\n\t            params.src != null ||\n\t            params.stroke != null ||\n\t            params[\"stroke-width\"] != null ||\n\t            params[\"stroke-opacity\"] != null ||\n\t            params[\"fill-opacity\"] != null ||\n\t            params[\"stroke-dasharray\"] != null ||\n\t            params[\"stroke-miterlimit\"] != null ||\n\t            params[\"stroke-linejoin\"] != null ||\n\t            params[\"stroke-linecap\"] != null) {\n\t            var fill = node.getElementsByTagName(fillString),\n\t                newfill = false;\n\t            fill = fill && fill[0];\n\t            !fill && (newfill = fill = createNode(fillString));\n\t            if (o.type == \"image\" && params.src) {\n\t                fill.src = params.src;\n\t            }\n\t            params.fill && (fill.on = true);\n\t            if (fill.on == null || params.fill == \"none\" || params.fill === null) {\n\t                fill.on = false;\n\t            }\n\t            if (fill.on && params.fill) {\n\t                var isURL = Str(params.fill).match(R._ISURL);\n\t                if (isURL) {\n\t                    fill.parentNode == node && node.removeChild(fill);\n\t                    fill.rotate = true;\n\t                    fill.src = isURL[1];\n\t                    fill.type = \"tile\";\n\t                    var bbox = o.getBBox(1);\n\t                    fill.position = bbox.x + S + bbox.y;\n\t                    o._.fillpos = [bbox.x, bbox.y];\n\n\t                    R._preload(isURL[1], function () {\n\t                        o._.fillsize = [this.offsetWidth, this.offsetHeight];\n\t                    });\n\t                } else {\n\t                    fill.color = R.getRGB(params.fill).hex;\n\t                    fill.src = E;\n\t                    fill.type = \"solid\";\n\t                    if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\n\t                        a.fill = \"none\";\n\t                        a.gradient = params.fill;\n\t                        fill.rotate = false;\n\t                    }\n\t                }\n\t            }\n\t            if (\"fill-opacity\" in params || \"opacity\" in params) {\n\t                var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\n\t                opacity = mmin(mmax(opacity, 0), 1);\n\t                fill.opacity = opacity;\n\t                if (fill.src) {\n\t                    fill.color = \"none\";\n\t                }\n\t            }\n\t            node.appendChild(fill);\n\t            var stroke = (node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0]),\n\t            newstroke = false;\n\t            !stroke && (newstroke = stroke = createNode(\"stroke\"));\n\t            if ((params.stroke && params.stroke != \"none\") ||\n\t                params[\"stroke-width\"] ||\n\t                params[\"stroke-opacity\"] != null ||\n\t                params[\"stroke-dasharray\"] ||\n\t                params[\"stroke-miterlimit\"] ||\n\t                params[\"stroke-linejoin\"] ||\n\t                params[\"stroke-linecap\"]) {\n\t                stroke.on = true;\n\t            }\n\t            (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\n\t            var strokeColor = R.getRGB(params.stroke);\n\t            stroke.on && params.stroke && (stroke.color = strokeColor.hex);\n\t            opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\n\t            var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\n\t            opacity = mmin(mmax(opacity, 0), 1);\n\t            params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\n\t            params[\"stroke-width\"] && (stroke.weight = width);\n\t            width && width < 1 && (opacity *= width) && (stroke.weight = 1);\n\t            stroke.opacity = opacity;\n\n\t            params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\n\t            stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\n\t            params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\n\t            if (\"stroke-dasharray\" in params) {\n\t                var dasharray = {\n\t                    \"-\": \"shortdash\",\n\t                    \".\": \"shortdot\",\n\t                    \"-.\": \"shortdashdot\",\n\t                    \"-..\": \"shortdashdotdot\",\n\t                    \". \": \"dot\",\n\t                    \"- \": \"dash\",\n\t                    \"--\": \"longdash\",\n\t                    \"- .\": \"dashdot\",\n\t                    \"--.\": \"longdashdot\",\n\t                    \"--..\": \"longdashdotdot\"\n\t                };\n\t                stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\n\t            }\n\t            newstroke && node.appendChild(stroke);\n\t        }\n\t        if (res.type == \"text\") {\n\t            res.paper.canvas.style.display = E;\n\t            var span = res.paper.span,\n\t                m = 100,\n\t                fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\n\t            s = span.style;\n\t            a.font && (s.font = a.font);\n\t            a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\n\t            a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\n\t            a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\n\t            fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\n\t            s.fontSize = fontSize * m + \"px\";\n\t            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\n\t            var brect = span.getBoundingClientRect();\n\t            res.W = a.w = (brect.right - brect.left) / m;\n\t            res.H = a.h = (brect.bottom - brect.top) / m;\n\t            // res.paper.canvas.style.display = \"none\";\n\t            res.X = a.x;\n\t            res.Y = a.y + res.H / 2;\n\n\t            (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\n\t            var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\n\t            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {\n\t                res._.dirty = 1;\n\t                break;\n\t            }\n\n\t            // text-anchor emulation\n\t            switch (a[\"text-anchor\"]) {\n\t                case \"start\":\n\t                    res.textpath.style[\"v-text-align\"] = \"left\";\n\t                    res.bbx = res.W / 2;\n\t                break;\n\t                case \"end\":\n\t                    res.textpath.style[\"v-text-align\"] = \"right\";\n\t                    res.bbx = -res.W / 2;\n\t                break;\n\t                default:\n\t                    res.textpath.style[\"v-text-align\"] = \"center\";\n\t                    res.bbx = 0;\n\t                break;\n\t            }\n\t            res.textpath.style[\"v-text-kern\"] = true;\n\t        }\n\t        // res.paper.canvas.style.display = E;\n\t    },\n\t    addGradientFill = function (o, gradient, fill) {\n\t        o.attrs = o.attrs || {};\n\t        var attrs = o.attrs,\n\t            pow = Math.pow,\n\t            opacity,\n\t            oindex,\n\t            type = \"linear\",\n\t            fxfy = \".5 .5\";\n\t        o.attrs.gradient = gradient;\n\t        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\n\t            type = \"radial\";\n\t            if (fx && fy) {\n\t                fx = toFloat(fx);\n\t                fy = toFloat(fy);\n\t                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\n\t                fxfy = fx + S + fy;\n\t            }\n\t            return E;\n\t        });\n\t        gradient = gradient.split(/\\s*\\-\\s*/);\n\t        if (type == \"linear\") {\n\t            var angle = gradient.shift();\n\t            angle = -toFloat(angle);\n\t            if (isNaN(angle)) {\n\t                return null;\n\t            }\n\t        }\n\t        var dots = R._parseDots(gradient);\n\t        if (!dots) {\n\t            return null;\n\t        }\n\t        o = o.shape || o.node;\n\t        if (dots.length) {\n\t            o.removeChild(fill);\n\t            fill.on = true;\n\t            fill.method = \"none\";\n\t            fill.color = dots[0].color;\n\t            fill.color2 = dots[dots.length - 1].color;\n\t            var clrs = [];\n\t            for (var i = 0, ii = dots.length; i < ii; i++) {\n\t                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\n\t            }\n\t            fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\n\t            if (type == \"radial\") {\n\t                fill.type = \"gradientTitle\";\n\t                fill.focus = \"100%\";\n\t                fill.focussize = \"0 0\";\n\t                fill.focusposition = fxfy;\n\t                fill.angle = 0;\n\t            } else {\n\t                // fill.rotate= true;\n\t                fill.type = \"gradient\";\n\t                fill.angle = (270 - angle) % 360;\n\t            }\n\t            o.appendChild(fill);\n\t        }\n\t        return 1;\n\t    },\n\t    Element = function (node, vml) {\n\t        this[0] = this.node = node;\n\t        node.raphael = true;\n\t        this.id = R._oid++;\n\t        node.raphaelid = this.id;\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.attrs = {};\n\t        this.paper = vml;\n\t        this.matrix = R.matrix();\n\t        this._ = {\n\t            transform: [],\n\t            sx: 1,\n\t            sy: 1,\n\t            dx: 0,\n\t            dy: 0,\n\t            deg: 0,\n\t            dirty: 1,\n\t            dirtyT: 1\n\t        };\n\t        !vml.bottom && (vml.bottom = this);\n\t        this.prev = vml.top;\n\t        vml.top && (vml.top.next = this);\n\t        vml.top = this;\n\t        this.next = null;\n\t    };\n\t    var elproto = R.el;\n\n\t    Element.prototype = elproto;\n\t    elproto.constructor = Element;\n\t    elproto.transform = function (tstr) {\n\t        if (tstr == null) {\n\t            return this._.transform;\n\t        }\n\t        var vbs = this.paper._viewBoxShift,\n\t            vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\n\t            oldt;\n\t        if (vbs) {\n\t            oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\n\t        }\n\t        R._extractTransform(this, vbt + tstr);\n\t        var matrix = this.matrix.clone(),\n\t            skew = this.skew,\n\t            o = this.node,\n\t            split,\n\t            isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\n\t            isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\n\t        matrix.translate(1, 1);\n\t        if (isPatt || isGrad || this.type == \"image\") {\n\t            skew.matrix = \"1 0 0 1\";\n\t            skew.offset = \"0 0\";\n\t            split = matrix.split();\n\t            if ((isGrad && split.noRotation) || !split.isSimple) {\n\t                o.style.filter = matrix.toFilter();\n\t                var bb = this.getBBox(),\n\t                    bbt = this.getBBox(1),\n\t                    dx = bb.x - bbt.x,\n\t                    dy = bb.y - bbt.y;\n\t                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);\n\t                setCoords(this, 1, 1, dx, dy, 0);\n\t            } else {\n\t                o.style.filter = E;\n\t                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\n\t            }\n\t        } else {\n\t            o.style.filter = E;\n\t            skew.matrix = Str(matrix);\n\t            skew.offset = matrix.offset();\n\t        }\n\t        if (oldt !== null) { // empty string value is true as well\n\t            this._.transform = oldt;\n\t            R._extractTransform(this, oldt);\n\t        }\n\t        return this;\n\t    };\n\t    elproto.rotate = function (deg, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (deg == null) {\n\t            return;\n\t        }\n\t        deg = Str(deg).split(separator);\n\t        if (deg.length - 1) {\n\t            cx = toFloat(deg[1]);\n\t            cy = toFloat(deg[2]);\n\t        }\n\t        deg = toFloat(deg[0]);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t            cx = bbox.x + bbox.width / 2;\n\t            cy = bbox.y + bbox.height / 2;\n\t        }\n\t        this._.dirtyT = 1;\n\t        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\n\t        return this;\n\t    };\n\t    elproto.translate = function (dx, dy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        dx = Str(dx).split(separator);\n\t        if (dx.length - 1) {\n\t            dy = toFloat(dx[1]);\n\t        }\n\t        dx = toFloat(dx[0]) || 0;\n\t        dy = +dy || 0;\n\t        if (this._.bbox) {\n\t            this._.bbox.x += dx;\n\t            this._.bbox.y += dy;\n\t        }\n\t        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\n\t        return this;\n\t    };\n\t    elproto.scale = function (sx, sy, cx, cy) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        sx = Str(sx).split(separator);\n\t        if (sx.length - 1) {\n\t            sy = toFloat(sx[1]);\n\t            cx = toFloat(sx[2]);\n\t            cy = toFloat(sx[3]);\n\t            isNaN(cx) && (cx = null);\n\t            isNaN(cy) && (cy = null);\n\t        }\n\t        sx = toFloat(sx[0]);\n\t        (sy == null) && (sy = sx);\n\t        (cy == null) && (cx = cy);\n\t        if (cx == null || cy == null) {\n\t            var bbox = this.getBBox(1);\n\t        }\n\t        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\n\t        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\n\n\t        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\n\t        this._.dirtyT = 1;\n\t        return this;\n\t    };\n\t    elproto.hide = function () {\n\t        !this.removed && (this.node.style.display = \"none\");\n\t        return this;\n\t    };\n\t    elproto.show = function () {\n\t        !this.removed && (this.node.style.display = E);\n\t        return this;\n\t    };\n\t    // Needed to fix the vml setViewBox issues\n\t    elproto.auxGetBBox = R.el.getBBox;\n\t    elproto.getBBox = function(){\n\t      var b = this.auxGetBBox();\n\t      if (this.paper && this.paper._viewBoxShift)\n\t      {\n\t        var c = {};\n\t        var z = 1/this.paper._viewBoxShift.scale;\n\t        c.x = b.x - this.paper._viewBoxShift.dx;\n\t        c.x *= z;\n\t        c.y = b.y - this.paper._viewBoxShift.dy;\n\t        c.y *= z;\n\t        c.width  = b.width  * z;\n\t        c.height = b.height * z;\n\t        c.x2 = c.x + c.width;\n\t        c.y2 = c.y + c.height;\n\t        return c;\n\t      }\n\t      return b;\n\t    };\n\t    elproto._getBBox = function () {\n\t        if (this.removed) {\n\t            return {};\n\t        }\n\t        return {\n\t            x: this.X + (this.bbx || 0) - this.W / 2,\n\t            y: this.Y - this.H,\n\t            width: this.W,\n\t            height: this.H\n\t        };\n\t    };\n\t    elproto.remove = function () {\n\t        if (this.removed || !this.node.parentNode) {\n\t            return;\n\t        }\n\t        this.paper.__set__ && this.paper.__set__.exclude(this);\n\t        R.eve.unbind(\"raphael.*.*.\" + this.id);\n\t        R._tear(this, this.paper);\n\t        this.node.parentNode.removeChild(this.node);\n\t        this.shape && this.shape.parentNode.removeChild(this.shape);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        this.removed = true;\n\t    };\n\t    elproto.attr = function (name, value) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (name == null) {\n\t            var res = {};\n\t            for (var a in this.attrs) if (this.attrs[has](a)) {\n\t                res[a] = this.attrs[a];\n\t            }\n\t            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\n\t            res.transform = this._.transform;\n\t            return res;\n\t        }\n\t        if (value == null && R.is(name, \"string\")) {\n\t            if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\n\t                return this.attrs.gradient;\n\t            }\n\t            var names = name.split(separator),\n\t                out = {};\n\t            for (var i = 0, ii = names.length; i < ii; i++) {\n\t                name = names[i];\n\t                if (name in this.attrs) {\n\t                    out[name] = this.attrs[name];\n\t                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\n\t                    out[name] = this.paper.customAttributes[name].def;\n\t                } else {\n\t                    out[name] = R._availableAttrs[name];\n\t                }\n\t            }\n\t            return ii - 1 ? out : out[names[0]];\n\t        }\n\t        if (this.attrs && value == null && R.is(name, \"array\")) {\n\t            out = {};\n\t            for (i = 0, ii = name.length; i < ii; i++) {\n\t                out[name[i]] = this.attr(name[i]);\n\t            }\n\t            return out;\n\t        }\n\t        var params;\n\t        if (value != null) {\n\t            params = {};\n\t            params[name] = value;\n\t        }\n\t        value == null && R.is(name, \"object\") && (params = name);\n\t        for (var key in params) {\n\t            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\n\t        }\n\t        if (params) {\n\t            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\n\t                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\n\t                this.attrs[key] = params[key];\n\t                for (var subkey in par) if (par[has](subkey)) {\n\t                    params[subkey] = par[subkey];\n\t                }\n\t            }\n\t            // this.paper.canvas.style.display = \"none\";\n\t            if (params.text && this.type == \"text\") {\n\t                this.textpath.string = params.text;\n\t            }\n\t            setFillAndStroke(this, params);\n\t            // this.paper.canvas.style.display = E;\n\t        }\n\t        return this;\n\t    };\n\t    elproto.toFront = function () {\n\t        !this.removed && this.node.parentNode.appendChild(this.node);\n\t        this.paper && this.paper.top != this && R._tofront(this, this.paper);\n\t        return this;\n\t    };\n\t    elproto.toBack = function () {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (this.node.parentNode.firstChild != this.node) {\n\t            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\n\t            R._toback(this, this.paper);\n\t        }\n\t        return this;\n\t    };\n\t    elproto.insertAfter = function (element) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (element.constructor == R.st.constructor) {\n\t            element = element[element.length - 1];\n\t        }\n\t        if (element.node.nextSibling) {\n\t            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\n\t        } else {\n\t            element.node.parentNode.appendChild(this.node);\n\t        }\n\t        R._insertafter(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.insertBefore = function (element) {\n\t        if (this.removed) {\n\t            return this;\n\t        }\n\t        if (element.constructor == R.st.constructor) {\n\t            element = element[0];\n\t        }\n\t        element.node.parentNode.insertBefore(this.node, element.node);\n\t        R._insertbefore(this, element, this.paper);\n\t        return this;\n\t    };\n\t    elproto.blur = function (size) {\n\t        var s = this.node.runtimeStyle,\n\t            f = s.filter;\n\t        f = f.replace(blurregexp, E);\n\t        if (+size !== 0) {\n\t            this.attrs.blur = size;\n\t            s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\n\t            s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\n\t        } else {\n\t            s.filter = f;\n\t            s.margin = 0;\n\t            delete this.attrs.blur;\n\t        }\n\t        return this;\n\t    };\n\n\t    R._engine.path = function (pathString, vml) {\n\t        var el = createNode(\"shape\");\n\t        el.style.cssText = cssDot;\n\t        el.coordsize = zoom + S + zoom;\n\t        el.coordorigin = vml.coordorigin;\n\t        var p = new Element(el, vml),\n\t            attr = {fill: \"none\", stroke: \"#000\"};\n\t        pathString && (attr.path = pathString);\n\t        p.type = \"path\";\n\t        p.path = [];\n\t        p.Path = E;\n\t        setFillAndStroke(p, attr);\n\t        vml.canvas && vml.canvas.appendChild(el);\n\t        var skew = createNode(\"skew\");\n\t        skew.on = true;\n\t        el.appendChild(skew);\n\t        p.skew = skew;\n\t        p.transform(E);\n\t        return p;\n\t    };\n\t    R._engine.rect = function (vml, x, y, w, h, r) {\n\t        var path = R._rectPath(x, y, w, h, r),\n\t            res = vml.path(path),\n\t            a = res.attrs;\n\t        res.X = a.x = x;\n\t        res.Y = a.y = y;\n\t        res.W = a.width = w;\n\t        res.H = a.height = h;\n\t        a.r = r;\n\t        a.path = path;\n\t        res.type = \"rect\";\n\t        return res;\n\t    };\n\t    R._engine.ellipse = function (vml, x, y, rx, ry) {\n\t        var res = vml.path(),\n\t            a = res.attrs;\n\t        res.X = x - rx;\n\t        res.Y = y - ry;\n\t        res.W = rx * 2;\n\t        res.H = ry * 2;\n\t        res.type = \"ellipse\";\n\t        setFillAndStroke(res, {\n\t            cx: x,\n\t            cy: y,\n\t            rx: rx,\n\t            ry: ry\n\t        });\n\t        return res;\n\t    };\n\t    R._engine.circle = function (vml, x, y, r) {\n\t        var res = vml.path(),\n\t            a = res.attrs;\n\t        res.X = x - r;\n\t        res.Y = y - r;\n\t        res.W = res.H = r * 2;\n\t        res.type = \"circle\";\n\t        setFillAndStroke(res, {\n\t            cx: x,\n\t            cy: y,\n\t            r: r\n\t        });\n\t        return res;\n\t    };\n\t    R._engine.image = function (vml, src, x, y, w, h) {\n\t        var path = R._rectPath(x, y, w, h),\n\t            res = vml.path(path).attr({stroke: \"none\"}),\n\t            a = res.attrs,\n\t            node = res.node,\n\t            fill = node.getElementsByTagName(fillString)[0];\n\t        a.src = src;\n\t        res.X = a.x = x;\n\t        res.Y = a.y = y;\n\t        res.W = a.width = w;\n\t        res.H = a.height = h;\n\t        a.path = path;\n\t        res.type = \"image\";\n\t        fill.parentNode == node && node.removeChild(fill);\n\t        fill.rotate = true;\n\t        fill.src = src;\n\t        fill.type = \"tile\";\n\t        res._.fillpos = [x, y];\n\t        res._.fillsize = [w, h];\n\t        node.appendChild(fill);\n\t        setCoords(res, 1, 1, 0, 0, 0);\n\t        return res;\n\t    };\n\t    R._engine.text = function (vml, x, y, text) {\n\t        var el = createNode(\"shape\"),\n\t            path = createNode(\"path\"),\n\t            o = createNode(\"textpath\");\n\t        x = x || 0;\n\t        y = y || 0;\n\t        text = text || \"\";\n\t        path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\n\t        path.textpathok = true;\n\t        o.string = Str(text);\n\t        o.on = true;\n\t        el.style.cssText = cssDot;\n\t        el.coordsize = zoom + S + zoom;\n\t        el.coordorigin = \"0 0\";\n\t        var p = new Element(el, vml),\n\t            attr = {\n\t                fill: \"#000\",\n\t                stroke: \"none\",\n\t                font: R._availableAttrs.font,\n\t                text: text\n\t            };\n\t        p.shape = el;\n\t        p.path = path;\n\t        p.textpath = o;\n\t        p.type = \"text\";\n\t        p.attrs.text = Str(text);\n\t        p.attrs.x = x;\n\t        p.attrs.y = y;\n\t        p.attrs.w = 1;\n\t        p.attrs.h = 1;\n\t        setFillAndStroke(p, attr);\n\t        el.appendChild(o);\n\t        el.appendChild(path);\n\t        vml.canvas.appendChild(el);\n\t        var skew = createNode(\"skew\");\n\t        skew.on = true;\n\t        el.appendChild(skew);\n\t        p.skew = skew;\n\t        p.transform(E);\n\t        return p;\n\t    };\n\t    R._engine.setSize = function (width, height) {\n\t        var cs = this.canvas.style;\n\t        this.width = width;\n\t        this.height = height;\n\t        width == +width && (width += \"px\");\n\t        height == +height && (height += \"px\");\n\t        cs.width = width;\n\t        cs.height = height;\n\t        cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\n\t        if (this._viewBox) {\n\t            R._engine.setViewBox.apply(this, this._viewBox);\n\t        }\n\t        return this;\n\t    };\n\t    R._engine.setViewBox = function (x, y, w, h, fit) {\n\t        R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\n\t        var paperSize = this.getSize(),\n\t            width = paperSize.width,\n\t            height = paperSize.height,\n\t            H, W;\n\t        if (fit) {\n\t            H = height / h;\n\t            W = width / w;\n\t            if (w * H < width) {\n\t                x -= (width - w * H) / 2 / H;\n\t            }\n\t            if (h * W < height) {\n\t                y -= (height - h * W) / 2 / W;\n\t            }\n\t        }\n\t        this._viewBox = [x, y, w, h, !!fit];\n\t        this._viewBoxShift = {\n\t            dx: -x,\n\t            dy: -y,\n\t            scale: paperSize\n\t        };\n\t        this.forEach(function (el) {\n\t            el.transform(\"...\");\n\t        });\n\t        return this;\n\t    };\n\t    var createNode;\n\t    R._engine.initWin = function (win) {\n\t            var doc = win.document;\n\t            if (doc.styleSheets.length < 31) {\n\t                doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\n\t            } else {\n\t                // no more room, add to the existing one\n\t                // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t                doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\n\t            }\n\t            try {\n\t                !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\n\t                createNode = function (tagName) {\n\t                    return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\n\t                };\n\t            } catch (e) {\n\t                createNode = function (tagName) {\n\t                    return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\n\t                };\n\t            }\n\t        };\n\t    R._engine.initWin(R._g.win);\n\t    R._engine.create = function () {\n\t        var con = R._getContainer.apply(0, arguments),\n\t            container = con.container,\n\t            height = con.height,\n\t            s,\n\t            width = con.width,\n\t            x = con.x,\n\t            y = con.y;\n\t        if (!container) {\n\t            throw new Error(\"VML container not found.\");\n\t        }\n\t        var res = new R._Paper,\n\t            c = res.canvas = R._g.doc.createElement(\"div\"),\n\t            cs = c.style;\n\t        x = x || 0;\n\t        y = y || 0;\n\t        width = width || 512;\n\t        height = height || 342;\n\t        res.width = width;\n\t        res.height = height;\n\t        width == +width && (width += \"px\");\n\t        height == +height && (height += \"px\");\n\t        res.coordsize = zoom * 1e3 + S + zoom * 1e3;\n\t        res.coordorigin = \"0 0\";\n\t        res.span = R._g.doc.createElement(\"span\");\n\t        res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\n\t        c.appendChild(res.span);\n\t        cs.cssText = R.format(\"top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden\", width, height);\n\t        if (container == 1) {\n\t            R._g.doc.body.appendChild(c);\n\t            cs.left = x + \"px\";\n\t            cs.top = y + \"px\";\n\t            cs.position = \"absolute\";\n\t        } else {\n\t            if (container.firstChild) {\n\t                container.insertBefore(c, container.firstChild);\n\t            } else {\n\t                container.appendChild(c);\n\t            }\n\t        }\n\t        res.renderfix = function () {};\n\t        return res;\n\t    };\n\t    R.prototype.clear = function () {\n\t        R.eve(\"raphael.clear\", this);\n\t        this.canvas.innerHTML = E;\n\t        this.span = R._g.doc.createElement(\"span\");\n\t        this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\n\t        this.canvas.appendChild(this.span);\n\t        this.bottom = this.top = null;\n\t    };\n\t    R.prototype.remove = function () {\n\t        R.eve(\"raphael.remove\", this);\n\t        this.canvas.parentNode.removeChild(this.canvas);\n\t        for (var i in this) {\n\t            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\n\t        }\n\t        return true;\n\t    };\n\n\t    var setproto = R.st;\n\t    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\n\t        setproto[method] = (function (methodname) {\n\t            return function () {\n\t                var arg = arguments;\n\t                return this.forEach(function (el) {\n\t                    el[methodname].apply(el, arg);\n\t                });\n\t            };\n\t        })(method);\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raphael/raphael.js\n// module id = 3\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../css-loader/index.js!./morris.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../vue-style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../css-loader/index.js!./morris.css\", function() {\n\t\t\tvar newContent = require(\"!!./../css-loader/index.js!./morris.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/morris.js/morris.css\n// module id = 4\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 5\n// module chunks = 0","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./area-chart.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-756f4bcb!vue-loader/lib/selector?type=template&index=0!./area-chart.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/area-chart.vue\n// module id = 6\n// module chunks = 0","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./bar-chart.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-674d63f2!vue-loader/lib/selector?type=template&index=0!./bar-chart.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/bar-chart.vue\n// module id = 7\n// module chunks = 0","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./donut-chart.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-6091d8d4!vue-loader/lib/selector?type=template&index=0!./donut-chart.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/donut-chart.vue\n// module id = 8\n// module chunks = 0","var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* script */\n__vue_exports__ = require(\"!!babel-loader!vue-loader/lib/selector?type=script&index=0!./line-chart.vue\")\n\n/* template */\nvar __vue_template__ = require(\"!!vue-loader/lib/template-compiler?id=data-v-602d5672!vue-loader/lib/selector?type=template&index=0!./line-chart.vue\")\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\nmodule.exports = __vue_exports__\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/line-chart.vue\n// module id = 9\n// module chunks = 0","<template>\r\n  <div :id=\"id\"></div>\r\n</template>\r\n\r\n<script>\r\nimport Raphael from 'raphael/raphael'\r\nglobal.Raphael = Raphael\r\nimport 'morris.js/morris'\r\nimport 'morris.js/morris.css'\r\nimport Converter from '../util/converter'\r\nimport ChartProps from './chart-props'\r\n\r\nexport default {\r\n  name: 'area-chart',\r\n\r\n  mixins: [ ChartProps.area ],\r\n\r\n  data () {\r\n    return {\r\n      chart: null\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    data (val) {\r\n      this.$nextTick(() => {\r\n        this.chart.setData(Converter.toObject(this.data))\r\n      })\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    let options = {\r\n      element: this.id,\r\n      data: Converter.toObject(this.data),\r\n      resize: Converter.toBoolean(this.resize),\r\n      labels: Converter.toObject(this.labels),\r\n      xkey: this.xkey,\r\n      ykeys: Converter.toObject(this.ykeys),\r\n      grid: Converter.toBoolean(this.grid),\r\n      gridTextColor: this.gridTextColor,\r\n      gridTextSize: Converter.toInt(this.gridTextSize),\r\n      gridTextFamily: this.gridTextFamily,\r\n      gridTextWeight: this.gridTextWeight\r\n    }\r\n\r\n    if (this.lineColors) {\r\n      options.lineColors = Converter.toObject(this.lineColors)\r\n    }\r\n\r\n    if (this.xLabels) {\r\n      options.xLabels = this.xLabels\r\n    }\r\n\r\n    console.log(options.data)\r\n\r\n    this.chart = Morris.Area(options)\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// area-chart.vue?491a9510","<template>\r\n  <div :id=\"id\"></div>\r\n</template>\r\n\r\n<script>\r\nimport Raphael from 'raphael/raphael'\r\nglobal.Raphael = Raphael\r\nimport 'morris.js/morris'\r\nimport 'morris.js/morris.css'\r\nimport Converter from '../util/converter'\r\nimport ChartProps from './chart-props'\r\n\r\nexport default {\r\n  name: 'bar-chart',\r\n\r\n  data () {\r\n    return {\r\n      chart: null\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    data (val) {\r\n      this.$nextTick(() => {\r\n        this.chart.setData(this.data)\r\n      })\r\n    }\r\n  },\r\n\r\n  mixins: [ ChartProps.bar ],\r\n\r\n  mounted () {\r\n    let options = {\r\n      element: this.id,\r\n      data: Converter.toObject(this.data),\r\n      labels: Converter.toObject(this.labels),\r\n      resize: Converter.toBoolean(this.resize),\r\n      xkey: this.xkey,\r\n      ykeys: Converter.toObject(this.ykeys),\r\n      axes: Converter.toBoolean(this.axes),\r\n      hideHover: this.hideHover,\r\n      stacked: Converter.toBoolean(this.stacked),\r\n      grid: Converter.toBoolean(this.grid),\r\n      gridTextColor: this.gridTextColor,\r\n      gridTextSize: Converter.toInt(this.gridTextSize),\r\n      gridTextFamily: this.gridTextFamily,\r\n      gridTextWeight: this.gridTextWeight\r\n    }\r\n\r\n    if (this.barColors) {\r\n      options.barColors = Converter.toObject(this.barColors)\r\n    }\r\n\r\n    if (this.hoverCallback) {\r\n      options.hoverCallback = this.hoverCallback\r\n    }\r\n\r\n    this.chart = Morris.Bar(options)\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// bar-chart.vue?7b8d53e1","<template>\r\n  <div :id=\"id\"></div>\r\n</template>\r\n\r\n<script>\r\nimport Raphael from 'raphael/raphael'\r\nglobal.Raphael = Raphael\r\nimport 'morris.js/morris'\r\nimport 'morris.js/morris.css'\r\nimport Converter from '../util/converter'\r\nimport ChartProps from './chart-props'\r\n\r\nexport default {\r\n  name: 'donut-chart',\r\n\r\n  data () {\r\n    return {\r\n      chart: null\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    data (val) {\r\n      this.$nextTick(() => {\r\n        this.chart.setData(Converter.toObject(this.data))\r\n      })\r\n    }\r\n  },\r\n\r\n  mixins: [ ChartProps.donut ],\r\n\r\n  mounted () {\r\n    let options = {\r\n      element: this.id,\r\n      data: Converter.toObject(this.data),\r\n      resize: Converter.toBoolean(this.resize)\r\n    }\r\n\r\n    if (this.colors) {\r\n      options.colors = Converter.toObject(this.colors)\r\n    }\r\n\r\n    if (this.formatter) {\r\n      options.formatter = this.formatter\r\n    }\r\n\r\n    this.chart = Morris.Donut(options)\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// donut-chart.vue?7f9168ca","<template>\r\n  <div :id=\"id\"></div>\r\n</template>\r\n\r\n<script>\r\nimport Raphael from 'raphael/raphael'\r\nglobal.Raphael = Raphael\r\nimport 'morris.js/morris'\r\nimport 'morris.js/morris.css'\r\nimport Converter from '../util/converter'\r\nimport ChartProps from './chart-props'\r\n\r\nexport default {\r\n  name: 'line-chart',\r\n\r\n  mixins: [ ChartProps.line ],\r\n\r\n  data () {\r\n    return {\r\n      chart: null\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    data (val) {\r\n      this.$nextTick(() => {\r\n        this.chart.setData(Converter.toObject(this.data))\r\n      })\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    let options = {\r\n      element: this.id,\r\n      data: Converter.toObject(this.data),\r\n      resize: Converter.toBoolean(this.resize),\r\n      labels: Converter.toObject(this.labels),\r\n      xkey: this.xkey,\r\n      ykeys: Converter.toObject(this.ykeys),\r\n      grid: Converter.toBoolean(this.grid),\r\n      gridTextColor: this.gridTextColor,\r\n      gridTextSize: Converter.toInt(this.gridTextSize),\r\n      gridTextFamily: this.gridTextFamily,\r\n      gridTextWeight: this.gridTextWeight\r\n    }\r\n\r\n    if (this.lineColors) {\r\n      options.lineColors = Converter.toObject(this.lineColors)\r\n    }\r\n\r\n    if (this.xLabels) {\r\n      options.xLabels = this.xLabels\r\n    }\r\n\r\n    console.log(options.data)\r\n\r\n    this.chart = Morris.Line(options)\r\n  }\r\n}\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// line-chart.vue?d82ede84","exports = module.exports = require(\"./../css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".morris-hover{position:absolute;z-index:1000}.morris-hover.morris-default-style{border-radius:10px;padding:6px;color:#666;background:hsla(0,0%,100%,.8);border:2px solid hsla(0,0%,90%,.8);font-family:sans-serif;font-size:12px;text-align:center}.morris-hover.morris-default-style .morris-hover-row-label{font-weight:700;margin:.25em 0}.morris-hover.morris-default-style .morris-hover-point{white-space:nowrap;margin:.1em 0}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/morris.js/morris.css\n// module id = 14\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 15\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-602d5672!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/line-chart.vue\n// module id = 16\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-6091d8d4!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/donut-chart.vue\n// module id = 17\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-674d63f2!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/bar-chart.vue\n// module id = 18\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": _vm.id\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-756f4bcb!./~/vue-loader/lib/selector.js?type=template&index=0!./src/components/area-chart.vue\n// module id = 19\n// module chunks = 0","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/addStyles.js\n// module id = 20\n// module chunks = 0","import DonutChart from './components/donut-chart.vue'\nimport BarChart from './components/bar-chart.vue'\nimport LineChart from './components/line-chart.vue'\nimport AreaChart from './components/area-chart.vue'\n\nconst VueMorris = {\n  DonutChart, BarChart, LineChart, AreaChart\n}\n\nmodule.exports = VueMorris\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}